# -*- coding: utf-8 -*-
"""
/***************************************************************************
 walidatorPlikowGML
                                 A QGIS plugin
 Walidator plików GML baz BDOT10k, PRNG, GESUT, EGiB, BDOT500
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-12-23
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Marcin Lebiecki - Główny Urząd Geodezji i Kartografii
        email                : marcin.lebiecki@gugik.gov.pl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import lxml
import os, subprocess
import zipfile
import pathlib
import pandas as pd
import re
import xml.etree.ElementTree as et
import matplotlib.pyplot
import time
import xlwt
import osgeo
import hashlib
import binascii
from lxml.etree import parse, XMLSchema
from lxml import etree # TODO
from time import sleep
from datetime import datetime
from osgeo import ogr,osr, gdal
from qgis.PyQt.QtCore import *
from qgis.core import *
from qgis.gui import *
from qgis.utils import *
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import *
from qgis.PyQt.QtWidgets import QFileDialog, QProgressBar, QMessageBox, QAction
from .resources import *
from .utils import *
from .walidatorPlikowGML_dialog import walidatorPlikowGMLDialog
from osgeo_utils.samples import ogr2ogr
from .fpdf import FPDF
from .fpdf import FontFace



class walidatorPlikowGML:

    def __init__(self, iface):
        self.iface = iface
        self.plugin_dir = os.path.dirname(__file__)
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(self.plugin_dir,'i18n','walidatorPlikowGML_{}.qm'.format(locale))
        
        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)
            
        self.actions = []
        self.menu = self.tr(u'&Walidator plików GML')
        self.first_start = None
        
        os.environ['QT_AUTO_SCREEN_SCALE_FACTOR'] = '1'
        
        global mainPath, config, dlg
        
        mainPath = pathlib.Path(QgsApplication.qgisSettingsDirPath())/pathlib.Path("python/plugins/Walidator_plikow_gml/")
        
        config = configparser.ConfigParser()
        config.read(str(mainPath)+'/Walidator_plikow_gml.ini')


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        return QCoreApplication.translate('walidatorPlikowGML', message)


    def add_action(self,icon_path,text,callback,enabled_flag=True,add_to_menu=True,add_to_toolbar=True,status_tip=None,whats_this=None,parent=None):
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)
        if status_tip is not None:
            action.setStatusTip(status_tip)
            
        if whats_this is not None:
            action.setWhatsThis(whats_this)
            
        if add_to_toolbar:
            self.iface.addToolBarIcon(action)
            
        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)
        self.actions.append(action)
        return action


    def initGui(self):
        icon_path = ':/plugins/walidatorPlikowGML/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'walidatorPlikowGML'),
            callback=self.run,
            parent=self.iface.mainWindow())

        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Walidator plików GML'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        global xsdPaths, szablonKontroliPaths
        walidowanaBaza = ['EGIB','GESUT','BDOT500','RCN','PRNG','BDOT10k','BDOO']
        formatRaportu = ['xls','txt', 'pdf']
        xsdPaths = {'BDOO':"/XSD/BDOT10kBDOO/BDOT10k_BDOO.xsd",
                    'BDOT10k':"/XSD/BDOT10kBDOO/BDOT10k_BDOO.xsd",
                    'PRNG':"/XSD/PRNG/NG_PRNG.xsd",
                    'BDOT500':"/XSD/BDOT500/BDOT500_1.3tech.xsd",
                    'GESUT':"/XSD/GESUT/GESUT_1.3tech.xsd",
                    'EGIB':"/XSD/EGIB/EGIB_1.8.xsd",
                    'RCN':"/XSD/RCN/RCN_1.4.xsd"
                   }
        
        szablonKontroliPaths = {'BDOO':"/SzablonyKontroli/BDOO/SK_BDOO_1.0.0.xml",
                                'BDOT10k':"/SzablonyKontroli/BDOT10k/SK_BDOT10k_1.0.4.xml",
                                'PRNG':"/SzablonyKontroli/PRNG/SK_PRNG_1.0.0.xml",
                                'BDOT500':"/SzablonyKontroli/BDOT500/SK_BDOT500_1.0.2.xml",
                                'GESUT':"/SzablonyKontroli/GESUT/SK_GESUT_1.0.0.xml",
                                'EGIB':"/SzablonyKontroli/EGIB/SK_EGIB_1.0.1.xml",
                                'RCN':"/SzablonyKontroli/RCN/SK_RCN_1.0.0.xml"
                               }
        
        self.dlg = walidatorPlikowGMLDialog()
        
        self.dlg.comboBox.addItems(walidowanaBaza)
        self.dlg.comboBox_2.addItems(formatRaportu)
        self.dlg.pushButton_1.clicked.connect(self.zaznaczWszystkieKontrole)
        self.dlg.pushButton_2.clicked.connect(self.odznaczWszystkieKontrole)
        self.walidacjaIKontrolaAtrybutow()


    # wskazanie pliku i zlecenie walidacji
    def walidacjaIKontrolaAtrybutow(self):
        global pliki, sciezkaGML, files, plik, path, plikRaportu, walidacjaZWynikiemPozytywnym, kontrolaZWynikiemPozytywnym, xmlschema, formatPlikuRaportu, dataFrame
        global walidowanePliki_df, wiersze_df, opisyBledow_df, komunikatyBledow_df, szablonKontroliPath, mainGroup
        global kontrolowanePliki_df, klasy_df, lokalneId_df, komunikatyBledowKontroli_df, plikiZparsowane, czyGrupaDodana
        global liczbaKontroliDoWykonania, progress, liczbaKontroliWykonanych, nazwy
        
        sciezkaGML_ini = config['UstawieniaOgolne']['sciezkagml']
        plik = QFileDialog.getOpenFileNames(self.dlg,"Wskaż plik z danymi do walidacji",sciezkaGML_ini,"Plik GML (*.gml);;Plik XML (*.xml);;Plik skompresowany (*.zip)")
        
        try:
            sciezkaGML = str(pathlib.Path(plik[0][0]).parent)
            nazwa_pliku = pathlib.Path(plik[0][0]).name[:-4]
            if sciezkaGML != sciezkaGML_ini:
                config.set('UstawieniaOgolne', 'sciezkagml', sciezkaGML)
                with open(str(mainPath)+'/Walidator_plikow_gml.ini', 'w') as configfile:
                    config.write(configfile)
        except Exception as inst:
            if inst.args[0] == 13:
                self.iface.messageBar().pushMessage("Uwaga!", inst.args[1], level=Qgis.Critical)
            else:
                pass
            return
        
        if plik[1] == 'Plik skompresowany (*.zip)':
            try:
                plikZIP = zipfile.ZipFile(plik[0][0],'r') 
            except:
                self.iface.messageBar().pushMessage("Uwaga!", "Niepoprawny plik zip.", level=Qgis.Critical)
                return
            
            files = plikZIP.namelist()
            
            if len(files): # jeżeli jest kilka plików to łączy ich nazwy do wyszukania frazy
                nazwaPlikuLubPlikow = ''.join(files)
        else:
            files = plik[0]
            nazwaPlikuLubPlikow = pathlib.Path(files[0]).name
        
        if re.search('OT_|BDOT10',str(nazwaPlikuLubPlikow).upper()) != None:
            self.dlg.comboBox.setCurrentIndex(self.dlg.comboBox.findText('BDOT10k'))
        elif re.search('BDOT500',str(nazwaPlikuLubPlikow).upper()) != None:
            self.dlg.comboBox.setCurrentIndex(self.dlg.comboBox.findText('BDOT500'))
        elif re.search('GESUT',str(nazwaPlikuLubPlikow).upper()) != None:
            self.dlg.comboBox.setCurrentIndex(self.dlg.comboBox.findText('GESUT'))
        else:
            self.dlg.comboBox.setCurrentIndex(self.dlg.comboBox.findText('EGIB'))
        
        self.dlg.comboBox.currentIndexChanged.connect(self.wczytanieSzablonuKontroli)
        self.wczytanieSzablonuKontroli()
        
        self.dlg.show()
        result = self.dlg.exec_()
        formatPlikuRaportu = None
        
        if result:
            self.iface.messageBar().pushMessage("Walidacja pliku " + str(pathlib.Path(plik[0][0]).name) + " rozpoczęta ...", level=Qgis.Info)
            QCoreApplication.processEvents()
            
            timestr = time.strftime("%Y-%m-%d_%H.%M")
            
            if self.dlg.comboBox_2.currentText() == 'txt':
                path = sciezkaGML + "/RaportBledow_" + str(nazwa_pliku) + "_" + timestr + ".txt"
                formatPlikuRaportu = "txt"
            else:
                if self.dlg.comboBox_2.currentText() == 'pdf':
                    path = sciezkaGML + "/RaportBledow_" + str(nazwa_pliku) + "_" + timestr + ".pdf"
                    formatPlikuRaportu = "pdf"
                    pdfpath=path
                else:
                    path = sciezkaGML + "/RaportBledow_" + str(nazwa_pliku) + "_" + timestr + ".xls"
                    formatPlikuRaportu = "xls"
            try:
                if os.path.isfile(path):
                    os.remove(path)
            except:
                self.iface.messageBar().pushMessage("Uwaga!", "Plik raportu jest otwarty. Proszę o zamknięcie pliku.", level=Qgis.Critical)
                return
        else:
            if formatPlikuRaportu == 'txt':
                plikRaportu.close() 
            return
        
        try:
            if formatPlikuRaportu == 'txt':
                plikRaportu = open(path,"a", encoding='utf-8')
        except:
            self.iface.messageBar().pushMessage("Uwaga!", "Brak uprawnień do zapisu raportu.", level=Qgis.Critical)
            return
        
        pliki = []
        plikiZparsowane = []
        walidowanePliki_df = []
        wiersze_df = []
        opisyBledow_df = []
        komunikatyBledow_df = []
        
        kontrolowanePliki_df = []
        klasy_df = []
        lokalneId_df = []
        komunikatyBledowKontroli_df = []
        
        i = 0
        walidacjaZWynikiemPozytywnym = True
        kontrolaZWynikiemPozytywnym = True
        namespace = self.dlg.comboBox.currentText()
        mainGroup = os.path.splitext(os.path.basename(plik[0][0]))[0]
        
        try:
            xsdPath = parse(str(mainPath) + xsdPaths[namespace])
            szablonKontroliPath = parse(str(mainPath) + szablonKontroliPaths[namespace])
        except:
            self.iface.messageBar().pushMessage("Uwaga!", "Brak dostępu do pliku XSD.", level=Qgis.Critical)
            return
        
        try:
            xmlschema = XMLSchema(xsdPath)
        except:
            self.iface.messageBar().pushMessage("Uwaga!", "Brak dostępu do internetu.", level=Qgis.Critical)
            return
        
        for file in files:
            if plik[1] == 'Plik skompresowany (*.zip)':
                try:
                    plikGML = plikZIP.extract(file)
                except:
                   self.iface.messageBar().pushMessage("Uwaga!", "Problem z rozpakowaniem pliku zip.", level=Qgis.Critical)
                   return 
            else:
                plikGML = file
            if plikGML[-3:] in ['xml','gml','XML','GML']:
                pliki.append(plikGML)
                task = QgsTask.fromFunction(str(i), self.walidacja, on_finished=self.wynikiWalidacji, flags=QgsTask.CanCancel)
                QgsApplication.taskManager().addTask(task)
                while QgsApplication.taskManager().countActiveTasks() > 0:
                    QCoreApplication.processEvents()
                while task.status() not in [QgsTask.Complete, QgsTask.Terminated]:
                    QCoreApplication.processEvents()
                i += 1
        
        czyGrupaDodana = False
        if not walidacjaZWynikiemPozytywnym:
            msgBox = QMessageBox()
            msgBox.setText("W pliku gml występują błędy zgodności ze schematem aplikacyjnym i dlatego dalsze kontrole atrybutowe i geometryczne mogą się nie wykonać poprawnie - czy chcesz  kontynuować?")
            msgBox.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
            odp = msgBox.exec() 
        else:
            odp = 0
        
        if odp == 16384 or odp == 0:
            liczbaKontroliDoWykonania = 0
            liczbaKontroliWykonanych = 0
            nazwy = []
            progress = QProgressBar()
            # sprawdzenie liczby kontroli do wykonania
            for i in range(modelKontroli.rowCount()):
                parent = modelKontroli.item(i)
                if parent.checkState() in (1,2):
                    for j in range(parent.rowCount()):
                        if parent.child(j).checkState() == 2:
                            liczbaKontroliDoWykonania += 1
                            nazwy.append((parent.child(j).data(1),parent.child(j).data(2)))
                            
            if liczbaKontroliDoWykonania > 0: # wczytaj warstwy nawet, gdy nie wybierze się żadniej kontroli
                for plikZparsowany in plikiZparsowane:
                    self.importGML(plikZparsowany)
            
            QCoreApplication.processEvents()
            progressMessageBar = iface.messageBar().createMessage("Postęp wykonania kontroli atrybutów")
            progress.setMaximum(liczbaKontroliDoWykonania)
            progress.setAlignment(Qt.AlignLeft|Qt.AlignVCenter)
            progressMessageBar.layout().addWidget(progress)
            iface.messageBar().pushWidget(progressMessageBar, Qgis.Info)
    
            for plikZparsowany in plikiZparsowane:
                self.kontrolaAtrybutow(plikZparsowany)
            if liczbaKontroliWykonanych != liczbaKontroliDoWykonania:
                progress.setValue(progress.maximum()) # ustawia 100% jesli nie wszystkie kontrole przeszly
            iface.messageBar().clearWidgets() # pasek zniknie, gdy zakończy kontrole
                
        if formatPlikuRaportu == 'txt':
            if len(kontrolowanePliki_df) > 0:
                plikRaportu.write('------------------------------------------------ KONTROLE ATRYBUTÓW ------------------------------------------------\n')
            for i in range(len(kontrolowanePliki_df)):
                opisBledu = 'KONTROLOWANY PLIK: ' + kontrolowanePliki_df[i] + ', KLASA: ' + klasy_df[i] + ', LOKALNYID: ' + lokalneId_df[i] + ', KOMUNIKAT BŁĘDU: ' + komunikatyBledowKontroli_df[i] + '\n'
                plikRaportu.write(opisBledu)
        elif formatPlikuRaportu == 'pdf':
             nazwaPliku = str(pathlib.Path(plikZparsowany).name)
             bledyWalidacji = {'WALIDOWANY PLIK': walidowanePliki_df, 'WIERSZ': wiersze_df, 'OPIS BŁĘDU': opisyBledow_df, 'KOMUNIKAT BŁĘDU': komunikatyBledow_df}
             bledyKontroli = {'KONTROLOWANY PLIK':kontrolowanePliki_df, 'KLASA':klasy_df, 'LOKALNYID':lokalneId_df, 'KOMUNIKAT BŁĘDU':komunikatyBledowKontroli_df}
             dfWalidcaji = pd.DataFrame(bledyWalidacji)
             dfKontroli = pd.DataFrame(bledyKontroli)
             datawalidacja = dfWalidcaji.values.tolist()
             datakontrola = dfKontroli.values.tolist()
        
             if len(str(bledyWalidacji["WIERSZ"])) == 0:
                 bledyWalidacji["WIERSZ"] = 0
                 
             # tworzenie dokumentu
             class PDF(FPDF): # stopka z numerem strony
                 def header(self):
                     self.add_font('Verdana', '', os.path.dirname(os.path.realpath(__file__)) + "\\fpdf\\Verdana.ttf", uni = True)
                     self.set_font('Verdana', size=5)
                     self.cell(0,-5,"Raport został wygenerowany przy pomocy wtyczki QGIS – „Walidator plików GML” w wersji 1.0.6 - udostępnionej przez GUGiK",0,0,"L")
                 def footer(self):
                     self.set_y(-15)
                     self.cell(0, 10, f'Strona {self.page_no()}', 0, 0, 'C')
             def create_pdf(filename):
                 czas = time.strftime("%Y-%m-%d %H:%M")
                 pdf = PDF()
                 walidator_sciezka = os.path.dirname(os.path.realpath(__file__))
                 pdf.add_page()
                 pdf.alias_nb_pages()
                 pdf.set_margins(10,10,10)
                 pdf.add_font('Verdana', '', walidator_sciezka + "\\fpdf\\Verdana.ttf", uni = True)
                 pdf.add_font("Verdana", "B", walidator_sciezka + "\\fpdf\\Verdana-bold.ttf", uni = True)
                 pdf.set_font('Verdana', 'B',14)
                 pdf.cell(0,5,ln = 1)
                 pdf.cell(0,0, "Raport z kontroli", align='C',ln=2)
                 pdf.set_font("Verdana", "", 8)
                 pdf.cell(0,10,ln = 1)
                 pdf.cell(100,0, "wskazany plik:", align='R',ln=0)
                 pdf.cell(100,0, nazwaPliku, align = "L")
                 pdf.cell(0,5,ln = 1)
                 pdf.cell(100,0, "wynik walidacji:", align = "R", ln = 0)
                 if len(bledyWalidacji["WIERSZ"]) == 0:
                    wynikw = "Pozytywny"
                    pdf.set_text_color(0,153,0)
                 else:
                    wynikw = "Negatywny"
                    pdf.set_text_color(255,0,0)
                 lightblue = (143, 216, 255)
                 gray = (240,240,240)
                 pdf.cell(100,0,wynikw, align = "L")
                 pdf.cell(0,5,ln = 1)
                 pdf.set_text_color(0,0,0)
                 pdf.cell(100,0, "wynik kontroli atrybutów:", align = "R", ln = 0)
                 if len(bledyKontroli["KLASA"]) == 0:
                    wynikon = "Pozytywny"
                    pdf.set_text_color(0,153,0)
                 else:
                    wynikon = "Negatywny"
                    pdf.set_text_color(255,0,0)
                 pdf.cell(100,0,wynikon, align = "L")
                 pdf.cell(0,5, ln = 1) # wolne miejsce
                 pdf.set_text_color(0,0,0)
                 pdf.cell(100,0,"data kontroli:", ln=0, align = "R") # tekst
                 pdf.cell(100,0, czas , ln = 1, align = "L")
                 pdf.cell(0,5,ln = 1)
                 pdf.cell(100,0,"wersja szablonu:", align = "R")
                 pdf.cell(100,0,wersjaSzablonuKontroli, align = "L", ln = 1)
                 pdf.cell(0,1,ln = 1)
                 with pdf.table(first_row_as_headings = False, col_widths = (105,95), borders_layout = "NONE", v_align = "TOP") as tabelaskp:
                     rzad = tabelaskp.row()
                     rzad.cell("szablon kontroli:", align = "R", padding=(1,1,1,1))
                     rzad.cell(szablonKontroliSciezka, align = "J", padding = (1,5,1,1))
                 pdf.cell(0,1,ln = 1)
                 pdf.cell(100,0,"wersja schematu aplikacyjnego GML:", align = "R", ln = 0)
                 pdf.cell(100,0, wersjaSchematu, align = "L", ln = 1)
                 pdf.cell(0,1,ln = 1)
                 with pdf.table(first_row_as_headings = False, col_widths = (105,95), borders_layout = "NONE", v_align = "TOP") as tabelaskp:
                     rzad = tabelaskp.row()
                     rzad.cell("schemat aplikacyjny GML:", align = "R", padding=(1,1,1,1))
                     rzad.cell(schematKontroliPath, align = "J", padding = (1,5,1,1))
                 pdf.cell(0,1,ln = 1)
                 pdf.cell(100,0,"suma kontrolna schematu (CRC32):", align = "R", ln = 0)
                 pdf.cell(100,0, sumaKontrolaSchemat, align = "L", ln = 1)
                 pdf.cell(0,5,ln = 1)
                 pdf.cell(100,0,"suma kontrolna wskazanego pliku (CRC32):", align = "R", ln = 0)
                 pdf.cell(100,0, sumaKontrolaPlikWalidowany, align = "L")
                 pdf.cell(0,10,ln =1)
                 if len(nazwy) > 0:
                     pdf.set_font("Verdana", "B", 10)
                     pdf.cell(0,0,"Tabela z wykonanymi kontrolami dodatkowymi", align = "C")
                     pdf.cell(0,5,ln = 1)
                     pdf.set_font("Verdana",  "", 8)
                     pdf.set_fill_color(lightblue)
                     with pdf.table(col_widths=(12,40), text_align = "C",padding = (1)) as table:
                         pdf.set_font("Verdana", "", 5)
                         headings = table.row()
                         headings.cell("ID KONTROLI")
                         headings.cell("ZAKRES KONTROLI")
                         pdf.set_fill_color(gray)
                     with pdf.table(nazwy, col_widths=(12,40), first_row_as_headings = False, text_align = "L", padding = (1)):
                         pass
                 else: # jak nie ma błędów walidacji
                      pdf.set_font("Verdana", "B", 10)
                      pdf.cell(0,0, "Nie wykonano kontroli dodatkowych", align = "C")
                 pdf.set_fill_color(255,255,255)
                 pdf.set_font("Verdana", "" , 6)
                 pdf.cell(0,12,ln = 1)
                 # tabela walidacji
                 if len(bledyWalidacji["WIERSZ"]) > 0:
                     pdf.set_font("Verdana", "B", 10)
                     pdf.cell(0,0,"Tabela z błędami walidacji", align = "C")
                     pdf.set_font("Verdana",  "", 8)
                     pdf.cell(0,5,ln = 1)
                     pdf.set_fill_color(lightblue)
                     with pdf.table(col_widths=(40,12,40,88), text_align = "C",padding = (1)) as table:
                         pdf.set_font("Verdana", "", 5)
                         headings = table.row()
                         headings.cell("WALIDOWANY PLIK")
                         headings.cell("WIERSZ")
                         headings.cell("OPIS BŁĘDU")
                         headings.cell("KOMUNIKAT BŁĘDU")
                         pdf.set_fill_color(gray)
                     with pdf.table(datawalidacja, col_widths=(40,12,40,88), first_row_as_headings = False, text_align = "L", padding = (1)):
                         pass
                     pdf.set_fill_color(255,255,255)
                     pdf.set_font("Verdana", "" , 6)
                 else: # jak nie ma błędów walidacji
                     pdf.set_font("Verdana", "", 10)
                     pdf.cell(0,0, "Nie znaleziono błędów walidacji", align = "C")
                 pdf.cell(w=0,h=10,txt = " ",ln=1)
                 # tabela konotroli
                 if len(bledyKontroli["KLASA"]) > 0:
                     pdf.set_font("Verdana", "B", 10)
                     naglowek=[["KONTROLOWANY PLIK", "KLASA",  "LOKALNY ID", "KOMUNIKAT BŁĘDU"]] # Definicja nagłówka
                     datakontrola2 = naglowek + datakontrola # dodanie do tablicy
                     pdf.set_font("Verdana", "B", 10)
                     pdf.cell(0,0,"Tabela z błędami kontroli atrybutowych", align="C")
                     pdf.set_font("Verdana", "", 5)
                     pdf.cell(0,5,ln = 1)
                     headings_style = FontFace(emphasis="BOLD", color=0, fill_color=(143, 216, 255)) 
                     with pdf.table(datakontrola2, num_heading_rows=1, col_widths=(40,20,50,70), cell_fill_color=(240,240,240), headings_style=headings_style, first_row_as_headings = True, 
                                    text_align="C", padding = (1)):
                         pass
                 else:
                     pdf.set_font("Verdana", "B", 10)
                     pdf.cell(0,0,"Nie znaleziono błędów kontroli", align = "C")
                     pdf.set_font("Verdana", "", 5)
                     
                 pdf.output(name=filename,dest='F'.encode('latin-1'))
             create_pdf(pdfpath)
             # koniec pdfu
        else:
            bledyWalidacji = {'WALIDOWANY PLIK': walidowanePliki_df, 'WIERSZ': wiersze_df, 'OPIS BŁĘDU': opisyBledow_df, 'KOMUNIKAT BŁĘDU': komunikatyBledow_df}
            bledyKontroli = {'KONTROLOWANY PLIK':kontrolowanePliki_df, 'KLASA':klasy_df, 'LOKALNYID':lokalneId_df, 'KOMUNIKAT BŁĘDU':komunikatyBledowKontroli_df}
            if len(bledyWalidacji["WIERSZ"]) == 0:
                bledyWalidacji["WIERSZ"] = 0
            dataFrameWalidacja= pd.DataFrame(bledyWalidacji)
            dataFrameKontrola= pd.DataFrame(bledyKontroli)
            try:
                plikGML = plikGML.replace("/","\\")
                kolumna = 3
                strony = xlwt.Workbook()
                arkuszDaneWstepne = strony.add_sheet('Raport kontroli')
                arkuszWalidacji = strony.add_sheet('Raport z walidacji')
                arkuszKontroli = strony.add_sheet('Raport z kontroli atrybutów')
                styl1 = xlwt.easyxf('align: wrap on, vert center;  borders: left thin, right thin, top thin, bottom thin')
                styl2 = xlwt.easyxf("align: horz center, vert center; font: bold on; align: wrap on; borders: left thin, right thin, top thin, bottom thin")
                styl3 = xlwt.easyxf("align: horz left, vert center; font: bold on; align: wrap on; borders: left thin, right thin, top thin, bottom thin")
                neg = xlwt.easyxf("align: horz left, vert center; font: bold on, color red; align: wrap on; borders: left thin, right thin, top thin, bottom thin")
                poz = xlwt.easyxf("align: horz left, vert center; font: bold on, color green; align: wrap on; borders: left thin, right thin, top thin, bottom thin")
                arkuszDaneWstepne.write(0,0,"Wynik kontroli", styl3)
                arkuszDaneWstepne.write(1,0,"Data kontroli i wskazany plik", styl3)
                arkuszDaneWstepne.write(2,0,"Suma kontrolna wskazanego pliku (CRC32)", styl3)
                arkuszDaneWstepne.write(3,0,"Wersja szablonu", styl3)
                arkuszDaneWstepne.write(4,0,"Suma kontrolna schematu (CRC32)", styl3)
                arkuszDaneWstepne.write(5,0,"Wersja schematu aplikacyjnego GML", styl3)
                arkuszDaneWstepne.write(6,0,"Wynik walidacji", styl3)
                arkuszDaneWstepne.write(7,0,"Wynik kontroli atrybutów", styl3)
                arkuszDaneWstepne.col(0).width = 10000
                arkuszDaneWstepne.col(1).width = 5000
                arkuszDaneWstepne.col(2).width = 35000
                timestr = time.strftime("%Y-%m-%d %H:%M")
                arkuszDaneWstepne.write(0,2,'', styl1)
                arkuszDaneWstepne.write(1,1,timestr, styl1)
                arkuszDaneWstepne.write(1,2,plikGML, styl1)
                arkuszDaneWstepne.write(2,1,sumaKontrolaPlikWalidowany,styl1)
                arkuszDaneWstepne.write(2,2,'', styl1)
                arkuszDaneWstepne.write(3,1,wersjaSzablonuKontroli,styl1)
                arkuszDaneWstepne.write(3,2,szablonKontroliSciezka,styl1)
                arkuszDaneWstepne.write(4,1,sumaKontrolaSchemat,styl1)
                arkuszDaneWstepne.write(4,2,'', styl1)
                arkuszDaneWstepne.write(5,1,wersjaSchematu,styl1)
                for i, (data1, data2) in enumerate(nazwy):
                    arkuszDaneWstepne.write(i + 8,0,"Wykonane kontrole dodatkowe", styl3)
                    arkuszDaneWstepne.write(i + 8,1, f"{data1}", styl1) 
                    arkuszDaneWstepne.write(i + 8,2, f"{data2}", styl1)
                arkuszDaneWstepne.write(5,2,schematKontroliPath, styl1)
                arkuszDaneWstepne.write(6,2,'', styl1)
                arkuszDaneWstepne.write(7,2,'', styl1)
                arkuszWalidacji.write(0,0,"WALIDOWANY PLIK", styl2) 
                arkuszWalidacji.write(0,1,"WIERSZ", styl2)
                arkuszWalidacji.write(0,2,"OPIS BŁĘDU", styl2)
                arkuszWalidacji.write(0,3,"KOMUNIKAT BŁĘDU", styl2)
                arkuszWalidacji.col(0).width = 12500
                arkuszWalidacji.col(1).width = 2000
                arkuszWalidacji.col(2).width = 22500
                arkuszWalidacji.col(3).width = 22500
                arkuszKontroli.write(0,0,"KONTROLOWANY PLIK", styl2)
                arkuszKontroli.write(0,1,"KLASA", styl2)
                arkuszKontroli.write(0,2,"LOKALNYID", styl2)
                arkuszKontroli.write(0,3,"KOMUNIKAT BŁĘDU", styl2)
                arkuszKontroli.col(0).width = 12000
                arkuszKontroli.col(1).width = 8000
                arkuszKontroli.col(2).width = 12500
                arkuszKontroli.col(3).width = 27500
                for i, row in enumerate(dataFrameWalidacja.values):
                    for j, val in enumerate(row):
                        arkuszWalidacji.write(i + 1, j, str(val), styl1) 
                for i, row in enumerate(dataFrameKontrola.values):
                    kontrolaZWynikiemPozytywnym = False
                    for j, val in enumerate(row):
                        arkuszKontroli.write(i + 1, j, str(val), styl1)
                if walidacjaZWynikiemPozytywnym and kontrolaZWynikiemPozytywnym:
                    arkuszDaneWstepne.write(0,1,"Pozytywny", poz)
                    arkuszDaneWstepne.write(6,1,"Pozytywny", poz)
                    arkuszDaneWstepne.write(7,1,"Pozytywny", poz)
                else:
                    arkuszDaneWstepne.write(0,1,"Negatywny", neg)
                    if not walidacjaZWynikiemPozytywnym and kontrolaZWynikiemPozytywnym == True:
                        arkuszDaneWstepne.write(6,1,"Negatywny", neg)
                        arkuszDaneWstepne.write(7,1,"Pozytywny", poz)
                    elif not kontrolaZWynikiemPozytywnym and walidacjaZWynikiemPozytywnym == True:
                        arkuszDaneWstepne.write(6,1,"Pozytywny", poz)
                        arkuszDaneWstepne.write(7,1,"Negatywny", neg)
                    else:
                        arkuszDaneWstepne.write(6,1,"Negatywny", neg)
                        arkuszDaneWstepne.write(7,1,"Negatywny", neg)
                strony.save(path)
            except Exception as e:
                print(f'Błąd : {e}')
                self.iface.messageBar().pushMessage("Uwaga!", "Brak uprawnień do zapisu raportu.", level=Qgis.Critical)
                return
        
        if walidacjaZWynikiemPozytywnym and kontrolaZWynikiemPozytywnym:
            widget = iface.messageBar().createMessage("Walidacja pliku " + str(pathlib.Path(plik[0][0]).name) + " zakończona z wynikiem pozytywnym.")
            button = QPushButton(widget)
            button.setText("Metadane kontroli")
            button.pressed.connect(self.otwarcieRaportuZWalidacji)
            widget.layout().addWidget(button)
            self.iface.messageBar().pushWidget(widget,Qgis.Success)
         
        else:
            if walidacjaZWynikiemPozytywnym == False and kontrolaZWynikiemPozytywnym == False:
                msg = "Walidacja i kontrola atrybutów zakończona z wynikiem negatywnym: "
            elif walidacjaZWynikiemPozytywnym == False:
                msg = "Walidacja pliku zakończona z wynikiem negatywnym: "
            else:
                msg = "Kontrola atrybutów zakończona z wynikiem negatywnym: "
            widget = iface.messageBar().createMessage(msg, str(pathlib.Path(plik[0][0]).name))
            
            button = QPushButton(widget)
            button.setText("Raport z walidacji")
            button.pressed.connect(self.otwarcieRaportuZWalidacji)
            widget.layout().addWidget(button)
            self.iface.messageBar().pushWidget(widget, Qgis.Warning)
        
        if formatPlikuRaportu == 'txt':
            plikRaportu.close()
        else:
            pass


    # walidacja pliku GML z conajmniej jednym obiektem
    def walidacja(self, task):
        global walidacjaZWynikiemPozytywnym, plikiZparsowane, plikGML, walidowanyPlik
        plikGML = pliki[int(task.description())]
        try:
            walidowanyPlik = lxml.etree.parse(plikGML)
            plikiZparsowane.append(plikGML) # przechowujemy pliki, które są na tyle dobre by wykonać ew. kontrole atrybutowe
            ns = {'bt': 'urn:gugik:specyfikacje:gmlas:modelPodstawowy:1.0'}
            try:
                if walidowanyPlik.xpath('//*[namespace-uri()="%s"]' % ns['bt'], namespaces=ns):
                    raise OSError("Plik nie jest zgodny z obowiązującym schematem aplikacyjnym GML - z plikiem XSD. Plik wykorzystuje przestrzeń nazw Modelu Podstawowego, która była wykorzystywana w schematach aplikacyjnych przed 2021 rokiem.")
            except:
                pass
            
            root = walidowanyPlik.getroot()
            
            if root != None:
                wynikWalidacji = xmlschema.validate(walidowanyPlik)
                if not wynikWalidacji:
                    walidacjaZWynikiemPozytywnym = False
                    return {'taskID':task.description(), 'plikGML':plikGML, 'error':xmlschema.error_log}
        except lxml.etree.XMLSyntaxError as error:
            walidacjaZWynikiemPozytywnym = False
            return {'taskID':task.description(), 'plikGML':plikGML, 'error':error}
        except OSError as error:
            walidacjaZWynikiemPozytywnym = False
            return {'taskID':task.description(), 'plikGML':plikGML, 'error':error}


    # zapisanie logów błędów walidacji do pliku; komunikat z przyciskiem pobrania raportu
    def wynikiWalidacji(self, exception=None, value=None):
        global walidowanePliki_df, wiersze_df, opisyBledow_df, komunikatyBledow_df
        
        frazy = {"The value":"Wartość",
                 "failed to load external entity":"nie udało się załadować",
                 "Error reading file":"Błąd odczytu pliku",
                 "is not an element of the set":"nie znajduje się na liście",
                 "This element is not expected":"Ten element jest nieoczekiwany",
                 "Expected is one of":"Oczekiwana jest jedna wartość z ", 
                 "Expected is":"Oczekiwany jest ",
                 "is not a valid value of the atomic type":"jest nieprawidłową wartością typu podstawowego",
                 "is not a valid value of the list type \'{http://www.opengis.net/gml/3.2}doubleList\'":" jest nieprawidłową wartością typu listowego \'{http://www.opengis.net/gml/3.2}doubleList\'",
                 "Opening and ending tag mismatch":"Błędny otwierający lub zamykający znacznik",
                 "line":"linia",
                 "and":"i",
                 "Start tag expected":"Oczekiwany tag początkowy",
                 "huge text node":"ogromny węzeł tekstowy",
                 "Point":"Punkt",
                 "column":"kolumna",
                 "is not a valid value of the union type":"jest nieprawdłową wartością typu unia",
                 "is less than the minimum value allowed":"jest mniejsza niż minimalna dozwolona wartość",
                 "Missing child element(s)":"Brakuje elementów dziecka/dzieci",
                 "EndTag":"Znacznik zamykający",
                 "must be greater than":"musi być większa niż",
                 "is not accepted by the pattern":"nie jest zgodna z paternem",
                 "is greater than the maximum value allowed":"jest większa niż maksymalna dozwolona liczba",
                 "not found": "nie został znaleziony",
                 "is not a valid value of the local atomic type":"nie jest poprawną wartością lokalnego typu podstawowego"
                 }
        if value != None:
            if  isinstance(value['error'], lxml.etree.XMLSyntaxError):
                opisBledu = str(value['error'])
                for key in frazy:
                    opisBledu = opisBledu.replace(key,frazy[key])
                msg = 'Błąd w składni pliku XML: ' + str(value['plikGML']) + '\n' + \
                      '- komunikat błędu: ' + opisBledu + '\n\n'
                if formatPlikuRaportu == 'txt':
                    plikRaportu.write(msg)
                else:
                    walidowanePliki_df.append(str(value['plikGML']))
                    wiersze_df.append("-")
                    opisyBledow_df.append("Błąd w składni pliku XML")
                    komunikatyBledow_df.append(opisBledu)
            elif isinstance(value['error'], lxml.etree._ListErrorLog):
                for i in range(len(value['error'])):
                    opisBledu = value['error'][i].message
                    for key in frazy:
                        opisBledu = opisBledu.replace(key,frazy[key]) # tłumaczenie
                    msg = 'Walidacja pliku: ' + str(value['plikGML']) + ' z wynikiem negatywnym.\n' + \
                          '- ' + config['KodyWalidacji'][value['error'][i].type_name] + '\n' + \
                          '- wiersz: ' + str(value['error'][i].line) + '\n' + \
                          '- komunikat błędu: ' + opisBledu + '\n\n'
                    if formatPlikuRaportu == 'txt':
                        plikRaportu.write(msg)
                    else:
                        walidowanePliki_df.append(str(value['plikGML']))
                        wiersze_df.append(str(value['error'][i].line))
                        opisyBledow_df.append(config['KodyWalidacji'][value['error'][i].type_name])
                        komunikatyBledow_df.append(opisBledu)
            elif isinstance(value['error'], OSError):
                opisBledu = str(value['error'])
                for key in frazy:
                    opisBledu = opisBledu.replace(key,frazy[key]) # tłumaczenie
                if formatPlikuRaportu == 'txt':
                    plikRaportu.write(opisBledu)
                else:
                    walidowanePliki_df.append(str(value['plikGML']))
                    wiersze_df.append("-")
                    opisyBledow_df.append("-")
                    komunikatyBledow_df.append(opisBledu)


    # otwarcie pliku raportu
    def otwarcieRaportuZWalidacji(self):
        if os.path.isfile(path):
            try:
                os.startfile(path, 'open') # Windows
            except:
                subprocess.call(('open', path)) # macOS


    # import plików GML do QGIS
    def importGML(self, zparsowanyPlik):
        global group
        gdal.SetConfigOption('GML_ATTRIBUTES_TO_OGR_FIELDS', 'YES')
        root = QgsProject.instance().layerTreeRoot()
        typyGeometrii = { 0: 'Geometry',
                          1: 'Point',
                          2: 'LineString',
                          3: 'Polygon',
                          4: 'MultiPoint',
                          5: 'MultiLineString',
                          6: 'MultiPolygon',
                          9: 'CompoundCurve',
                          10: 'CurvePolygon',
                          11: 'MultiCurve',
                          12: 'MultiSurface',
                          13: 'Curve',
                          100: 'No Geometry'}
        
        warstwy = [x.GetName() for x in ogr.Open(zparsowanyPlik)]
        data_source = ogr.Open(zparsowanyPlik)
        
        typGeometriiWarstw = [x.GetGeomType() for x in ogr.Open(zparsowanyPlik)]
        
        localGroup = os.path.splitext(os.path.basename(zparsowanyPlik))[0]
        if plik[1] == 'Plik skompresowany (*.zip)':
            group = groupaGlowna.addGroup(localGroup)
        else:
            group = QgsProject.instance().layerTreeRoot().addGroup(localGroup)
        group.setExpanded(False)
        
        for warstwa, feature_geom in zip(warstwy, typGeometriiWarstw):
            if str(pathlib.Path(zparsowanyPlik).name)[:-4].find(warstwa) != -1:
                nazwaWarstwy = str(pathlib.Path(zparsowanyPlik).name)[:-4]
            else:
                nazwaWarstwy = str(pathlib.Path(zparsowanyPlik).name)[:-4] + '_' + warstwa
                
            if feature_geom == 100: # brak geometrii
                qgis_layer = QgsVectorLayer(zparsowanyPlik + "|layername=" + warstwa, nazwaWarstwy, 'ogr')
                QgsProject.instance().addMapLayer(qgis_layer, False)
                group.addLayer(qgis_layer)
                qgis_layer = None
            elif feature_geom == 0: # GeometryPropertyType
                
                tablica_typow_geometrii = [1,2,3]
                if warstwa in ['EGB_ObrebEwidencyjny','EGB_Budynek','EGB_JednostkaEwidencyjna', # EGiB
                               'OT_Ogrodzenia','OT_BudynekNiewykazanyWEGIB', # BDOT500
                               'NG_NazwaGeograficznaSwiata','NG_NazwaGeograficznaRP' # PRNG
                              ]:
                    tablica_typow_geometrii = [4,5,6]
                    
                for typGeometryPropertyType in tablica_typow_geometrii:
                    qgis_layer = QgsVectorLayer(zparsowanyPlik + "|layername=" + warstwa + "|geometrytype=" + typyGeometrii[typGeometryPropertyType], nazwaWarstwy, 'ogr')
                    if qgis_layer.featureCount() > 0:
                        QgsProject.instance().addMapLayer(qgis_layer, False)
                        group.addLayer(qgis_layer)
                        qgis_layer = None
            else:
                qgis_layer = QgsVectorLayer(zparsowanyPlik + "|layername=" + warstwa + "|geometrytype=" + typyGeometrii[feature_geom], nazwaWarstwy, 'ogr')
                if qgis_layer.featureCount() > 0:
                    QgsProject.instance().addMapLayer(qgis_layer, False)
                    group.addLayer(qgis_layer)
                    qgis_layer = None


    # wczytanie szablonu kontroli
    def wczytanieSzablonuKontroli(self):
        global modelKontroli, wersjaSzablonuKontroli, wersjaSchematu, sumaKontrolaSchemat, metaSchemat, szablonKontroliSciezka, schematKontroliPath
        szablonKontroliSciezka = str(mainPath) + szablonKontroliPaths.get(self.dlg.comboBox.currentText())
        schematKontroliPath = str(mainPath) + xsdPaths.get(self.dlg.comboBox.currentText())
        buf_size = 65536  # Czytaj plik w blokach o rozmiarze 64KB
        crc = 0
        with open(schematKontroliPath, 'rb') as f:
            while True:
                data = f.read(buf_size)
                if not data:
                    break
                crc = binascii.crc32(data, crc)
       
        sumaKontrolaSchemat = "%08X" % (crc & 0xFFFFFFFF) # tworzenie sumu kontrolnej
        tree = et.parse(szablonKontroliSciezka)
        root = tree.getroot()
        tree1 = et.parse(schematKontroliPath)
        root1 = tree1.getroot()
        wersjaSzablonuKontroli = root.get('version')
        wersjaSchematu = root1.get('version')
        filename = os.path.basename(schematKontroliPath) # pobiera sama nazwę pliku
        metaSchemat = os.path.splitext(filename)[0] + " " +  wersjaSchematu
        md5 = hashlib.md5()
        sha1 = hashlib.sha1()
        # Otwarcie pliku w trybie binarnym i aktualizacja sumy kontrolnej
        with open(schematKontroliPath, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                md5.update(chunk)
                sha1.update(chunk)
        
        # Zapisanie wyniku sumy kontrolnej w formie heksadecymalnej do zmiennej
        #sumaKontrolaSchemat = md5.hexdigest()
        szablonKontroliSciezka = szablonKontroliSciezka.replace("/","\\")
        self.dlg.label_17.setText('Wersja szablonu: ' + str(wersjaSzablonuKontroli))
        modelKontroli = QStandardItemModel()
        modelKontroli.setHorizontalHeaderLabels(['Lista kontroli'])
        self.dlg.treeView.setModel(modelKontroli)
        self.dlg.treeView.setUniformRowHeights(True)
        
        i = 0
        for grupaKontroli in root:
            parent = QStandardItem(grupaKontroli.get('name')) 
            modelKontroli.appendRow(parent)
            parent.setCheckable(True)
            parent.setCheckState(0)
            for kontrola in grupaKontroli:
                child = QStandardItem(kontrola.get('name'))
                child.setData(kontrola.get('id'), 1)
                child.setData(kontrola.get('name'), 2)
                child.setData(kontrola.get('class'), 3)
                child.setData(kontrola.get('errorPhrase'), 4)
                for k in kontrola:
                    child.setData(k.get('typ'), 5)
                    child.setData(k.get('sql'), 6)
                child.setData(kontrola.get('class2'), 7)
                child.setData(kontrola.get('joinFieldName'), 8)
                child.setData(kontrola.get('targetFieldName'), 9)
                child.setData(kontrola.get('joinFieldNamesSubset'), 11)
                child.setCheckable(True)
                child.setCheckState(0)
                parent.appendRow([child])
            self.dlg.treeView.setFirstColumnSpanned(i, self.dlg.treeView.rootIndex(), True)
            i += 1
        modelKontroli.itemChanged.connect(self.zmianaStatusuKontroli)


    def zaznaczWszystkieKontrole(self):
        for i in range(modelKontroli.rowCount()):
            item = modelKontroli.item(i)
            if item.checkState() in (0,1):
                item.setCheckState(2)
    
    
    def odznaczWszystkieKontrole(self):
        for i in range(modelKontroli.rowCount()):
            item = modelKontroli.item(i)
            if item.checkState() in (1,2):
                item.setCheckState(0)


    def zmianaStatusuKontroli(self, item):
        statusParent = item.checkState() 
        if item.rowCount() > 0:
            for j in range(item.rowCount()):
                statusChild = item.child(j).checkState()
                if statusParent == 2:
                    item.child(j).setCheckState(2)
                if statusParent == 0:
                    item.child(j).setCheckState(0)
        else:
            suma = 0
            for j in range(item.parent().rowCount()):
                suma += item.parent().child(j).checkState()
            if suma == 0:
                item.parent().setCheckState(0)
            elif suma == item.parent().rowCount() * 2:
                item.parent().setCheckState(2)
            else:
                item.parent().setCheckState(1)


    # kontrola atrybutów
    def kontrolaAtrybutow(self, zparsowanyPlik):
        global liczbaKontroliWykonanych, liczbaKontroliDoWykonania, czyGrupaDodana, groupaGlowna, progress, sumaKontrolaPlikWalidowany
        sumaKontrolaPlikWalidowany = ' '
        # obliczanie sumy kontroli
        kontrolowany = pathlib.Path(zparsowanyPlik)
        buf_size = 65536
        crc = 0
        with open(kontrolowany, 'rb') as f:
             while True:
                 data = f.read(buf_size)
                 if not data:
                     break
                 crc = binascii.crc32(data, crc)
        sumaKontrolaPlikWalidowany = "%08X" % (crc & 0xFFFFFFFF)
        # jeżeli są kontrole do wykonania to wykonanie importu plików GML do QGIS
        if liczbaKontroliDoWykonania > 0:
            if czyGrupaDodana == False and plik[1] == 'Plik skompresowany (*.zip)':
                root = QgsProject.instance().layerTreeRoot()
                czyGrupaDodana = True
                groupaGlowna = root.addGroup(mainGroup)
                groupaGlowna.setExpanded(False)
                
            QCoreApplication.processEvents()
            QgsMessageLog.logMessage("Import pliku " + str(pathlib.Path(zparsowanyPlik).name) + " do QGIS ...", level=Qgis.Info)
            QCoreApplication.processEvents()
            self.importGML(zparsowanyPlik)
        else:
            return
        
        geometryType = {0:'Point',1:'Line',2:'Polygon'}
        
        for i in range(modelKontroli.rowCount()):
            parent = modelKontroli.item(i)
            if parent.checkState() in (1,2):
                for j in range(parent.rowCount()):
                    if parent.child(j).checkState() == 2 and parent.child(j).data(1) != '' and parent.child(j).data(2) != '' and \
                        parent.child(j).data(3) != '' and  parent.child(j).data(4) != '' and \
                        parent.child(j).data(5) in ('QgsExpression','QgsExpressionWithJoin','pythonFunction') and parent.child(j).data(6) != '':
                        errorPhrase = parent.child(j).data(4)
                        sqltxt = parent.child(j).data(6)
                        sqltxt = sqltxt.replace("&gt;",">")
                        sqltxt = sqltxt.replace("&lt;","<")
                        klasa = parent.child(j).data(3)
                        teryt = str(pathlib.Path(zparsowanyPlik).name)[:-15][-4:]
                        if str(pathlib.Path(zparsowanyPlik).name)[:-4].find(klasa) != -1:
                            nazwaWarstwyJ1 = str(pathlib.Path(zparsowanyPlik).name)[:-4]
                        else:
                            nazwaWarstwyJ1 = str(pathlib.Path(zparsowanyPlik).name)[:-4] + '_' + klasa
                        
                        try:
                            for warstwaWsqltext in re.findall(r"layer:='(.*?)'", sqltxt):
                                sqltxt = sqltxt.replace("layer:='" + warstwaWsqltext,"layer:='" + str(pathlib.Path(zparsowanyPlik).name)[:-13] + warstwaWsqltext + '_' + warstwaWsqltext)
                        except:
                            pass
                        try:
                            layerL1 = None
                            layerL1 = QgsProject().instance().mapLayersByName(nazwaWarstwyJ1)[0]
                        except:
                            pass
                        if parent.child(j).data(5) in ('QgsExpression','QgsExpressionWithJoin','pythonFunction') and layerL1 != None:
                               request = QgsFeatureRequest(QgsExpression(sqltxt))
                               
                               # join dwóch warstw
                               if parent.child(j).data(7) != None and parent.child(j).data(8) != None and parent.child(j).data(9) != None and parent.child(j).data(11) != None:
                                   klasa2 = parent.child(j).data(7)
                                   warstwa_w_memory_nazwa = str(pathlib.Path(zparsowanyPlik).name)[:-4] + '_' + klasa + "_" + klasa2
                                   
                                   #czy jest warstwa złączonych warstw
                                   if len(QgsProject().instance().mapLayersByName(warstwa_w_memory_nazwa)) == 0:
                                       if str(pathlib.Path(zparsowanyPlik).name)[:-4].find(klasa2) != -1:
                                           nazwaWarstwyJ2 = str(pathlib.Path(zparsowanyPlik).name)[:-4]
                                       else:
                                           nazwaWarstwyJ2 = str(pathlib.Path(zparsowanyPlik).name)[:-4] + '_' + klasa2
                                       layerL2 = QgsProject().instance().mapLayersByName(nazwaWarstwyJ2)[0]
                                       joinFieldName = parent.child(j).data(8)
                                       targetFieldName = parent.child(j).data(9)
                                       joinFieldNamesSubset = parent.child(j).data(11).split(",")
                                       noweAtrybuty = {}
                                       
                                       definicje_pol = layerL1.fields()
                                       
                                       for nowyAtrybut in joinFieldNamesSubset:
                                           pole_lista = QgsField(klasa2 + '_' + nowyAtrybut, 11)
                                           definicje_pol.append(pole_lista)
                                           
                                       warstwa_w_memory = QgsVectorLayer(geometryType[layerL1.geometryType()] + "?crs=" + layerL1.crs().authid(), warstwa_w_memory_nazwa, "memory")
                                       warstwa_w_memory.dataProvider().addAttributes(definicje_pol)
                                       warstwa_w_memory.updateFields()
                                       QgsProject.instance().addMapLayer(warstwa_w_memory, False)
                                       group.addLayer(warstwa_w_memory)
                                       warstwa_w_memory.startEditing()
                                       
                                       for feature1 in layerL1.getFeatures():
                                           nowyRekord = QgsFeature(definicje_pol)
                                           nowyRekord.setGeometry(feature1.geometry())
                                           
                                           # dodaje wartoci atrybutów klasy
                                           for attr in feature1.fields():
                                               fieldIdx = warstwa_w_memory.fields().indexFromName(attr.name())
                                               nowyRekord.setAttribute(fieldIdx, QVariant(feature1[attr.name()]))
                                        
                                           # join
                                           for nowyAtrybut in joinFieldNamesSubset:
                                               noweAtrybuty[nowyAtrybut] = []
                                           for x in feature1[joinFieldName]:
                                               for feature2 in layerL2.getFeatures():
                                                   if x == feature2[targetFieldName]:
                                                       for nowyAtrybut in joinFieldNamesSubset:
                                                           noweAtrybuty[nowyAtrybut].append(feature2[nowyAtrybut])
                                                           
                                           for nowyAtrybut in joinFieldNamesSubset:
                                               fieldIdx = warstwa_w_memory.fields().indexFromName(klasa2 + '_' + nowyAtrybut)
                                               nowyRekord.setAttribute(fieldIdx, QVariant(noweAtrybuty[nowyAtrybut]))
                                               
                                           warstwa_w_memory.addFeature(nowyRekord)
                                           warstwa_w_memory.updateFeature(nowyRekord)
                                           
                                       warstwa_w_memory.commitChanges()
                                       
                                   # zmiana nazwy klasy
                                   klasa = klasa + "_" + klasa2
                               try:
                                   if str(pathlib.Path(zparsowanyPlik).name)[:-4].find(klasa) != -1:
                                       nazwaWarstwy = str(pathlib.Path(zparsowanyPlik).name)[:-4]
                                   else:
                                       nazwaWarstwy = str(pathlib.Path(zparsowanyPlik).name)[:-4] + '_' + klasa
                                   requestFeatures = []
                                   pasujace_warstwy = QgsProject().instance().mapLayersByName(nazwaWarstwy)
                                   if len(pasujace_warstwy) > 1: # sprawdza czy warstw o danej nazwie występuje więcej niż raz
                                       for usun_dupli in pasujace_warstwy[1:]:
                                            QgsProject.instance().removeMapLayer(usun_dupli.id())
                                            root = QgsProject.instance().layerTreeRoot()
                                            for group in root.findGroups():
                                                if not group.findLayers():  # Sprawdzenie, czy grupa jest pusta i usuwa jesli tak
                                                    root.removeChildNode(group)
                                                    break
                                   for i in range(len(QgsProject().instance().mapLayersByName(nazwaWarstwy))):
                                       layer = QgsProject().instance().mapLayersByName(nazwaWarstwy)[i]
                                       if parent.child(j).data(5) in ('QgsExpression','QgsExpressionWithJoin'):
                                           requestFeatures = layer.getFeatures(request)
                                       else:
                                           layerTMP = QgsProject().instance().mapLayersByName(nazwaWarstwyJ1)
                                           if sqltxt.count('(teryt)') > 0:
                                               requestFeatures = globals().get(sqltxt.replace('(teryt)', ''))(layerTMP[0], teryt)
                                           elif sqltxt.count('(gml)') > 0: # do bezposredniego wczytania xml-a do wtyczki
                                               requestFeatures = globals().get(sqltxt.replace('(gml)', ''))(layerTMP[0], walidowanyPlik)
                                           else:
                                               requestFeatures = globals().get(sqltxt)(layerTMP[0])
                                       selected_features = []  # lista z wybranymi obiektami
                                       if klasa == 'OT_SKRW_P' and errorPhrase == 'topo_e3_k164 Powierzchnia OT_PTTR_A mniejsza niż 1000 m2':
                                           klasa = 'OT_PTTR_A'
                                           nazwaPliku = str(pathlib.Path(zparsowanyPlik).name)
                                           nazwaPliku = nazwaPliku[:-10] + 'PTTR_A' + nazwaPliku[-4:] if nazwaPliku[-10:-4] == 'SKRW_P' else nazwaPliku
                                       else: # rozwiązanie problemu z błędną nazwą klasy, dla kontroli, która wymaga warstwy alfabetycznie później wczytanej
                                           nazwaPliku = str(pathlib.Path(zparsowanyPlik).name)
                                       for feature in requestFeatures:
                                           kontrolowanePliki_df.append(nazwaPliku)
                                           lokalneId_df.append(feature['lokalnyId'])
                                           if klasa == 'OT':
                                               klasa = klasa + str(pathlib.Path(zparsowanyPlik).name)[-11:-4]
                                           klasy_df.append(klasa)
                                           komunikatyBledowKontroli_df.append(errorPhrase)
                               except Exception as e:
                                   print(f'Błąd : {e}')
                               liczbaKontroliWykonanych += 1
                               progress.setValue(liczbaKontroliWykonanych)
                               QCoreApplication.processEvents()