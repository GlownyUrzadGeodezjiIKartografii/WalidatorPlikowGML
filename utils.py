# -*- coding: utf-8 -*-
"""
/***************************************************************************
 walidatorPlikowGML
                                 A QGIS plugin
 Walidator plików GML baz BDOT10k, PRNG, GESUT, EGiB, BDOT500
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-12-23
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Marcin Lebiecki - Główny Urząd Geodezji i Kartografii
        email                : marcin.lebiecki@gugik.gov.pl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.core import *
from qgis.PyQt.QtCore import *
from qgis import processing
from qgis.PyQt.QtWidgets import *
import pathlib
import configparser
import sys
import re
from datetime import datetime
import lxml
from lxml import etree
import pandas as pd
import zipfile
import os


loaded_csv_data = None
loaded_gml_prng_miejscowosci = None
loaded_gml_prng_obiektyfizjograficzne = None
tereny_chronione_zip = None
loaded_shp = {'OT_TCPN_A':[],'OT_TCPK_A':[],'OT_TCRZ_A':[],'OT_TCON_A':[]}


def findDuplicates(layer):
    obiektyZbledami = []
    
    extractbyexpression = processing.run("qgis:extractbyexpression", {
        'INPUT': layer,
        'EXPRESSION': '"rodzaj" != \'punkt wysokościowy w terenie\'',
        'FAIL_OUTPUT': 'memory:',
        'OUTPUT': 'memory:'
    })
    
    def localFun(obiektyZbledami, lyr):
        deleteduplicategeometries = processing.run("native:deleteduplicategeometries", {
            'INPUT': lyr,
            'OUTPUT': 'memory:'
        })
        
        liczbaUsunietychObiektow = layer.featureCount() - deleteduplicategeometries['OUTPUT'].featureCount()
        if liczbaUsunietychObiektow > 0:
            for obj1 in lyr.getFeatures():
                czyObiektIstnieje = False
                for obj2 in deleteduplicategeometries['OUTPUT'].getFeatures():
                    if obj1['gml_id'] == obj2['gml_id']:
                        czyObiektIstnieje = True
                        break
                if not czyObiektIstnieje:
                    obiektyZbledami.append(obj1)
    
    if extractbyexpression['FAIL_OUTPUT'].featureCount() > 0:
        localFun(obiektyZbledami, extractbyexpression['FAIL_OUTPUT'])
    
    localFun(obiektyZbledami, extractbyexpression['OUTPUT'])
    
    return obiektyZbledami


def validateGeometry(layer):
    obiektyZbledami = set()
    
    checkvalidity1 = processing.run("qgis:checkvalidity", {
        'INPUT_LAYER': layer,
        'METHOD': 1, # QGIS
        'INVALID_OUTPUT': 'memory:',
        'ERROR_OUTPUT': 'memory:'
    })
    
    for obj in checkvalidity1['INVALID_OUTPUT'].getFeatures():
        geom = obj.geometry()
        if geom.type() == QgsWkbTypes.LineGeometry:
            if geom.asPolyline()[0] == geom.asPolyline()[-1]:
                continue
        obiektyZbledami.add(obj)
    
    checkvalidity2 = processing.run("qgis:checkvalidity", {
        'INPUT_LAYER': layer,
        'METHOD': 2, # GEOS
        'INVALID_OUTPUT': 'memory:',
        'ERROR_OUTPUT': 'memory:'
    })
    
    for obj in checkvalidity2['INVALID_OUTPUT'].getFeatures():
        geom = obj.geometry()
        if geom.type() == QgsWkbTypes.LineGeometry:
            if geom.asPolyline()[0] == geom.asPolyline()[-1]:
                continue
        obiektyZbledami.add(obj)
    
    return obiektyZbledami


def adjaMinus2cmBufor(layer, klasa):
    ADJA_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace(klasa,"OT_ADJA_A"))[0]
    
    powiat = processing.run("qgis:extractbyexpression", {
        'INPUT': ADJA_A_layer,
        'EXPRESSION': '"rodzaj" = \'powiat\'',
        'FAIL_OUTPUT': 'memory:',
        'OUTPUT': 'memory:'
    })
    
    bufor = processing.run("native:buffer", {
        'INPUT': powiat['OUTPUT'],
        'DISTANCE': -0.02,
        'SEGMENTS': 10,
        'DISSOLVE': True,
        'OUTPUT': 'memory:'
    })
    
    # zamiana poligonu na linie
    granica = processing.run("native:polygonstolines", {
        'INPUT': bufor['OUTPUT'],
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    return granica


def minimalnaPowierzchnia(layer):
    minPowWarstwy = {"OT_PTWP_A":80,"OT_PTZB_A":1000,"OT_PTLZ_A":500, "OT_PTRK_A":1000,"OT_PTUT_A":1000,"OT_PTGN_A":1000,
                     "OT_PTSO_A":1000,"OT_PTWZ_A":1000,"OT_PTNZ_A":1000,"OT_BUWT_A":100,"OT_BUZT_A":175,"OT_KUSK_A":3000,
                     "OT_KUHO_A":3000,"OT_KUHU_A":3000,"OT_KUOS_A":3000,"OT_KUOZ_A":3000,"OT_KUZA_A":3000}
    obiektyZbledami = []
    klasa = layer.name()[-9:]
    
    granica = adjaMinus2cmBufor(layer, klasa)
    
    for feature in layer.getFeatures():
        geom = feature.geometry()
        if klasa == 'OT_BUZT_A' and feature['rodzaj'] != 'zbiornik':
            continue
        else:
            if geom.area() < minPowWarstwy[klasa]:
                for g in granica.getFeatures():
                    if not geom.intersects(g.geometry()):
                        obiektyZbledami.append(feature)
    
    return obiektyZbledami


def minimalnaPTRKwzgledemPTLZ(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'PTRK_A':
        PTLZ_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_PTRK_A","OT_PTLZ_A"))[0]
        PTRK_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    identyfikatory_bledow = set()
    
    granica = adjaMinus2cmBufor(layer, "OT_PTRK_A")
    
    for PTRK_A_feature in PTRK_A_layer.getFeatures():
        for PTLZ_A_feature in PTLZ_A_layer.getFeatures():
            geom1 = PTRK_A_feature.geometry()
            geom2 = PTLZ_A_feature.geometry()
            if geom1.area() < 2000 and PTRK_A_feature.attribute('rodzaj') == 'krzewy':
                styka = False
                for g in granica.getFeatures():
                    if geom1.intersects(geom2) and not geom1.intersects(g.geometry()) and PTRK_A_feature.id() not in identyfikatory_bledow:
                        styka = True
                        obiektyZbledami.append(PTRK_A_feature)
                        identyfikatory_bledow.add(PTRK_A_feature.id())
    
    return obiektyZbledami


def minimalnaPTTRronda(layer):
    minimalnaPowierzchniaBezWod(layer)


def minimalnaPowierzchniaBezWod(layer):
    obiektyZbledami = []
    minPowWarstwy = {"OT_PTGN_A":1000, "OT_PTLZ_A":500, "OT_PTRK_A":1000, "OT_PTTR_A":1000}
    klasa = layer.name()[-9:]
    
    granica = adjaMinus2cmBufor(layer, klasa)
    
    pokrycie = []
    for layer_id, lyr in QgsProject.instance().mapLayers().items():
        if lyr.name().__contains__("OT_PT"): # wrzucenie wszystkich warstw Pokrycia do jednej tablicy
            pokrycie.append(lyr)
    
    index_granica = QgsSpatialIndex()
    index_pokrycie = []
    for lyr in pokrycie: # umieszczenie wszystkich indeksów na obiekcie przestrzennym
       index = QgsSpatialIndex()
       for feature in lyr.getFeatures():
           index.insertFeature(feature)
       index_pokrycie.append((lyr, index))
     
    for feature in granica.getFeatures():
            index_granica.insertFeature(feature)
    if klasa == 'OT_PTTR_A': # dodatkowy indeks przestrzenny dla PTTR bez ronda
        SKRW_P_layer = QgsProject().instance().mapLayersByName(layer.name().replace(klasa,"OT_SKRW_P"))[0]
        index_SKRW_P = QgsSpatialIndex()
        identyfikatory_bledow = set()
        for SKRW_P_feature in SKRW_P_layer.getFeatures():
                if SKRW_P_feature['rodzaj'] != 'rondo':
                    index_SKRW_P.insertFeature(SKRW_P_feature)
    for feature in layer.getFeatures(): # obiekty z przeglądanych warstw
        geom = feature.geometry()
        graniczy_z = set()
        # Sprawdzanie sąsiedztwa z warstwami OT_PT
        for lyr, index in index_pokrycie:
            for fid in index.intersects(geom.boundingBox()):
                lyr_feature = lyr.getFeature(fid)
                if lyr_feature.id() != feature.id() and geom.intersects(lyr_feature.geometry()): # pomija sąsiada z tej samej warstwy
                    graniczy_z.add(lyr.name())
        # Sprawdzanie, czy obiekt graniczy tylko z jedną warstwą
        if len(graniczy_z) == 1 and any(layer_name.endswith('OT_PTWP_A') for layer_name in graniczy_z):
                continue  # Pomiń obiekt, jeśli graniczy tylko z OT_PTWP_A
        if klasa == 'OT_PTTR_A':
            if geom.area() < minPowWarstwy[klasa]:
                    intersects_SKRW_P = any(geom.intersects(SKRW_P_layer.getFeature(fid).geometry()) for fid in index_SKRW_P.intersects(geom.boundingBox()))
                    touches_boundary = any(geom.intersects(granica.getFeature(fid).geometry()) for fid in index_granica.intersects(geom.boundingBox()))
                    if not intersects_SKRW_P and not touches_boundary and feature.id() not in identyfikatory_bledow:
                        obiektyZbledami.append(feature)
                        identyfikatory_bledow.add(feature.id())
        else:
            if geom.area() < minPowWarstwy[klasa]:
                styka = False
                for g in granica.getFeatures():
                    if not geom.intersects(g.geometry()):
                        styka = True
                        obiektyZbledami.append(feature)
    
    return obiektyZbledami


def minimalnaPTPL(layer):
    obiektyZbledami = []
    
    granica = adjaMinus2cmBufor(layer, "OT_PTPL_A")
    
    for PTPL_A_feature in layer.getFeatures():
        geom = PTPL_A_feature.geometry()
        if geom.area() < 1000 and not 'placNazwa1' in PTPL_A_feature.fields().names():
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(PTPL_A_feature)
    
    return obiektyZbledami


def minPowierzchniaPTPLzKUPG(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'PTPL_A':
        KUPG_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_PTPL_A","OT_KUPG_A"))[0]
        PTPL_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    
    granica = adjaMinus2cmBufor(layer, "OT_PTPL_A")
    
    for PTPL_A_feature in PTPL_A_layer.getFeatures():
        for KUPG_A_feature in KUPG_A_layer.getFeatures():
            geom1 = PTPL_A_feature.geometry()
            geom2 = KUPG_A_feature.geometry()
            if geom2.area() < 3000:
                styka = False
                for g in granica.getFeatures():
                    if geom1.intersects(geom2) and not geom1.intersects(g.geometry()):
                        styka = True
                        obiektyZbledami.append(PTPL_A_feature)
    
    return obiektyZbledami


def minimalnaBUIT(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'BUIT_A':
        BUIT_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    
    granica = adjaMinus2cmBufor(layer, "OT_BUIT_A")
    
    for BUIT_A_feature in BUIT_A_layer.getFeatures():
        geom = BUIT_A_feature.geometry()
        if geom.area() < 1000 and BUIT_A_feature['rodzaj'] in ['zespół dystrybutorów paliwa', 'zespół transformatorów']:
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(BUIT_A_feature)
    
    return obiektyZbledami


def minimalnaKUPG(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'KUPG_A':
        KUPG_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    
    granica = adjaMinus2cmBufor(layer, "OT_KUPG_A")
    
    for KUPG_A_feature in KUPG_A_layer.getFeatures():
        geom = KUPG_A_feature.geometry()
        if geom.area() < 3000 and KUPG_A_feature['rodzaj'] not in ['oczyszczalnia ścieków', 'podstacja elektroenergetyczna', 'teren ujęcia wody']:
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(KUPG_A_feature)
    
    return obiektyZbledami


def minimalnaKUKO(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'KUKO_A':
        KUKO_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    
    granica = adjaMinus2cmBufor(layer, "OT_KUKO_A")
    
    for KUKO_A_feature in KUKO_A_layer.getFeatures():
        geom = KUKO_A_feature.geometry()
        if geom.area() < 3000 and KUKO_A_feature['rodzaj'] != 'stacja paliw':
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(KUKO_A_feature)
    
    return obiektyZbledami


def minimalnaKUSC(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'KUSC_A':
        KUSC_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    
    granica = adjaMinus2cmBufor(layer, "OT_KUSC_A")
    
    for KUSC_A_feature in KUSC_A_layer.getFeatures():
        geom = KUSC_A_feature.geometry()
        if geom.area() < 5000 and KUSC_A_feature['rodzaj'] == 'zespół sakralny lub klasztorny':
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(KUSC_A_feature)
    
    return obiektyZbledami


def minimalnaOIKM(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'OIKM_A':
        OIKM_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    
    granica = adjaMinus2cmBufor(layer, "OT_OIKM_A")
    
    for OIKM_A_feature in OIKM_A_layer.getFeatures():
        geom = OIKM_A_feature.geometry()
        if geom.area() < 500 and OIKM_A_feature['rodzaj'] == 'schody':
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(OIKM_A_feature)
    
    return obiektyZbledami


def minimalnaOIORschron(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'OIOR_A':
        OIOR_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    
    granica = adjaMinus2cmBufor(layer, "OT_OIOR_A")
    
    for OIOR_A_feature in OIOR_A_layer.getFeatures():
        geom = OIOR_A_feature.geometry()
        if geom.area() < 100 and OIOR_A_feature['rodzaj'] == 'bunkier lub schron':
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(OIOR_A_feature)
    
    return obiektyZbledami


def minimalnaOIORszklarnia(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'OIOR_A':
        OIOR_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    
    granica = adjaMinus2cmBufor(layer, "OT_OIOR_A")
    
    for OIOR_A_feature in OIOR_A_layer.getFeatures():
        geom = OIOR_A_feature.geometry()
        if geom.area() < 100 and OIOR_A_feature['rodzaj'] == 'szklarnia niebędąca budynkiem':
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(OIOR_A_feature)
    
    return obiektyZbledami


def minimalnaOIORwiataAltana(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'OIOR_A':
        KUKO_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_OIOR_A","OT_KUKO_A"))[0]
        OIOR_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    identyfikatory_bledow = set()
    
    granica = adjaMinus2cmBufor(layer, "OT_OIOR_A")
    
    for OIOR_A_feature in OIOR_A_layer.getFeatures():
        for KUKO_A_feature in KUKO_A_layer.getFeatures():
            geom1 = OIOR_A_feature.geometry()
            geom2 = KUKO_A_feature.geometry()
            if geom1.area() < 200 and OIOR_A_feature['rodzaj'] == 'wiata lub altana' or (geom1.intersects(geom2) and KUKO_A_feature['rodzaj'] == 'stacja paliw'): 
                styka = False
                for g in granica.getFeatures():
                    if not geom1.intersects(g.geometry()) and OIOR_A_feature.id() not in identyfikatory_bledow:
                        styka = True
                        obiektyZbledami.append(OIOR_A_feature)
                        identyfikatory_bledow.add(OIOR_A_feature.id())
    
    return obiektyZbledami


def granicePowiatow():
    config = configparser.ConfigParser()
    mainPath = pathlib.Path(QgsApplication.qgisSettingsDirPath())/pathlib.Path(r"python/plugins/Walidator_plikow_gml/")
    config.read(str(mainPath)+'/Walidator_plikow_gml.ini')
    granicePowiatowPath = config['DEFAULT']['granicepowiatow']
    granicePowiatow_A = QgsVectorLayer(granicePowiatowPath, 'GranicePowiatow', 'ogr')
    
    # rozbicie multipoligon na poligony
    pojedynczeGranice = processing.run("native:multiparttosingleparts", {
        'INPUT': granicePowiatow_A,
        'OUTPUT': 'memory:'
    })
    
    # zamiana typu geometrii z poligonu na linię
    granicePowiatow_L = processing.run("native:polygonstolines", {
        'INPUT': pojedynczeGranice['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    return granicePowiatow_L


def czyPrzecinaGranicePowiatuDlugoscPonizej50m(layer): # kompatabilnoć w szablonie kontroli
    czyPrzecinaGranicePowiatuDlugoscPonizej25m(layer)


def czyPrzecinaGranicePowiatuDlugoscPonizej25m(layer):
    try:
        obiektyZbledami = []
        granicePowiatow_L = granicePowiatow()
        alg_params = {
            'INPUT': granicePowiatow_L['OUTPUT'],
            'DISTANCE': 7.5, # Odległość bufora
            'SEGMENTS': 8, # Ilość segmentów na kwadrant, większa wartość = bardziej okrągły bufor
            'END_CAP_STYLE': 0,
            'JOIN_STYLE': 0,
            'MITER_LIMIT': 2,
            'DISSOLVE': False, # Ustawienie na True spowoduje scalenie wszystkich buforów w jeden obiekt
            'OUTPUT': 'memory:'
        }
        buforGranicy = processing.run('qgis:buffer', alg_params)['OUTPUT']
        index = QgsSpatialIndex()
        for granica in buforGranicy.getFeatures():
            index.insertFeature(granica)
        for obj in layer.getFeatures():
            if obj.geometry() is None:
                continue
            if obj.geometry().length() < 25 and obj.attribute("kodKarto10k") != NULL:
                czyPrzecina = False
                intersecting_ids = index.intersects(obj.geometry().boundingBox())
                for id in intersecting_ids:
                    granica = buforGranicy.getFeature(id)
                    distance = obj.geometry().distance(granica.geometry())
                    if 0 < distance < 25:
                        czyPrzecina = True
                        break
                if czyPrzecina:
                    obiektyZbledami.append(obj)
    except:
        pass
    return obiektyZbledami


def czyObiektyWewnatrzPowiatu(layer, teryt):
    obiektyZbledami = []
    config = configparser.ConfigParser()
    mainPath = pathlib.Path(QgsApplication.qgisSettingsDirPath())/pathlib.Path("python/plugins/Walidator_plikow_gml/")
    config.read(str(mainPath)+'/Walidator_plikow_gml.ini')
    granicePowiatowPath = config['DEFAULT']['granicepowiatow']
    granicePowiatow_A = QgsVectorLayer(granicePowiatowPath, 'GranicePowiatow', 'ogr')
    granica_powiatu_z_PRG = QgsVectorLayer("Polygon?crs=epsg:2180&field=gml_id:string(254)", "granica powiatu z PRG", "memory")
    request = QgsFeatureRequest(QgsExpression("jpt_kod_je = \'" + teryt + "\'"))
    requestFeatures = granicePowiatow_A.getFeatures(request)
    for requestFeature in requestFeatures:
        granica_powiatu_z_PRG.dataProvider().addFeatures([requestFeature])
        break
    
    bufor = processing.run("native:buffer", {
        'INPUT': granica_powiatu_z_PRG,
        'DISTANCE': 0.02,
        'SEGMENTS': 10,
        'DISSOLVE': True,
        'OUTPUT': 'memory:'
    })
    
    roznica = processing.run("qgis:difference", {
        'INPUT': layer,
        'OVERLAY': bufor['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    pojedynczeObiekty = processing.run("native:multiparttosingleparts", {
        'INPUT': roznica['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    if pojedynczeObiekty['OUTPUT'].featureCount() > 0:
        czyDodacGranice = True
        for lyr in QgsProject.instance().mapLayers().values():
            if lyr.name() == "granica powiatu z PRG":
                czyDodacGranice = False
        if czyDodacGranice:
            QgsProject.instance().addMapLayer(granica_powiatu_z_PRG)
        
        for obj in pojedynczeObiekty['OUTPUT'].getFeatures():
            obiektyZbledami.append(obj)
    
    return obiektyZbledami


def czyOdleglosciMiedzyPoziomicami2m(layer):
    obiekty_z_bledami = []
    
    poziomice = processing.run("qgis:extractbyexpression", {
        'INPUT': layer,
        'EXPRESSION': '"rodzaj" = \'poziomica\' and "kodKarto10k" != \'\'',
        'FAIL_OUTPUT': 'memory:',
        'OUTPUT': 'memory:'
    })
    
    # bufor
    bufor = processing.run("native:buffer", {
        'INPUT': poziomice['OUTPUT'],
        'DISTANCE': 0.999,
        'END_CAP_STYLE': 0,
        'JOIN_STYLE': 0,
        'MITER_LIMIT': 2,
        'SEGMENTS': 5,
        'DISSOLVE': False,
        'OUTPUT': 'memory:'
    })
    
    union = processing.run("qgis:union", {
        'INPUT': bufor['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    nakladanie = QgsVectorLayer("Polygon?crs=epsg:2180&field=gml_id:string(254)", "nakładania buforów poziomic", "memory")
    geom_union = []
    for f in union['OUTPUT'].getFeatures():
        g = f.geometry()
        geom_wkt = g.asWkt()
        obiektBledny = False
        if not geom_wkt in geom_union:
            geom_union.append(geom_wkt)
        else:
            wysokosci = []
            x = bufor['OUTPUT'].getFeatures(g.boundingBox())
            for obiekt_bliski in x:
                if g.intersects(obiekt_bliski.geometry()) == True:
                    if obiekt_bliski['wysokosc'] in wysokosci:
                        obiektBledny = True
                    else:
                        wysokosci.append(obiekt_bliski['wysokosc'])
            if obiektBledny:
                continue
            nakladanie.dataProvider().addFeatures([f])
    
    QgsProject.instance().addMapLayer(nakladanie)
    
    extractbylocation1 = processing.run("qgis:extractbylocation", {
        'INPUT': bufor['OUTPUT'],
        'PREDICATE': 0,
        'INTERSECT': nakladanie,
        'OUTPUT': 'memory:'
    })
    
    extractbylocation2 = processing.run("qgis:extractbylocation", {
        'INPUT': poziomice['OUTPUT'],
        'PREDICATE': 6,
        'INTERSECT':extractbylocation1['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    if extractbylocation2['OUTPUT'].featureCount() > 0:
        for obj in extractbylocation2['OUTPUT'].getFeatures():
            obiekty_z_bledami.append(obj)
    
    return obiekty_z_bledami


def nadmiernaSegmentacja(layer):
    id_to_feature = {feature.id(): feature for feature in layer.getFeatures()} # Tworzenie słownika mapującego ID obiektu na obiekt
    obiekty_z_bledami = []
    spatial_index = QgsSpatialIndex(layer.getFeatures(), flags=QgsSpatialIndex.FlagStoreFeatureGeometries)
    for obj1 in layer.getFeatures():
        nearestNeighbors = spatial_index.nearestNeighbor(obj1.geometry(), 2, 0)
        for nn in nearestNeighbors:
            if obj1.id() == nn:
                continue
            obj2 = id_to_feature[nn]
            atrybuty1 = obj1.attributes()[2:]
            atrybuty2 = obj2.attributes()[2:]
            if not obj1 in obiekty_z_bledami and obj1.geometry().distance(obj2.geometry()) < 0.01 and atrybuty1 == atrybuty2 and not obj1.geometry().equals(obj2.geometry()):
                # sprawdzenie liczby wspólnych wierzchołków. Musi być > 1
                vertices1 = [vertex for vertex in obj1.geometry().vertices()]
                vertices2 = [vertex for vertex in obj2.geometry().vertices()]
                common_vertices = [v for v in vertices1 if v in vertices2]
                if len(common_vertices) > 1:
                    if len(common_vertices) == 2:
                        if vertices1[0] == vertices1[-1] or vertices2[0] == vertices2[-1]:
                            pass
                        else:
                            obiekty_z_bledami.append(obj1)
                            break
                    else:
                        obiekty_z_bledami.append(obj1)
                        break
    
    return obiekty_z_bledami


def nadmiernaSegmentacja_rtwl(layer):
    poziomice = processing.run("qgis:extractbyexpression", {
        'INPUT': layer,
        'EXPRESSION': '"rodzaj" = \'poziomica\' and "kodKarto10k" != \'\'',
        'FAIL_OUTPUT': 'memory:',
        'OUTPUT': 'memory:'
    })
    
    id_to_feature = {feature.id(): feature for feature in poziomice['OUTPUT'].getFeatures()} # Tworzenie słownika mapującego ID obiektu na obiekt
    obiekty_z_bledami = []
    hash_to_ids = {}
    spatial_index = QgsSpatialIndex(poziomice['OUTPUT'].getFeatures(), flags=QgsSpatialIndex.FlagStoreFeatureGeometries)
    
    for feature in id_to_feature.values():
        spatial_index.addFeature(feature)
    for feature_id, feature in id_to_feature.items():
        # Utwórz hash na podstawie atrybutów (pomijając pierwsze dwa)
        attrs_hash = hash(tuple(feature.attributes()[2:]))
        if attrs_hash in hash_to_ids:
            hash_to_ids[attrs_hash].append(feature_id)
        else:
            hash_to_ids[attrs_hash] = [feature_id]
    for attrs_hash, ids in hash_to_ids.items():
       if len(ids) > 1: # Jeśli więcej niż jeden obiekt ma ten sam hash
           for id in ids:
               obj1 = id_to_feature[id]
               bbox = obj1.geometry().boundingBox()
               bbox.grow(0.01)
               candidates_ids = spatial_index.intersects(bbox)
               candidates_ids.remove(id)
               for candidate_id in candidates_ids:
                   if candidate_id in ids: # Porównujemy tylko w ramach tej samej grupy hashowej
                        obj2 = id_to_feature[candidate_id]
                        if not obj1 in obiekty_z_bledami and obj1.geometry().distance(obj2.geometry()) < 0.01 and not obj1.geometry().equals(obj2.geometry()):
                            obiekty_z_bledami.append(obj1)
                            break
    
    return obiekty_z_bledami


def przewerteksowanie(layer):
    obiekty_z_bledami = []
    
    poziomice = processing.run("qgis:extractbyexpression", {
        'INPUT': layer,
        'EXPRESSION': '"rodzaj" = \'poziomica\'',
        'FAIL_OUTPUT': 'memory:',
        'OUTPUT': 'memory:'
    })
    
    simplifygeometries = processing.run("native:simplifygeometries", {
        'INPUT': poziomice['OUTPUT'],
        'METHOD': 0, # DP
        'TOLERANCE': 0.05, # 5 cm strzałki
        'OUTPUT': 'memory:'
        })
    
    roznica = processing.run("qgis:difference", {
        'INPUT': poziomice['OUTPUT'],
        'OVERLAY': simplifygeometries['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    pojedynczeObiekty = processing.run("native:multiparttosingleparts", {
        'INPUT': roznica['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    if pojedynczeObiekty['OUTPUT'].featureCount() > 0:
        for obj in pojedynczeObiekty['OUTPUT'].getFeatures():
            obiekty_z_bledami.append(obj)
    
    return obiekty_z_bledami


def przecieciaLiniiNapieciaPodziemna(layer):
    obiekty_z_bledami = []
    OT_SULN_L_layer = None
    OT_BUWT_P_layer = None
    if layer.name()[-6:] == 'SULN_L':
        OT_BUWT_P_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_SULN_L","OT_BUWT_P"))[0]
        OT_SULN_L_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    index = QgsSpatialIndex()
    identyfikatory_bledow = set() # Zbiór do śledzenia identyfikatorów błędnych obiektów w celu uniknięcia powieleń
    for feat in OT_BUWT_P_layer.getFeatures():
        index.insertFeature(feat) # Budowanie indeksu przestrzennego do szybszego przetworzenia
    for OT_SULN_L_feature in OT_SULN_L_layer.getFeatures():
        geom = OT_SULN_L_feature.geometry()
        all_points = [vertex for vertex in geom.vertices()]
        # Usuń pierwszy i ostatni punkt (wierzchołek)
        if len(all_points) <= 3:  # Pomiń linie z trzema lub dwoma wierzchołkami
            continue
        analysis_points = [QgsPointXY(vertex.x(), vertex.y()) for vertex in all_points[1:-1]]
        new_geom = QgsGeometry.fromPolylineXY(analysis_points)
        kodkarto = OT_SULN_L_feature['kodKarto10k']
        rodzaj = OT_SULN_L_feature['rodzaj']
        if kodkarto == '0010_444' and rodzaj in ['linia elektroenergetyczna najwyższego napięcia', 'linia elektroenergetyczna wysokiego napięcia', 'linia elektroenergetyczna średniego napięcia']:
            ids = index.intersects(new_geom.boundingBox()) # intersekcja z obiektem
            intersects = False
            for id in ids:
                other_feat = OT_BUWT_P_layer.getFeature(id)
                if other_feat['rodzaj'] == 'słup energetyczny' and new_geom.intersects(other_feat.geometry()) and OT_SULN_L_feature.id() not in identyfikatory_bledow:
                    intersects = True
                    obiekty_z_bledami.append(OT_SULN_L_feature)
                    identyfikatory_bledow.add(OT_SULN_L_feature.id())
    
    return obiekty_z_bledami


def przecieciaLiniiNapieciaNadziemna(layer):
    obiekty_z_bledami = []
    OT_SULN_L_layer = None
    OT_BUWT_P_layer = None
    if layer.name()[-6:] == 'SULN_L':
        OT_BUWT_P_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_SULN_L","OT_BUWT_P"))[0]
        OT_SULN_L_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    index = QgsSpatialIndex()
    identyfikatory_bledow = set() # Zbiór do śledzenia identyfikatorów błędnych obiektów w celu uniknięcia powieleń
    for feat in OT_BUWT_P_layer.getFeatures():
        index.insertFeature(feat) # Budowanie indeksu przestrzennego do szybszego przetworzenia
    for OT_SULN_L_feature in OT_SULN_L_layer.getFeatures():
        geom = OT_SULN_L_feature.geometry()
        all_points = [vertex for vertex in geom.vertices()]
        # Usuń pierwszy i ostatni punkt (wierzchołek)
        if len(all_points) <= 3:  # Pomiń linie z trzema lub dwoma wierzchołkami
            continue
        analysis_points = [QgsPointXY(vertex.x(), vertex.y()) for vertex in all_points[1:-1]]
        new_geom = QgsGeometry.fromPolylineXY(analysis_points)
        kodkarto = OT_SULN_L_feature['kodKarto10k']
        rodzaj = OT_SULN_L_feature['rodzaj']
        if kodkarto == '0010_446' and rodzaj not in ['linia elektroenergetyczna najwyższego napięcia', 'linia elektroenergetyczna wysokiego napięcia', 'linia elektroenergetyczna średniego napięcia']:
            ids = index.intersects(new_geom.boundingBox()) # intersekcja z obiektem
            intersects = False
            for id in ids:
                other_feat = OT_BUWT_P_layer.getFeature(id)
                if not new_geom.intersects(other_feat.geometry()) and other_feat['rodzaj'] == 'słup energetyczny' and OT_SULN_L_feature.id() not in identyfikatory_bledow:
                    intersects = True
                    obiekty_z_bledami.append(OT_SULN_L_feature)
                    identyfikatory_bledow.add(OT_SULN_L_feature.id())
    
    return obiekty_z_bledami


def kontrola_OT_ADMS_P_z_OT_ADMS_A(layer):
    obiekty_z_bledami = []
    OT_ADMS_A_layer = None
    OT_ADMS_P_layer = None
    if layer.name()[-6:] == 'ADMS_P':
        OT_ADMS_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_ADMS_P","OT_ADMS_A"))[0]
        OT_ADMS_P_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    if OT_ADMS_A_layer and OT_ADMS_P_layer:
        identyfikatory_bledow = set() # Zbiór do śledzenia identyfikatorów błędnych obiektów
        nazwy_adms_p = set([feature['nazwa'] for feature in OT_ADMS_P_layer.getFeatures()])
        nazwy_adms_a = set([feature['nazwa'] for feature in OT_ADMS_A_layer.getFeatures()])
        # Sprawdzenie przecięcia i nazw dla obiektów z OT_ADMS_A
        for OT_ADMS_A_feature in OT_ADMS_A_layer.getFeatures():
            is_intersected = False
            nazwa_adms_a = OT_ADMS_A_feature['nazwa']
            # Sprawdzenie przecięcia dla każdego obiektu z OT_ADMS_P
            for OT_ADMS_P_feature in OT_ADMS_P_layer.getFeatures():
                nazwa_adms_p = OT_ADMS_P_feature['nazwa']
                if OT_ADMS_P_feature.geometry().intersects(OT_ADMS_A_feature.geometry()) or OT_ADMS_A_feature.geometry().contains(OT_ADMS_P_feature.geometry()):
                    is_intersected = True
                    break
            if not is_intersected or nazwa_adms_a not in nazwy_adms_p: #... oraz czy nazwy z OT_ADMS_A występują w OT_ADMS_P
                if OT_ADMS_A_feature.id() not in identyfikatory_bledow:
                    obiekty_z_bledami.append(OT_ADMS_A_feature)
                    identyfikatory_bledow.add(OT_ADMS_A_feature.id())
            # Sprawdzenie, czy nazwy z OT_ADMS_P występują w OT_ADMS_A
            if OT_ADMS_P_feature['nazwa'] not in nazwy_adms_a and OT_ADMS_P_feature.id() not in identyfikatory_bledow:
                obiekty_z_bledami.append(OT_ADMS_P_feature)
                identyfikatory_bledow.add(OT_ADMS_P_feature.id())
    
    return obiekty_z_bledami


def kontrolaTERCpunkt(layer):
    obiektyZbledami = []
    adms = None
    adja = None
    if layer.name()[-6:] == 'ADMS_P':
        adja = QgsProject().instance().mapLayersByName(layer.name().replace("OT_ADMS_P","OT_ADJA_A"))[0]
        adms = QgsProject().instance().mapLayersByName(layer.name())[0]
    # Zestaw do śledzenia już dodanych identyfikatorów TERYT
    przetworzone_teryt = set()
    
    # Sprawdzenie, czy są warstwy
    if adms and adja:
        expression = """ "rodzaj" IN ('miasto', 'miasto w gminie miejsko-wiejskiej', 'gmina') """
        # Wykonaj selekcję
        adja.selectByExpression(expression, QgsVectorLayer.SetSelection)
        selected = adja.selectedFeatures()
        # Przygotuj listę identyfikatorów TERYT z warstwy ADJA jako tekst
        identyfikatory_teryt = {str(feature["identyfikatorTerytJednostki"]).zfill(7): feature for feature in selected}
        # Przygotuj słownik dla ADMS_P: klucz to IdentyfikatorTERC, wartość to lista nazw
        identyfikatory_terc_adms = {}
        for feature in adms.getFeatures():
           teryt_adms = str(feature["IdentyfikatorTERC"]).zfill(7)
           if teryt_adms in identyfikatory_terc_adms:
               identyfikatory_terc_adms[teryt_adms].append(feature)
           else:
               identyfikatory_terc_adms[teryt_adms] = [feature]
        # Dla każdego identyfikatora TERYT/TERC
        for teryt, adja_feature in identyfikatory_teryt.items():
            if not teryt in identyfikatory_terc_adms and len(teryt) == 7:
                obiektyZbledami.append(adja_feature)
        for teryt_adms, adms_features in identyfikatory_terc_adms.items():
           if teryt_adms not in identyfikatory_teryt:
               for adms_feature in adms_features:
                   obiektyZbledami.append(adms_feature)
        adja.removeSelection()
    
    return obiektyZbledami


def kontrolaTERCpowierzchnia(layer):
    obiektyZbledami = []
    adms = None
    adja = None
    if layer.name()[-6:] == 'ADMS_A':
        adja = QgsProject().instance().mapLayersByName(layer.name().replace("ADMS","ADJA"))[0]
        adms = QgsProject().instance().mapLayersByName(layer.name())[0]
        
    # Zestaw do śledzenia już dodanych identyfikatorów TERYT
    przetworzone_teryt = set()
    
    # Sprawdzenie, czy jsą warstwy
    if adms and adja:
        # Iteruj przez warstwy
        expression = """ "rodzaj" IN ('miasto', 'miasto w gminie miejsko-wiejskiej', 'gmina') """
        # Wykonaj selekcję na ADJA_A
        adja.selectByExpression(expression, QgsVectorLayer.SetSelection)
        selected = adja.selectedFeatures()
        # Przygotuj listę identyfikatorów TERYT z warstwy ADJA jako tekst
        identyfikatory_teryt = {str(feature["identyfikatorTerytJednostki"]).zfill(7): feature  for feature in selected}
        # Przygotuj słownik dla ADMS_A: klucz to IdentyfikatorTERC, wartość to lista nazw
        identyfikatory_terc_adms = {}
        for feature in adms.getFeatures():
            teryt_adms = str(feature["IdentyfikatorTERC"]).zfill(7)
            if teryt_adms in identyfikatory_terc_adms:
                identyfikatory_terc_adms[teryt_adms].append(feature)
            else:
                identyfikatory_terc_adms[teryt_adms] = [feature]
        # Sprawdź pokrycie
        for teryt, adja_feature in identyfikatory_teryt.items():
            if not teryt in identyfikatory_terc_adms and len(teryt) == 7:
                obiektyZbledami.append(adja_feature)
         # Dodatkowe sprawdzenie: kod TERYT w ADMS_A, ale nie w ADJA
        for teryt_adms, adms_features in identyfikatory_terc_adms.items():
           if teryt_adms not in identyfikatory_teryt:
               for adms_feature in adms_features:
                    obiektyZbledami.append(adms_feature)
        adja.removeSelection()
    
    return obiektyZbledami


def fullCoverage(layer):
    obiektyZbledami = []
    adja = None
    wszystkieObiektyZPokrycia = QgsVectorLayer("Polygon?crs=epsg:" + str(2180), "Wszystkie obiekty z pokrycia", "memory")
    pokrycie = []
    for layer_id, lyr in QgsProject.instance().mapLayers().items():
        if lyr.name().__contains__("OT_PT"):
            pokrycie.append(lyr)
        elif lyr.name().__contains__("OT_ADJA_A"):
            adja = lyr
    
    # Tworzenie indeksu przestrzennego dla każdej warstwy wektorowej
    for l in pokrycie:
        for feature in l.getFeatures():
            wszystkieObiektyZPokrycia.dataProvider().addFeatures([feature])
    
    # Iteracja przez każdą parę warstw do sprawdzenia pokryć
    if adja and not QgsProject.instance().mapLayersByName("nakładania w pokryciu terenu") and not QgsProject.instance().mapLayersByName("dziury w pokryciu terenu"):
        nakladanie = QgsVectorLayer("Polygon?crs=epsg:2180&field=gml_id:string(254)", "nakładania w pokryciu terenu", "memory")
        dziury = QgsVectorLayer("Polygon?crs=epsg:2180&field=gml_id:string(254)", "dziury w pokryciu terenu", "memory")
        
        isvalid_wszystkieObiektyZPokrycia = processing.run("qgis:checkvalidity", {
            'INPUT_LAYER': wszystkieObiektyZPokrycia,
            'METHOD': 2,
            'IGNORE_RING_SELF_INTERSECTION': False,
            'VALID_OUTPUT': 'memory:',
            'INVALID_OUTPUT': 'memory:',
            'ERROR_OUTPUT': 'memory:'
        })
        
        if isvalid_wszystkieObiektyZPokrycia['INVALID_OUTPUT'].featureCount() > 0:
            isvalid_wszystkieObiektyZPokrycia['INVALID_OUTPUT'].setName("błędne geometrie obiektów pokrycia terenu")
            QgsProject.instance().addMapLayer(isvalid_wszystkieObiektyZPokrycia['INVALID_OUTPUT'])
        
        if isvalid_wszystkieObiektyZPokrycia['ERROR_OUTPUT'].featureCount() > 0:
            isvalid_wszystkieObiektyZPokrycia['ERROR_OUTPUT'].setName("lokalizacje błędów geometrii obiektów pokrycia terenu")
            QgsProject.instance().addMapLayer(isvalid_wszystkieObiektyZPokrycia['ERROR_OUTPUT'])
        
        union = processing.run("qgis:union", {
            'INPUT': isvalid_wszystkieObiektyZPokrycia['VALID_OUTPUT'],
            'OUTPUT': 'memory:'
        })
        
        geom_union = []
        for f in union['OUTPUT'].getFeatures():
            g = f.geometry()
            geom_wkt = g.asWkt()
            if not geom_wkt in geom_union:
                geom_union.append(geom_wkt)
            else:
                nakladanie.dataProvider().addFeatures([f])
        
        if nakladanie.featureCount() > 0:
            nakladanie.startEditing()
            for n in nakladanie.getFeatures():
                n.setAttribute(0,'nie dotyczy')
                nakladanie.updateFeature(n)
                obiektyZbledami.append(n)
            nakladanie.commitChanges()
            QgsProject.instance().addMapLayer(nakladanie)
        
        invalid_layer = processing.run("qgis:checkvalidity", {
            'INPUT_LAYER': adja,
            'METHOD': 0,
            'IGNORE_RING_SELF_INTERSECTION': True,
            'VALID_OUTPUT': 'memory:',
            'INVALID_OUTPUT': 'memory:',
            'ERROR_OUTPUT': 'memory:'
            })
        
        if invalid_layer['INVALID_OUTPUT'] and not QgsProject.instance().mapLayersByName("naprawiona OT_ADJA_A"):
            naprawiona = processing.run("native:fixgeometries", {
                'INPUT': adja,
                'OUTPUT': 'memory:'
            })
            naprawiona['OUTPUT'].setName("naprawiona OT_ADJA_A")
            adja = naprawiona['OUTPUT']
        
        if not QgsProject.instance().mapLayersByName("dziury w pokryciu terenu"):
            # bufor -0.01 m
            buforMinus1cm = processing.run("native:buffer", {
                'INPUT': adja,
                'DISTANCE': -0.01,
                'SEGMENTS': 10,
                'DISSOLVE': True,
                'OUTPUT': 'memory:'
            })
            
            roznica = processing.run("qgis:difference", {
                'INPUT': buforMinus1cm['OUTPUT'],
                'OVERLAY': isvalid_wszystkieObiektyZPokrycia['VALID_OUTPUT'],
                'OUTPUT': 'memory:'
            })
            
            pojedynczeDziury = processing.run("native:multiparttosingleparts", {
                'INPUT': roznica['OUTPUT'],
                'OUTPUT': 'memory:'
            })
            
            dziury.startEditing()
            for n in pojedynczeDziury['OUTPUT'].getFeatures():
                if n.geometry().area() > 2:
                    nowyRekord = QgsFeature(dziury.fields())
                    nowyRekord.setAttribute(0,'nie dotyczy')
                    nowyRekord.setGeometry(n.geometry())
                    dziury.addFeature(nowyRekord)
                    obiektyZbledami.append(nowyRekord)
            dziury.commitChanges()
            
            if dziury.featureCount() > 0:
                QgsProject.instance().addMapLayer(dziury)
    
    return obiektyZbledami


def jednostkaEwidencyjnaFullCoverage(layer):
    obiektyZbledami = []
    wszystkieJednostkiEwidencyjne = QgsVectorLayer("Polygon?crs=epsg:" + str(4326), "Wszystkie jednostki ewidencyjne", "memory")
    warstwy = []
    for layer_id, lyr in QgsProject.instance().mapLayers().items():
        if lyr.name().__contains__("EGB_JednostkaEwidencyjna"):
            reprojectlayer = processing.run("native:reprojectlayer", {
                'INPUT': lyr,
                'TARGET_CRS':QgsCoordinateReferenceSystem('EPSG:4326'),
                'OUTPUT': 'memory:'
            })
            warstwy.append(reprojectlayer['OUTPUT'])
    
    for l in warstwy:
        for feature in l.getFeatures():
            wszystkieJednostkiEwidencyjne.dataProvider().addFeatures([feature])
    
    # Iteracja przez każdą parę warstw do sprawdzenia pokryć
    if not QgsProject.instance().mapLayersByName("nakładania w pokryciu jednostek ewidencyjnych") and not QgsProject.instance().mapLayersByName("dziury w pokryciu jednostek ewidencyjnych"):
        nakladanie = QgsVectorLayer("Polygon?crs=epsg:4326&field=gml_id:string(254)", "nakładania w pokryciu jednostek ewidencyjnych", "memory")
        dziury = QgsVectorLayer("Polygon?crs=epsg:4326&field=gml_id:string(254)", "dziury pomiędzy jednostkami ewidencyjnymi", "memory")
        
        isvalid_wszystkieObiektyZPokrycia = processing.run("qgis:checkvalidity", {
            'INPUT_LAYER': wszystkieJednostkiEwidencyjne,
            'METHOD': 2,
            'IGNORE_RING_SELF_INTERSECTION': False,
            'VALID_OUTPUT': 'memory:',
            'INVALID_OUTPUT': 'memory:',
            'ERROR_OUTPUT': 'memory:'
        })
        
        if isvalid_wszystkieObiektyZPokrycia['INVALID_OUTPUT'].featureCount() > 0:
            isvalid_wszystkieObiektyZPokrycia['INVALID_OUTPUT'].setName("błędne geometrie obiektów jednostek ewidencyjnych")
            QgsProject.instance().addMapLayer(isvalid_wszystkieObiektyZPokrycia['INVALID_OUTPUT'])
        
        if isvalid_wszystkieObiektyZPokrycia['ERROR_OUTPUT'].featureCount() > 0:
            isvalid_wszystkieObiektyZPokrycia['ERROR_OUTPUT'].setName("lokalizacje błędów geometrii obiektów jednostek ewidencyjnych")
            QgsProject.instance().addMapLayer(isvalid_wszystkieObiektyZPokrycia['ERROR_OUTPUT'])
        
        union = processing.run("qgis:union", {
            'INPUT': isvalid_wszystkieObiektyZPokrycia['VALID_OUTPUT'],
            'OUTPUT': 'memory:'
        })
        
        pojedynczeNakladania = processing.run("native:multiparttosingleparts", {
            'INPUT': union['OUTPUT'],
            'OUTPUT': 'memory:'
        })
        
        geom_union = []
        for f in pojedynczeNakladania['OUTPUT'].getFeatures():
            g = f.geometry()
            geom_wkt = g.asWkt()
            if not geom_wkt in geom_union:
                geom_union.append(geom_wkt)
            else:
                nakladanie.dataProvider().addFeatures([f])
        
        if nakladanie.featureCount() > 0:
            nakladanie.startEditing()
            for n in nakladanie.getFeatures():
                n.setAttribute(0,'nie dotyczy')
                nakladanie.updateFeature(n)
                obiektyZbledami.append(n)
            nakladanie.commitChanges()
            QgsProject.instance().addMapLayer(nakladanie)
        
        dissolve = processing.run("qgis:dissolve", {
            'INPUT': isvalid_wszystkieObiektyZPokrycia['VALID_OUTPUT'],
            'FIELD': [],
            'OUTPUT': 'memory:'
        })
        
        deleteholes = processing.run("native:deleteholes", {
            'INPUT': dissolve['OUTPUT'],
            'OUTPUT': 'memory:'
        })
        
        roznica = processing.run("qgis:difference", {
            'INPUT': deleteholes['OUTPUT'],
            'OVERLAY': dissolve['OUTPUT'],
            'OUTPUT': 'memory:'
        })
        
        multiparttosingleparts = processing.run("qgis:multiparttosingleparts", {
            'INPUT': roznica['OUTPUT'],
            'OUTPUT': 'memory:'
        })
        
        if not QgsProject.instance().mapLayersByName("dziury pomiędzy jednostkami ewidencyjnymi"):
            dziury.startEditing()
            for n in multiparttosingleparts['OUTPUT'].getFeatures():
                if n.geometry().area() > 0: # 0- bez tolerancji
                    nowyRekord = QgsFeature(dziury.fields())
                    nowyRekord.setAttribute(0,'nie dotyczy')
                    nowyRekord.setGeometry(n.geometry())
                    dziury.addFeature(nowyRekord)
                    obiektyZbledami.append(nowyRekord)
            dziury.commitChanges()
            
            if dziury.featureCount() > 0:
                QgsProject.instance().addMapLayer(dziury)
    
    return obiektyZbledami


def boundaryPTWP(layer):
    try: 
        obiektyZbledami = []
        ptwp = None
        if layer.name().__contains__('RTLW_L'):
            ptwp = QgsProject().instance().mapLayersByName(layer.name().replace("RTLW_L","PTWP_A"))[0]
        if ptwp:
            # bufor -0.02 m
            bufor = processing.run("native:buffer", {
                'INPUT': ptwp,
                'DISTANCE': -0.02,
                'SEGMENTS': 10,
                'DISSOLVE': True,
                'OUTPUT': 'memory:'
            })
            
            pojedynczePTWP = processing.run("native:multiparttosingleparts", {
                'INPUT': bufor['OUTPUT'],
                'OUTPUT': 'memory:'
            })
            
            extractbyexpression = processing.run("qgis:extractbyexpression", {
                'INPUT': layer,
                'EXPRESSION': '"rodzaj" in (\'skarpa\',\'wąwóz\')',
                'FAIL_OUTPUT': 'memory:',
                'OUTPUT': 'memory:'
            })
            
            extractbylocation = processing.run("native:extractbylocation", {
                'INPUT': extractbyexpression['OUTPUT'],
                'INTERSECT': pojedynczePTWP['OUTPUT'],
                'PREDICATE': [0],
                'OUTPUT': 'memory:'
            })
            
            if extractbylocation['OUTPUT'].featureCount() > 0:
                for obj in extractbylocation['OUTPUT'].getFeatures():
                    obiektyZbledami.append(obj)
    except:
        pass
    
    return obiektyZbledami


def boundaryPTWP_poziomica(layer):
    obiektyZbledami = []
    ptwp = None
    if layer.name().__contains__('RTLW_L'):
        ptwp = QgsProject().instance().mapLayersByName(layer.name().replace("RTLW_L","PTWP_A"))[0]
    if ptwp:
        # bufor -0.04 m
        bufor = processing.run("native:buffer", {
            'INPUT': ptwp,
            'DISTANCE': -0.04,
            'SEGMENTS': 10,
            'DISSOLVE': True,
            'OUTPUT': 'memory:'
        })
        
        pojedynczePTWP = processing.run("native:multiparttosingleparts", {
            'INPUT': bufor['OUTPUT'],
            'OUTPUT': 'memory:'
        })
        
        extractbyexpression = processing.run("qgis:extractbyexpression", {
            'INPUT': layer,
            'EXPRESSION': '"rodzaj" in (\'poziomica\') and "kodKarto10k" != \'\'',
            'FAIL_OUTPUT': 'memory:',
            'OUTPUT': 'memory:'
        })
        
        extractbylocation = processing.run("native:extractbylocation", {
            'INPUT': extractbyexpression['OUTPUT'],
            'INTERSECT': pojedynczePTWP['OUTPUT'],
            'PREDICATE': [0],
            'OUTPUT': 'memory:'
        })
        
        if extractbylocation['OUTPUT'].featureCount() > 0:
            for obj in extractbylocation['OUTPUT'].getFeatures():
                obiektyZbledami.append(obj)

    return obiektyZbledami


def KontrolaAtrybutuKlasouzytek(layer, plikGML):
    obiektyZbledami = []
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'egb': 'ewidencjaGruntowIBudynkow:1.0'}
    
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces = ns):
        dzialka = featureMember.find('.//egb:EGB_DzialkaEwidencyjna', namespaces = ns)
        if dzialka is not None:
           # Dla każdego Klasouzytek w obrębie Działki Ewidencyjnej
           for klasouzytek in dzialka.findall('.//egb:EGB_Klasouzytek', namespaces = ns):
               lokalnyId = dzialka.find('.//egb:lokalnyId', namespaces=ns)
               lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
               OFU = klasouzytek.find('.//egb:OFU', namespaces=ns)
               ofu_value = OFU.text if OFU is not None else None
               if ofu_value in ['Ls', 'W']:
                   OZU = klasouzytek.find('.//egb:OZU', namespaces=ns)
                   ozu_value = OZU.text if OZU is not None else None
                   if ozu_value == 'Ls':
                       OZK = klasouzytek.find('.//egb:OZK', namespaces=ns)
                       ozk_value = OZK.text if OZK is not None else None
                       if ozk_value in ['IIIa', 'IIIb', 'IVa', 'IVb']:
                           expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
                           request = QgsFeatureRequest().setFilterExpression(expression)
                           for feature in layer.getFeatures(request):
                               obiektyZbledami.append(feature)
    
    return obiektyZbledami


def KontrolaAtrybutuKlasouzytek2(layer, plikGML):
    obiektyZbledami = []
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'egb': 'ewidencjaGruntowIBudynkow:1.0'}
    
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        dzialka = featureMember.find('.//egb:EGB_DzialkaEwidencyjna', namespaces=ns)
        if dzialka is not None:
           # Dla każdego Klasouzytek w obrębie Działki Ewidencyjnej
           for klasouzytek in dzialka.findall('.//egb:EGB_Klasouzytek', namespaces=ns):
               lokalnyId = dzialka.find('.//egb:lokalnyId', namespaces=ns)
               lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
               OFU = klasouzytek.find('.//egb:OFU', namespaces=ns)
               ofu_value = OFU.text if OFU is not None else None
               if ofu_value in ['R','S', 'Br','Wsr','W','Lzr']:
                   OZU = klasouzytek.find('.//egb:OZU', namespaces=ns)
                   ozu_value = OZU.text if OZU is not None else None
                   if ozu_value == 'R':
                       OZK = klasouzytek.find('.//egb:OZK', namespaces=ns)
                       ozk_value = OZK.text if OZK is not None else None
                       if not ozk_value in ['I','II','IIIa', 'IIIb', 'IVa', 'IVb','V','VI','VIz']:
                           expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
                           request = QgsFeatureRequest().setFilterExpression(expression)
                           for feature in layer.getFeatures(request):
                               obiektyZbledami.append(feature)
    
    return obiektyZbledami


def KontrolaGeometriaSchody(layer, plikGML):
    obiektyZbledami = []
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'egb': 'ewidencjaGruntowIBudynkow:1.0'}
    
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        budynek = featureMember.find('.//egb:EGB_ObiektTrwaleZwiazanyZBudynkiem', namespaces=ns)
        if budynek is not None:
            polKier =  budynek.findall('.//egb:poliliniaKierunkowa', namespaces=ns)
            lokalnyId = budynek.find('.//egb:lokalnyId', namespaces=ns)
            lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
            expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
            request = QgsFeatureRequest().setFilterExpression(expression)
            if not polKier: # całkowity brak atrybutu
                for feature in layer.getFeatures(request):
                    obiektyZbledami.append(feature)
            else:
                for pk in polKier:  # błędy i braki wewnątrz atrybutu
                    posList = pk.find('.//gml:posList', namespaces=ns)
                    posList_wsp = posList.text
                    if posList_wsp is None:
                        for feature in layer.getFeatures(request):
                            obiektyZbledami.append(feature)
    
    return obiektyZbledami


def gminyCzyNakladajaSie(layer):
    obiektyZbledami = []
    gm = processing.run("qgis:extractbyexpression", {
        'INPUT':layer,
        'EXPRESSION':'"rodzaj" = \'gmina\'',
        'OUTPUT':'memory:'})
    gminy = gm['OUTPUT']
    gminy.setName("gminy")
    
    invalid_layer = processing.run("qgis:checkvalidity", {
        'INPUT_LAYER': gminy, 
        'METHOD': 0, 
        'IGNORE_RING_SELF_INTERSECTION': True,
        'VALID_OUTPUT': 'memory:',
        'INVALID_OUTPUT': 'memory:',
        'ERROR_OUTPUT': 'memory:'})
        
        # zawiera warstwę z niepoprawnymi geometriami
    if invalid_layer['INVALID_OUTPUT']:
              params = {
              'INPUT': gminy,
              'OUTPUT': 'memory:'
              }
          # Wykonanie naprawy geometrii
              naprawiona= processing.run("native:fixgeometries", params)['OUTPUT']
              naprawiona.setName("naprawiona ADJA_A")
              gminy = naprawiona
    
    nach = processing.run("qgis:extractbylocation", {
        'INPUT': gminy,
        'PREDICATE': [5],
        'INTERSECT': gminy,
        'OUTPUT': 'memory:'})
    wynik = nach['OUTPUT']
    wynik.setName("wynik") 
    #QgsProject.instance().addMapLayer(wynik)
    for obj in wynik.getFeatures():
        obiektyZbledami.append(obj)
    
    return obiektyZbledami


def miastoWiesCzyNakladajaSie(layer):
    obiektyZbledami = []
    mw = processing.run("qgis:extractbyexpression",{
        'INPUT': layer,
        'EXPRESSION':'"rodzaj"=\'miasto\' or "rodzaj"=\'wieś\'',
        'OUTPUT':'memory:'})
    miastoWies = mw['OUTPUT']
    miastoWies.setName("miasto_wies")
    
    invalid_layer = processing.run("qgis:checkvalidity",{
        'INPUT_LAYER': miastoWies,
        'METHOD': 0,
        'IGNORE_RING_SELF_INTERSECTION': True,
        'VALID_OUTPUT': 'memory:',
        'INVALID_OUTPUT': 'memory:',
        'ERROR_OUTPUT': 'memory:'})
    
        # zawiera warstwę z niepoprawnymi geometriami
    if invalid_layer['INVALID_OUTPUT']:
              params = {
              'INPUT': miastoWies,
              'OUTPUT': 'memory:'
              }
          # Wykonanie naprawy geometrii
              naprawiona= processing.run("native:fixgeometries", params)['OUTPUT']
              naprawiona.setName("naprawiona ADMS_A")
              miastoWies = naprawiona
    
    nach = processing.run("qgis:extractbylocation", {
        'INPUT': miastoWies,
        'PREDICATE': [5],
        'INTERSECT': miastoWies,
        'OUTPUT': 'memory:'})
    
    wynik = nach['OUTPUT']
    wynik.setName("wynik")
    for obj in wynik.getFeatures():
        obiektyZbledami.append(obj)
    
    return obiektyZbledami


def sprawdzLokalnyId(layer):
    obiektyZbledami = []
    if layer.name()[-6:] in ['RTLW_L', 'RTPW_P']:
        # funkcja nie wykona się dla warstw z rzeźbą terenu
        return obiektyZbledami
    uuid_pattern = re.compile(r'^[A-Za-z0-9]{8}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{12}$|^$')
    # Zbiór do sprawdzania unikalności
    unique_ids = set()
    for f in layer.getFeatures():
        lokalny = f.attribute('lokalnyId')
        matches_pattern = bool(uuid_pattern.match(lokalny))
        if not isinstance(lokalny, str):
            lokalny = str(lokalny) # konwersja pustej wartosci na string
        is_unique = lokalny not in unique_ids
        if is_unique and not matches_pattern:
            unique_ids.add(lokalny)
            obiektyZbledami.append(f)
    
    return obiektyZbledami


def sprawdzPrzestrzenNazw(layer):
    obiektyZbledami = []
    if layer.name()[-6:] in ['RTLW_L', 'RTPW_P']:
        # funkcja nie wykona się dla warstw z rzeźbą terenu
        return obiektyZbledami
    dozwolone_kody = {
    '02': '337',  # dolnośląskie
    '04': '994',  # kujawsko-pomrskie
    '06': '3700', # lubelskie
    '26': '370',  # świętokrzyskie
    '08': '333',  # lubuskie
    '10': '340',  # łódzkie
    '12': '283',  # małopolskie
    '14': '330',  # mazowieckie
    '16': '1833', # opolskie
    '18': '332',  # podlaskie
    '20': '335',  # podkarpackie
    '22': '336',  # pomorskie
    '24': '238',  # śląskie
    '28': '341',  # warmińsko-mazurskie
    '30': '308',  # wielkopolskie
    '32': '339'   # zachodniopomorskie
    }
    pattern = re.compile(r'^PL\.PZGiK\.(\d{3,4})\.BDOT10k$')
    # Zbiór do sprawdzania unikalności
    unique_ids = set()
    for f in layer.getFeatures():
        przestrzen = f.attribute('przestrzenNazw')
        match = pattern.match(przestrzen)
        if not isinstance(przestrzen, str):
            przestrzen = str(przestrzen) # konwersja pustej wartosci na string
        if not match: # sprawdza, czy są niezgodne z schematem
            obiektyZbledami.append(f)
        else: 
            woj = layer.name()[13:15] # sprawdza niezgodnosci cyfr w wojewodztwach
            if woj in ['.1', '.0']:
                woj = layer.name()[14:16]
            cyfry = match.group(1) if match.group(1) else None
            expected_cyfry = dozwolone_kody.get(woj, None)
            if isinstance(expected_cyfry, list):
                valid = cyfry in expected_cyfry
            else:
                valid = cyfry == expected_cyfry
                
            if not valid:
                    obiektyZbledami.append(f)
    
    return obiektyZbledami


def sprawdzWersja(layer):
    obiektyZbledami = []
    if layer.name()[-6:] in ['RTLW_L', 'RTPW_P']:
        # funkcja nie wykona się dla warstw z rzeźbą terenu
        return obiektyZbledami
    uuid_pattern = re.compile(r'^[0-9]{4}-[01][0-9]-[0-3][0-9]T[0-2][0-9]:[0-5][0-9]:[0-5][0-9]$|^$')
    # Zbiór do sprawdzania unikalności
    unique_ids = set()
    for f in layer.getFeatures():
        wersja = f.attribute('wersja')
        matches_pattern = bool(uuid_pattern.match(wersja))
        if not isinstance(wersja, str):
            wersja = str(wersja) # konwersja pustej wartosci na string
        is_unique = wersja not in unique_ids
        if is_unique and not matches_pattern:
            unique_ids.add(wersja)
            obiektyZbledami.append(f)
    
    return obiektyZbledami


def sprawdzPoczatekWersjiObiektu(layer):
    obiektyZbledami = []
    if layer.name()[-6:] in ['RTLW_L', 'RTPW_P']:
        # funkcja nie wykona się dla warstw z rzeźbą terenu
        return obiektyZbledami
    uuid_pattern = re.compile(r'^[0-9]{4}-[01][0-9]-[0-3][0-9]T[0-2][0-9]:[0-5][0-9]:[0-5][0-9]$')
    # Zbiór do sprawdzania unikalności
    unique_ids = set()
    for f in layer.getFeatures():
        poczatek = f.attribute('poczatekWersjiObiektu')
        wersja = f.attribute('wersja')
        if not isinstance(wersja, str):
            wersja = str(wersja)
        if not isinstance(poczatek, str):
            poczatek = str(poczatek) # konwersja pustej wartosci na string
        if wersja != poczatek and f.id() not in unique_ids:
             unique_ids.add(f.id())
             obiektyZbledami.append(f)
        if not uuid_pattern.match(wersja) and f.id() not in unique_ids:
             unique_ids.add(f.id())
             obiektyZbledami.append(f)
        if not uuid_pattern.match(poczatek) and f.id() not in unique_ids:
             unique_ids.add(f.id())
             obiektyZbledami.append(f)
    
    return obiektyZbledami


def przestrzenNazw(layer,teryt):
    obiektyZbledami = []
    slownik = {
    '02': '337',  # dolnośląskie
    '04': '994',  # kujawsko-pomrskie
    '06': '3700', # lubelskie
    '08': '333',  # lubuskie
    '10': '340',  # łódzkie
    '12': '283',  # małopolskie
    '14': '330',  # mazowieckie
    '16': '1833', # opolskie
    '18': '332',  # podlaskie
    '20': '335',  # podkarpackie
    '22': '336',  # pomorskie
    '24': '238',  # śląskie
    '26': '370',  # świętokrzyskie
    '28': '341',  # warmińsko-mazurskie
    '30': '308',  # wielkopolskie
    '32': '339'   # zachodniopomorskie
    }
    pattern = re.compile(r'^PL\.PZGiK\.(\d{3,4})\.BDOT10k$')
    # Zbiór do sprawdzania unikalności
    unique_ids = set()
    for f in layer.getFeatures():
        przestrzen = f.attribute('przestrzenNazw')
        if not isinstance(przestrzen, str):
            przestrzen = str(przestrzen) # konwersja pustej wartosci na string
            obiektyZbledami.append(f)
        else:
            match = pattern.match(przestrzen)
            if not match: # sprawdza, czy są niezgodne z schematem
                match = pattern.match(przestrzen)
                obiektyZbledami.append(f)
            else:
                woj = teryt[:2]
                cyfry = match.group(1) if match.group(1) else None
                expected_cyfry = slownik.get(woj, None)
                if isinstance(expected_cyfry, list):
                    valid = cyfry in expected_cyfry
                else:
                    valid = cyfry == expected_cyfry
                if not valid:
                    obiektyZbledami.append(f)
    
    return obiektyZbledami


def zapisWspolrzednych(layer, plikGML):
    obiektyZbledami = []
    pattern = re.compile(r"[0-9]{6}\.[0-9]{3,}")
    plikGML = plikGML.getroot()
    otklasa = f'.//ot:{layer.name()[-9:]}'
    ns = {'gml': 'http://www.opengis.net/gml/3.2', "ot":"urn:gugik:specyfikacje:gmlas:bazaDanychObiektowTopograficznych10k:2.0"}
    warstwy_otklasy = {}
    
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        # Weryfikacja, czy wystąpienia są zgodne z oczekiwaniami
        matches = featureMember.find(otklasa, namespaces=ns)
        if matches is not None:
            geometria = matches.findall('.//ot:geometria', namespaces=ns)
            lokalnyId = matches.find('.//ot:lokalnyId', namespaces=ns)
            lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
            expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
            request = QgsFeatureRequest().setFilterExpression(expression)
            for g in geometria:  # błędy i braki wewnątrz atrybutu
                geom = g.find('.//gml:posList', namespaces=ns)
                geomPkt = g.find('.//gml:pos', namespaces=ns)
                if geom is not None: # linie i powierzchnie
                    geom_wsp = geom.text if geom is not None else "Nieznane ID"
                    if pattern.search(geom_wsp):
                        for feature in layer.getFeatures(request):
                            obiektyZbledami.append(feature)
                elif geomPkt is not None: # punkty
                    geom_wsp = geomPkt.text if geomPkt is not None else "Nieznane ID"
                    if pattern.search(geom_wsp):
                        for feature in layer.getFeatures(request):
                            obiektyZbledami.append(feature)
    
    return obiektyZbledami


def minDlugoscOIPR(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'OIPR_L':
        OIPR_L_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    
    granica = adjaMinus2cmBufor(layer, "OT_OIPR_L")
    
    for OIPR_L_feature in OIPR_L_layer.getFeatures():
        geom = OIPR_L_feature.geometry()
        if geom.length() < 40 and OIPR_L_feature['rodzaj'] in ['rząd drzew','pas krzewów lub żywopłot']:
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(OIPR_L_feature)
    
    return obiektyZbledami


def minDlugoscBUUO(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'BUUO_L':
        BUUO_L_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    
    granica = adjaMinus2cmBufor(layer, "OT_BUUO_L")
    
    for BUUO_L_feature in BUUO_L_layer.getFeatures():
        geom = BUUO_L_feature.geometry()
        if geom.length() < 10 and BUUO_L_feature['rodzaj'] in ['falochron','ostroga']:
            styka = False
            for g in granica['OUTPUT'].getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(BUUO_L_feature)
    
    return obiektyZbledami


def minDlugoscSUPRnaKUPG(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'SUPR_L':
        KUPG_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_SUPR_L","OT_KUPG_A"))[0]
        SUPR_L_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    else:
        return []
    
    granica = adjaMinus2cmBufor(layer, "OT_SUPR_L")
    
    for g in granica.getFeatures():
        ADJA_A_geom = g.geometry()
    
    for SUPR_L_feature in SUPR_L_layer.getFeatures():
        SUPR_L_geom = SUPR_L_feature.geometry()
        SUPR_L_id = SUPR_L_feature.id()
        if SUPR_L_geom.length() < 100 and not SUPR_L_geom.intersects(ADJA_A_geom):
            for KUPG_A_feature in KUPG_A_layer.getFeatures():
                KUPG_A_geom = KUPG_A_feature.geometry()
                if SUPR_L_geom.intersects(KUPG_A_geom):
                    przecina = False
                    for SUPR_L_feature_o in SUPR_L_layer.getFeatures():
                        SUPR_L_id_o = SUPR_L_feature_o.id()
                        if SUPR_L_id_o != SUPR_L_id:
                            SUPR_L_geom_o = SUPR_L_feature_o.geometry()
                            if SUPR_L_geom_o.intersects(SUPR_L_geom):
                                przecina = True
                                break
                    if not przecina:
                        obiektyZbledami.append(SUPR_L_feature)
    
    return obiektyZbledami


def kontrolaZgodnosciIdentyfikatoraUlicyZNazwa(layer, plikcsv):
    obiektyZbledami = []
    global loaded_csv_data
    
    if loaded_csv_data is None:
        loaded_csv_data = pd.read_csv(plikcsv, sep=';', encoding='utf-8')
        loaded_csv_data['CECHA'] = loaded_csv_data['CECHA'].fillna('NULL').str.strip()
        loaded_csv_data['NAZWA_1'] = loaded_csv_data['NAZWA_1'].fillna('NULL')
        loaded_csv_data['NAZWA_2'] = loaded_csv_data['NAZWA_2'].fillna('NULL')
    
    for f in layer.getFeatures():
        try:
            identyfikatorULIC = f.attribute('identyfikatorULIC')
        except:
            return []
        if identyfikatorULIC == NULL: # pomija puste obiekty
            continue
        
        t = ''
        if 'OT_PTPL_A' in layer.name():
            nazwa1 = f.attribute('placNazwa1')
            try:
                nazwa2 = f.attribute('placNazwa2')
            except:
                nazwa2 = 'NULL'
            cecha = f.attribute('placCecha')
            t = 'placCecha:' + cecha + ',placNazwa1:' + nazwa1 + ',placNazwa2:' + nazwa2
        else:
            nazwa1 = str(f.attribute('ulicaNazwa1'))
            try:
                nazwa2 = str(f.attribute('ulicaNazwa2'))
            except:
                nazwa2 = 'NULL'
            cecha = str(f.attribute('ulicaCecha'))
            t = 'ulicaCecha:' + cecha + ',ulicaNazwa1:' + nazwa1 + ',ulicaNazwa2:' + nazwa2
        identyfikatorSIMC = f.attribute('identyfikatorSIMC')
        
        wynik = loaded_csv_data[(loaded_csv_data['SYM_UL'] == identyfikatorULIC) & (loaded_csv_data['SYM'] == identyfikatorSIMC)]
        if len(wynik['CECHA'].tolist()) == 1:
            cecha_GUS = str(wynik['CECHA'].tolist()[0])
            nazwa1_GUS = str(wynik['NAZWA_1'].tolist()[0])
            nazwa2_GUS = str(wynik['NAZWA_2'].tolist()[0])
            if cecha_GUS != cecha or nazwa1_GUS != nazwa1 or nazwa2_GUS != nazwa2:
                gml_id = f["gml_id"] + "|" + ' CECHA:' + cecha_GUS + ',NAZWA_1:' + nazwa1_GUS + ',NAZWA_2:' + nazwa2_GUS + ";" + t
                f.setAttribute(layer.fields().indexFromName("gml_id"), gml_id)
                layer.updateFeature(f)
                
                obiektyZbledami.append(f)
        layer.commitChanges()
    return obiektyZbledami


def kontrolaZgodnosciIdentyfikatoraUlicyZNazwaPlacu(layer):
    obiektyZbledami = []
    
    identyfikator_map = {}
    for f in layer.getFeatures():
        ulic = f.attribute('identyfikatorULIC')
        if ulic == NULL: # pomija puste obiekty
            continue
        nazwa1 = f.attribute('placNazwa1')
        try:
            nazwa2 = f.attribute('placNazwa2')
        except:
            nazwa2 = 'NULL'
        cecha = f.attribute('placCecha')
        if ulic not in identyfikator_map:
            identyfikator_map[ulic] = {
                'cecha': set(),
                'nazwa1': set(),
                'nazwa2': set(),
                'features': []
            }

        # Dodajemy bieżące wartości atrybutów do zestawów
        identyfikator_map[ulic]['cecha'].add(cecha)
        identyfikator_map[ulic]['nazwa1'].add(nazwa1)
        identyfikator_map[ulic]['nazwa2'].add(nazwa2)
        identyfikator_map[ulic]['features'].append(f)

    # Sprawdzamy, czy są jakieś różnice w zestawach
    for ulic, data in identyfikator_map.items():
        if (
            len(data['cecha']) > 1 or
            len(data['nazwa1']) > 1 or
            len(data['nazwa2']) > 1
        ):
            # Jeśli są różnice, dodajemy wszystkie przypadki do obiektyZbledami
            obiektyZbledami.extend(data['features'])
    
    return obiektyZbledami


def pyExpression(layer, sqltxt):
    obiektyZbledami = []
    
    def lexpression(layer, sqltxt):
        expression = QgsExpression(sqltxt)
        
        if expression.hasParserError():
            return f"Parser error: {expression.parserErrorString()}"
        
        if not expression.isValid():
            print("błąd w szablonie kontroli")
        
        # Tworzenie kontekstu wyrażenia
        context = QgsExpressionContext()
        context.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layer))
        
        # Iteracja przez wszystkie obiekty w kontekcie expression
        for feature in layer.getFeatures():
            context.setFeature(feature)
            expression.evaluate(context)
            
            if expression.hasEvalError():
                field_name = expression.evalErrorString().split("'")[1]
                layer.addExpressionField(field_name, QgsField(field_name, QVariant.String))
                
                # iteracyjnie dodaje brakujące pola do warstwy
                lexpression(layer, sqltxt)
                break
    
    lexpression(layer, sqltxt)
    
    request = QgsFeatureRequest(QgsExpression(sqltxt))
    requestFeatures = layer.getFeatures(request)
    for f in requestFeatures:
        obiektyZbledami.append(f)
    
    return obiektyZbledami


def mgrExpression(layer, gml, sqltxt):
    obiektyZbledami = []
    
    if not QgsProject.instance().mapLayersByName(layer.name() + "_dodane_pola"):
        newFields = ['numerPodloza','podloze','szkieletowosc','rodzajGlebyOrganicznej','miazszosc','gatunekMady','gatunekRedziny','informacjeDodatkowe']
        nowePola = []
        
        layer_dodane_pola = QgsVectorLayer('Polygon?crs=EPSG:2180', layer.name() + "_dodane_pola", 'memory')
        memory_provider = layer_dodane_pola.dataProvider()
        memory_provider.addAttributes(layer.fields())
        layer_dodane_pola.updateFields()
        
        for field in newFields:
            for n in [1,2,3,4,5]:
                newFieldName = field + str(n)
                nowePola.append(newFieldName)
                memory_provider.addAttributes([QgsField(newFieldName, QVariant.String)])
        
        for feature in layer.getFeatures():
            memory_provider.addFeature(feature)
        
        layer_dodane_pola.startEditing()
        ns = {'gml': 'http://www.opengis.net/gml/3.2', 'gr': 'urn:gugik:specyfikacje:gmlas:mapaGlebowoRolnicza:1.0'}
        konturyGlebowe = gml.getroot().findall('.//gr:GR_KonturGlebowy', namespaces=ns)
        for konturGlebowy in konturyGlebowe:
            lokalnyId = konturGlebowy.find('.//gr:lokalnyId', namespaces=ns).text
            expression = f"\"lokalnyId\" = '{lokalnyId}'"
            request = QgsFeatureRequest().setFilterExpression(expression)
            lyr_request = layer_dodane_pola.getFeatures(request)
            for feature in lyr_request:
                QCoreApplication.processEvents()
                opisyPodlozy = konturGlebowy.findall('.//gr:opisPodloza', namespaces=ns)
                for opisPodloza in opisyPodlozy:
                    numerPodloza = opisPodloza.find('.//gr:numerPodloza', namespaces=ns).text
                    for field in newFields:
                        value = opisPodloza.find('.//gr:' + field, namespaces=ns)
                        if value == None:
                            wartosc = NULL
                        else:
                            wartosc = value.text
                        feature.setAttribute(layer_dodane_pola.fields().indexFromName(field + numerPodloza), wartosc)
                layer_dodane_pola.updateFeature(feature)
        layer_dodane_pola.commitChanges()
        
        QgsProject.instance().addMapLayer(layer_dodane_pola)
    else:
        layer_dodane_pola = QgsProject.instance().mapLayersByName(layer.name() + "_dodane_pola")[0]
    
    request = QgsFeatureRequest(QgsExpression(sqltxt))
    requestFeatures = layer_dodane_pola.getFeatures(request)
    for f in requestFeatures:
        obiektyZbledami.append(f)
    
    return obiektyZbledami


def numerPodloza(layer, plikGML):
    obiektyZbledami = []
    idenBledow = set()
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'gr': 'urn:gugik:specyfikacje:gmlas:mapaGlebowoRolnicza:1.0'}
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        kontur = featureMember.find('.//gr:GR_KonturGlebowy', namespaces=ns)
        if kontur is not None:
            opisyPodloza =  kontur.findall('.//gr:opisPodloza', namespaces=ns)
            lokalnyId = kontur.find('.//gr:lokalnyId', namespaces=ns)
            lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
            for opisPodloza in opisyPodloza:
                nrPodloza = opisPodloza.find('.//gr:numerPodloza', namespaces=ns)
                nrPodloza_value = nrPodloza.text if nrPodloza is not None else None
                if nrPodloza_value not in ['1','2','3','4','5']:
                    if lokalnyId_text not in idenBledow:
                        expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
                        request = QgsFeatureRequest().setFilterExpression(expression)
                        for feature in layer.getFeatures(request):
                                obiektyZbledami.append(feature)
                        idenBledow.add(lokalnyId_text)
    return obiektyZbledami


def miazszoscPodloza(layer, plikGML):
    obiektyZbledami = []
    idenBledow = set()
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'gr': 'urn:gugik:specyfikacje:gmlas:mapaGlebowoRolnicza:1.0'}
    warunki = {
         '-': '2',
         '=': ['2', '3'],
         '.': '3',
         ':': '4',
        ':.': '5',
    }
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        kontur = featureMember.find('.//gr:GR_KonturGlebowy', namespaces=ns)
        if kontur is not None:
            opisyPodloza =  kontur.findall('.//gr:opisPodloza', namespaces=ns)
            lokalnyId = kontur.find('.//gr:lokalnyId', namespaces=ns)
            lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
            for opisPodloza in opisyPodloza:
                nrPodloza = opisPodloza.find('.//gr:numerPodloza', namespaces=ns)
                miazszosc = opisPodloza.find('.//gr:miazszosc', namespaces=ns)
                nrPodloza_value = nrPodloza.text if nrPodloza is not None else None
                miazszosc_value = miazszosc.text if miazszosc is not None else None
                # Iteracja przez warunki w słowniku
                znaleziono_warunek = False
                for miazszosc_key, nrPodloza_values in warunki.items():
                    if miazszosc_value == miazszosc_key:
                        if isinstance(nrPodloza_values, list):
                            for value in nrPodloza_values:
                                if nrPodloza_value != value:
                                    if lokalnyId_text not in idenBledow:
                                        expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
                                        request = QgsFeatureRequest().setFilterExpression(expression)
                                        for feature in layer.getFeatures(request):
                                            obiektyZbledami.append(feature)
                                        idenBledow.add(lokalnyId_text)
                        else:
                            if nrPodloza_value != nrPodloza_values:
                                # Jeśli spełnia warunek, dodaj do obiektyZbledami
                                if lokalnyId_text not in idenBledow:
                                    expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
                                    request = QgsFeatureRequest().setFilterExpression(expression)
                                    for feature in layer.getFeatures(request):
                                        obiektyZbledami.append(feature)
                                    idenBledow.add(lokalnyId_text)
    
    return obiektyZbledami


def podlozeKompleks(layer, plikGML):
    obiektyZbledami = []
    idenBledow = set()
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'gr': 'urn:gugik:specyfikacje:gmlas:mapaGlebowoRolnicza:1.0'}
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        kontur = featureMember.find('.//gr:GR_KonturGlebowy', namespaces=ns)
        if kontur is not None:
            opisyPodloza =  kontur.findall('.//gr:opisPodloza', namespaces=ns)
            lokalnyId = kontur.find('.//gr:lokalnyId', namespaces=ns)
            lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
            kompleks = kontur.find('.//gr:kompleks', namespaces=ns)
            kompleks_text = kompleks.text if kompleks is not None else "Nieznane ID"
            typPodtyp = kontur.find('.//gr:typPodtyp', namespaces=ns)
            typPodtyp_text = typPodtyp.text if typPodtyp is not None else "Nieznane ID"
            if kompleks_text == 'Tnk':
                for opisPodloza in opisyPodloza:
                    nrPodloza = opisPodloza.find('.//gr:numerPodloza', namespaces=ns)
                    nrPodloza_value = nrPodloza.text if nrPodloza is not None else None
                    podloze = opisPodloza.find('.//gr:podloze', namespaces=ns)
                    podloze_value = podloze.text if podloze is not None else None
                    if typPodtyp_text is not None or podloze_value is not None or nrPodloza_value is not None:
                        if lokalnyId_text not in idenBledow:
                            expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
                            request = QgsFeatureRequest().setFilterExpression(expression)
                            for feature in layer.getFeatures(request):
                                obiektyZbledami.append(feature)
                            idenBledow.add(lokalnyId_text)
                    
    return obiektyZbledami


def kontrola_OT_ADJA_A_z_A02_Granice_powiatow(layer):
    obiektyZbledami = []
    
    ADJAexpression = processing.run("qgis:extractbyexpression", {
        'INPUT': layer,
        'EXPRESSION': '"rodzaj" = \'państwo\' or "rodzaj" = \'województwo\' or "rodzaj" = \'powiat\'',
        'FAIL_OUTPUT': 'memory:',
        'OUTPUT': 'memory:'
    })
    
    terytPowiatu = ''
    for obj in ADJAexpression['OUTPUT'].getFeatures():
        if obj['rodzaj'] == 'powiat':
            terytPowiatu = obj['identyfikatorTERYTjednostki']
            break
    
    config = configparser.ConfigParser()
    mainPath = pathlib.Path(QgsApplication.qgisSettingsDirPath())/pathlib.Path(r"python/plugins/Walidator_plikow_gml/")
    config.read(str(mainPath)+'/Walidator_plikow_gml.ini')
    granicePowiatowPath = config['DEFAULT']['granicepowiatow']
    granicePowiatow = QgsVectorLayer(granicePowiatowPath, 'GranicePowiatow', 'ogr')
    
    powiat_z_PRG = QgsVectorLayer("Polygon?crs=epsg:2180&field=gml_id:string(254)", "granica powiatu z PRG", "memory")
    
    for obj in granicePowiatow.getFeatures():
        if obj['JPT_KOD_JE'] == terytPowiatu:
            powiat_z_PRG.dataProvider().addFeatures([obj])
            break
    
    extractbyexpression_linia = processing.run("native:polygonstolines", {
        'INPUT': ADJAexpression['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    powiat_z_PRG_linia = processing.run("native:polygonstolines", {
        'INPUT': powiat_z_PRG,
        'OUTPUT': 'memory:'
    })
    
    # bufor 0.01 m
    bufor = processing.run("native:buffer", {
        'INPUT': powiat_z_PRG_linia['OUTPUT'],
        'DISTANCE': 0.01,
        'SEGMENTS': 10,
        'DISSOLVE': True,
        'OUTPUT': 'memory:'
    })
    
    difference = processing.run("qgis:difference", {
        'INPUT': extractbyexpression_linia['OUTPUT'],
        'OVERLAY': bufor['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    pojedynczeObiekty = processing.run("native:multiparttosingleparts", {
        'INPUT': difference['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    if pojedynczeObiekty['OUTPUT'].featureCount() > 0:
        czyDodacGranice = True
        for lyr in QgsProject.instance().mapLayers().values():
            if lyr.name() == "granica powiatu z PRG":
                czyDodacGranice = False
        if czyDodacGranice:
            QgsProject.instance().addMapLayer(powiat_z_PRG)
        
        for obj in pojedynczeObiekty['OUTPUT'].getFeatures():
            obiektyZbledami.append(obj)
    
    return obiektyZbledami


def kontrola_OT_ADJA_A_z_A03_Granice_gmin(layer):
    obiektyZbledami = []
    
    extractbyexpression = processing.run("qgis:extractbyexpression", {
        'INPUT': layer,
        'EXPRESSION': '"rodzaj" = \'gmina\'',
        'FAIL_OUTPUT': 'memory:',
        'OUTPUT': 'memory:'
    })
    
    terytyGmin = []
    for obj in extractbyexpression['OUTPUT'].getFeatures():
        if obj['rodzaj'] == 'gmina':
            terytyGmin.append(obj['identyfikatorTERYTjednostki'])
    
    config = configparser.ConfigParser()
    mainPath = pathlib.Path(QgsApplication.qgisSettingsDirPath())/pathlib.Path(r"python/plugins/Walidator_plikow_gml/")
    config.read(str(mainPath)+'/Walidator_plikow_gml.ini')
    graniceGminPath = config['DEFAULT']['granicegmin']
    graniceGmin = QgsVectorLayer(graniceGminPath, 'GraniceGmin', 'ogr')
    gmina_z_PRG = QgsVectorLayer("Polygon?crs=epsg:2180&field=gml_id:string(254)", "granice gmin z PRG", "memory")
    
    for obj in graniceGmin.getFeatures():
        if obj['JPT_KOD_JE'] in terytyGmin:
            gmina_z_PRG.dataProvider().addFeatures([obj])
    
    extractbyexpression_linia = processing.run("native:polygonstolines", {
        'INPUT': extractbyexpression['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    gmina_z_PRG_linia = processing.run("native:polygonstolines", {
        'INPUT': gmina_z_PRG,
        'OUTPUT': 'memory:'
    })
    
    # bufor 0.01 m
    bufor = processing.run("native:buffer", {
        'INPUT': gmina_z_PRG_linia['OUTPUT'],
        'DISTANCE': 0.01,
        'SEGMENTS': 10,
        'DISSOLVE': True,
        'OUTPUT': 'memory:'
    })
    
    difference = processing.run("qgis:difference", {
        'INPUT': extractbyexpression_linia['OUTPUT'],
        'OVERLAY': bufor['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    pojedynczeObiekty = processing.run("native:multiparttosingleparts", {
        'INPUT': difference['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    if pojedynczeObiekty['OUTPUT'].featureCount() > 0:
        czyDodacGranice = True
        for lyr in QgsProject.instance().mapLayers().values():
            if lyr.name() == "granice gmin z PRG":
                czyDodacGranice = False
        if czyDodacGranice:
            QgsProject.instance().addMapLayer(gmina_z_PRG)
        
        
        QgsProject.instance().addMapLayer(gmina_z_PRG)
        for obj in pojedynczeObiekty['OUTPUT'].getFeatures():
            obiektyZbledami.append(obj)
    
    return obiektyZbledami


def kontrola_OT_ADJA_A_z_A05_Granice_jednostek_ewidencyjnych(layer):
    obiektyZbledami = []
    
    extractbyexpression = processing.run("qgis:extractbyexpression", {
        'INPUT': layer,
        'EXPRESSION': '"rodzaj" = \'miasto w gminie miejsko-wiejskiej\'',
        'FAIL_OUTPUT': 'memory:',
        'OUTPUT': 'memory:'
    })
    
    terytyMiast = []
    for obj in extractbyexpression['OUTPUT'].getFeatures():
        if obj['rodzaj'] == 'miasto w gminie miejsko-wiejskiej':
            terytyMiast.append(str(obj['identyfikatorTERYTjednostki']))
    
    config = configparser.ConfigParser()
    mainPath = pathlib.Path(QgsApplication.qgisSettingsDirPath())/pathlib.Path(r"python/plugins/Walidator_plikow_gml/")
    config.read(str(mainPath)+'/Walidator_plikow_gml.ini')
    graniceJednostekEwidencyjnychPath = config['DEFAULT']['granicejednostekewidencyjnych']
    graniceJednostekEwidencyjnych = QgsVectorLayer(graniceJednostekEwidencyjnychPath, 'GraniceJednostekEwidencyjnych', 'ogr')
    graniceJednostekEwidencyjnych_z_PRG = QgsVectorLayer("Polygon?crs=epsg:2180&field=gml_id:string(254)", "granice jednostek ewidencyjnych z PRG", "memory")
    
    for obj in graniceJednostekEwidencyjnych.getFeatures():
        JPT_KOD_JE = str(obj['JPT_KOD_JE']).replace("_", "")
        if JPT_KOD_JE in terytyMiast:
            graniceJednostekEwidencyjnych_z_PRG.dataProvider().addFeatures([obj])
    
    extractbyexpression_linia = processing.run("native:polygonstolines", {
        'INPUT': extractbyexpression['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    jednostkiEwidencyjne_z_PRG_linia = processing.run("native:polygonstolines", {
        'INPUT': graniceJednostekEwidencyjnych_z_PRG,
        'OUTPUT': 'memory:'
    })
    
    # bufor 0.01 m
    bufor = processing.run("native:buffer", {
        'INPUT': jednostkiEwidencyjne_z_PRG_linia['OUTPUT'],
        'DISTANCE': 0.01,
        'SEGMENTS': 10,
        'DISSOLVE': True,
        'OUTPUT': 'memory:'
    })
    
    difference = processing.run("qgis:difference", {
        'INPUT': extractbyexpression_linia['OUTPUT'],
        'OVERLAY': bufor['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    pojedynczeObiekty = processing.run("native:multiparttosingleparts", {
        'INPUT': difference['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    if pojedynczeObiekty['OUTPUT'].featureCount() > 0:
        czyDodacGranice = True
        for lyr in QgsProject.instance().mapLayers().values():
            if lyr.name() == "granice jednostek ewidencyjnych z PRG":
                czyDodacGranice = False
        if czyDodacGranice:
            QgsProject.instance().addMapLayer(graniceJednostekEwidencyjnych_z_PRG)
        
        for obj in pojedynczeObiekty['OUTPUT'].getFeatures():
            obiektyZbledami.append(obj)
    
    return obiektyZbledami


def kompletnoscPlikowBDOT10k(pliki):
    obiektyZbledami = []
    
    listaKlas = ['OT_ADJA_A','OT_ADMS_A','OT_ADMS_P','OT_BUBD_A','OT_BUHD_A','OT_BUHD_L','OT_BUIB_A','OT_BUIB_L','OT_BUIN_L','OT_BUIT_A',
                 'OT_BUIT_P','OT_BUSP_A','OT_BUSP_L','OT_BUTR_L','OT_BUTR_P','OT_BUUO_L','OT_BUWT_A','OT_BUWT_P','OT_BUZM_L','OT_BUZT_A',
                 'OT_BUZT_P','OT_KUHO_A','OT_KUHU_A','OT_KUKO_A','OT_KUKO_P','OT_KUMN_A','OT_KUOS_A','OT_KUOZ_A','OT_KUPG_A','OT_KUPG_P',
                 'OT_KUPW_A','OT_KUSC_A','OT_KUSK_A','OT_KUZA_A','OT_OIKM_A','OT_OIKM_L','OT_OIKM_P','OT_OIMK_A','OT_OIOR_A','OT_OIOR_L',
                 'OT_OIOR_P','OT_OIPR_L','OT_OIPR_P','OT_OISZ_A','OT_PTGN_A','OT_PTKM_A','OT_PTLZ_A','OT_PTNZ_A','OT_PTPL_A','OT_PTRK_A',
                 'OT_PTSO_A','OT_PTTR_A','OT_PTUT_A','OT_PTWP_A','OT_PTWZ_A','OT_PTZB_A','OT_RTLW_L','OT_RTPW_P','OT_SKDR_L','OT_SKJZ_L',
                 'OT_SKPP_L','OT_SKRP_L','OT_SKRW_P','OT_SKTR_L','OT_SULN_L','OT_SUPR_L','OT_SWKN_L','OT_SWRM_L','OT_SWRS_L','OT_TCON_A',
                 'OT_TCPK_A','OT_TCPN_A','OT_TCRZ_A']
    
    brakujaceKlasy = QgsVectorLayer("Point?crs=epsg:2180&field=gml_id:string(254)", "brakujace klasy", "memory")
    
    for klasa in listaKlas:
        brakKlasy = True
        for plik in pliki:
            if plik.__contains__(klasa):
                brakKlasy = False
                break
        if brakKlasy:
            brakujaceKlasy.startEditing()
            nowyRekord = QgsFeature(brakujaceKlasy.fields())
            nowyRekord.setAttribute(0, klasa)
            nowyRekord.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(0, 0)))
            brakujaceKlasy.addFeature(nowyRekord)
            brakujaceKlasy.commitChanges()
            obiektyZbledami.append(nowyRekord)
    
    return obiektyZbledami


def kompletnoscObiektowBDOT10k(layer, plikGMLzrodlowy, plikGML):
    obiektyZbledami = []
    
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'ot': 'urn:gugik:specyfikacje:gmlas:bazaDanychObiektowTopograficznych10k:2.0'}
    lokalnyIdsKontrolowane = [element.text for element in lxml.etree.parse(plikGML).getroot().findall('.//ot:lokalnyId', namespaces=ns)]
    lokalnyIdsZrodla = [element.text for element in lxml.etree.parse(plikGMLzrodlowy).getroot().findall('.//ot:lokalnyId', namespaces=ns)]
    
    set_difference = set(lokalnyIdsZrodla) - set(lokalnyIdsKontrolowane)
    list_difference_result = list(set_difference)
    
    if len(list_difference_result) > 0:
        layerDaneZrodlowe = QgsVectorLayer(plikGMLzrodlowy, 'BDOT10k_dane_zrodlowe', 'ogr')
        
        for diff in list_difference_result:
            expression = QgsExpression(f'"lokalnyId" = \'{diff}\'')
            request = QgsFeatureRequest(expression)
            for feature in layerDaneZrodlowe.getFeatures(request):
                obiektyZbledami.append(feature)
    
    return obiektyZbledami


def kontrolaZmianAtrybutowWzgledemWersji(layer, plikGMLzrodlowy, plikGML):
    obiektyZbledami = set()
    parser = etree.XMLParser(remove_blank_text=True)
    k = lxml.etree.parse(plikGML, parser).getroot()
    z = lxml.etree.parse(plikGMLzrodlowy, parser).getroot()
    
    # usuwanie gml:id
    for elem in k.xpath('//*[@gml:id]', namespaces={'gml': 'http://www.opengis.net/gml/3.2'}):
        del elem.attrib['{http://www.opengis.net/gml/3.2}id']
    # usuwanie gml:id
    for elem in z.xpath('//*[@gml:id]', namespaces={'gml': 'http://www.opengis.net/gml/3.2'}):
        del elem.attrib['{http://www.opengis.net/gml/3.2}id']
    
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'ot': 'urn:gugik:specyfikacje:gmlas:bazaDanychObiektowTopograficznych10k:2.0'}
    fMembers_K = k.findall('.//gml:featureMember', namespaces=ns)
    fMembers_Z = z.findall('.//gml:featureMember', namespaces=ns)
    
    fMembers_K_dic = {}
    fMembers_Z_dic = {}
    badfMember_Z_dic = {}
    
    for fMember in fMembers_K:
        fMembers_K_dic[fMember.find('.//ot:lokalnyId', namespaces=ns).text] = fMember
    fMembers_K_dic = dict(sorted(fMembers_K_dic.items()))
    for fMember in fMembers_Z:
        fMembers_Z_dic[fMember.find('.//ot:lokalnyId', namespaces=ns).text] = fMember
    fMembers_Z_dic = dict(sorted(fMembers_Z_dic.items()))
    del fMembers_K, fMembers_Z
    
    for fMember_Z_dic in fMembers_Z_dic:
        if etree.tostring(fMembers_K_dic[fMember_Z_dic], method="c14n", exclusive=True) != etree.tostring(fMembers_Z_dic[fMember_Z_dic], method="c14n", exclusive=True):
            if fMembers_K_dic[fMember_Z_dic].find('.//ot:wersja', namespaces=ns).text == fMembers_Z_dic[fMember_Z_dic].find('.//ot:wersja', namespaces=ns).text:
                atrybutyZRoznica = set()
                for element in fMembers_Z_dic[fMember_Z_dic].iter():
                    elementyIdentyczne = False
                    for fM_K_dic_element in fMembers_K_dic[fMember_Z_dic].findall('.//' + element.tag):
                        if fM_K_dic_element.text == element.text:
                            elementyIdentyczne = True
                    if not elementyIdentyczne and element.tag != '{http://www.opengis.net/gml/3.2}featureMember':
                        if not element.tag.split("}")[1].startswith('OT_'):
                            if element.tag.split("}")[1] in ['posList','LinearRing','exterior','interior','Polygon','segments','LineStringSegment','Curve','pos','Point']:
                                atrybutyZRoznica.add('geometria')
                            else:
                                atrybutyZRoznica.add(element.tag.split("}")[1])
                for element in fMembers_K_dic[fMember_Z_dic].iter():
                    elementyIdentyczne = False
                    for fM_Z_dic_element in fMembers_Z_dic[fMember_Z_dic].findall('.//' + element.tag):
                        if fM_Z_dic_element.text == element.text:
                            elementyIdentyczne = True
                    if not elementyIdentyczne and element.tag != '{http://www.opengis.net/gml/3.2}featureMember':
                        if not element.tag.split("}")[1].startswith('OT_'):
                            if element.tag.split("}")[1] in ['posList','LinearRing','exterior','interior','Polygon','segments','LineStringSegment','Curve','pos','Point']:
                                atrybutyZRoznica.add('geometria')
                            else:
                                atrybutyZRoznica.add(element.tag.split("}")[1])
                if len(atrybutyZRoznica) > 0:
                    badfMember_Z_dic[fMember_Z_dic] = atrybutyZRoznica
    
    if len(badfMember_Z_dic) > 0:
        for feature in layer.getFeatures():
            if feature['lokalnyId'] in badfMember_Z_dic:
                gml_id = feature["gml_id"] + "|" + ','.join(badfMember_Z_dic[feature['lokalnyId']])
                feature.setAttribute(layer.fields().indexFromName("gml_id"), gml_id)
                layer.updateFeature(feature)
                obiektyZbledami.add(feature)
                layer.commitChanges()
    
    del fMembers_Z_dic, fMembers_K_dic, badfMember_Z_dic
    
    return obiektyZbledami


def kontrolaZgodnosciZDanymiPRNG(layer, plik_prng, klasa):
    global loaded_gml_prng_miejscowosci, loaded_gml_prng_obiektyfizjograficzne
    obiektyZbledami = []
    
    if not 'identyfikatorPRNG' in [field.name() for field in layer.fields()]:
        return []
    
    if loaded_gml_prng_miejscowosci is None and 'PRNG_MIEJSCOWOSCI' in plik_prng:
        loaded_gml_prng_miejscowosci = QgsVectorLayer(plik_prng, 'Warstwa GML', 'ogr')
    
    if loaded_gml_prng_obiektyfizjograficzne is None and 'PRNG_OBIEKTY_FIZJOGRAFICZNE' in plik_prng:
        loaded_gml_prng_obiektyfizjograficzne = QgsVectorLayer(plik_prng, 'Warstwa GML', 'ogr')
    
    if 'PRNG_MIEJSCOWOSCI' in plik_prng:
        loaded_gml_prng = loaded_gml_prng_miejscowosci
    else:
        loaded_gml_prng = loaded_gml_prng_obiektyfizjograficzne
    
    # granica = adjaMinus2cmBufor(layer, klasa)
    
    # linestopolygons = processing.run("qgis:linestopolygons", {
    #     'INPUT': granica,
    #     'OUTPUT': 'memory:'
    # })
    
    # extractbylocation = processing.run("qgis:extractbylocation", {
    #     'INPUT': loaded_gml_prng,
    #     'PREDICATE': [0],
    #     'INTERSECT': linestopolygons['OUTPUT'],
    #     'METHOD': 0,
    #     'OUTPUT': 'memory:'
    # })
    
    posiada_ID_PRNG = processing.run("qgis:extractbyexpression", {
        'INPUT': layer,
        'EXPRESSION': '"identyfikatorPRNG" IS NOT NULL',
        'OUTPUT': 'memory:'
    })
    
    joinattributestable = processing.run("native:joinattributestable", {
        'INPUT': posiada_ID_PRNG['OUTPUT'],
        'FIELD': 'identyfikatorPRNG',
        'INPUT_2': loaded_gml_prng, #extractbylocation['OUTPUT'],
        'FIELD_2':'identyfikatorPRNG',
        'FIELDS_TO_COPY': ['identyfikatorPRNG','nazwaGlowna'],
        'METHOD': 1,
        'DISCARD_NONMATCHING': False,
        'OUTPUT': 'memory:',
        'NON_MATCHING':'memory:'
    })
    
    # joinattributestable2 = processing.run("native:joinattributestable", {
    #     'INPUT': extractbylocation['OUTPUT'],
    #     'FIELD': 'identyfikatorPRNG',
    #     'INPUT_2': joinattributestable['OUTPUT'],
    #     'FIELD_2':'identyfikatorPRNG',
    #     'METHOD': 1,
    #     'DISCARD_NONMATCHING': False,
    #     'OUTPUT': 'memory:',
    #     'NON_MATCHING':'memory:'
    # })
    
    for feature in joinattributestable['OUTPUT'].getFeatures():
        if feature['nazwa'] != feature['nazwaGlowna']:
            gml_id = str(feature["gml_id"]) + '| nazwaGlowna:' + str(feature['nazwaGlowna']) + ',nazwa:' + str(feature['nazwa'])
            feature.setAttribute(joinattributestable['OUTPUT'].fields().indexFromName("gml_id"), gml_id)
            joinattributestable['OUTPUT'].updateFeature(feature)
            obiektyZbledami.append(feature)
    
    if joinattributestable['NON_MATCHING'].featureCount() > 0:
        joinattributestable['NON_MATCHING'].setName(f"obiekty {klasa} nie połączone z PRNG")
        QgsProject.instance().addMapLayer(joinattributestable['NON_MATCHING'])
    
    # if joinattributestable2['NON_MATCHING'].featureCount() > 0:
    #     joinattributestable2['NON_MATCHING'].setName(f"obiekty z PRNG nie połączone z {klasa}")
    #     QgsProject.instance().addMapLayer(joinattributestable2['NON_MATCHING'])
    
    return obiektyZbledami


def kontrolaZgodnosciZDanymiGDOS(layer, tc_zip, klasa):
    global tereny_chronione_zip
    obiektyZbledami = []
    klasaPliki = {'OT_TCPN_A':['ParkiNarodowePolygon.shp'],
                 'OT_TCPK_A':['ParkiKrajobrazowePolygon.shp'],
                 'OT_TCRZ_A':['RezerwatyPolygon.shp'],
                 'OT_TCON_A':['ObszarySpecjalnejOchronyPolygon.shp','SpecjalneObszaryOchronyPolygon.shp']}
    
    if tereny_chronione_zip == None:
        tereny_chronione_zip = tc_zip
        if zipfile.is_zipfile(tereny_chronione_zip):
            plikZIP = zipfile.ZipFile(tereny_chronione_zip,'r')
            for file in plikZIP.namelist():
                plikZIP.extract(file, os.path.dirname(tereny_chronione_zip))
    
    loaded_shp = {'OT_TCPN_A':[],'OT_TCPK_A':[],'OT_TCRZ_A':[],'OT_TCON_A':[]}
    i = 0
    for klasaPlik in klasaPliki[klasa]:
        if len(loaded_shp[klasa]) == 0:
            loaded_shp[klasa] = [QgsVectorLayer(os.path.join(os.path.dirname(tereny_chronione_zip), klasaPlik),f'Warstwa {i} SHP dla klasy {klasa}', 'ogr')]
        else:
            warstwa = QgsVectorLayer(os.path.join(os.path.dirname(tereny_chronione_zip), klasaPlik),f'Warstwa {i} SHP dla klasy {klasa}', 'ogr')
            loaded_shp[klasa].append(warstwa)
        i += 1
    
    posiada_numerCRFOP = processing.run("qgis:extractbyexpression", {
        'INPUT': layer,
        'EXPRESSION': '"numerCRFOP" IS NOT NULL',
        'OUTPUT': 'memory:'
    })
    
    if klasa != 'OT_TCON_A':
        shp_out = processing.run("qgis:extractbyexpression", {
            'INPUT': loaded_shp[klasa][0],
            'EXPRESSION': "not nazwa like '%otulina%'",
            'OUTPUT': 'memory:'
        })
    else:
        shp_out = processing.run("native:mergevectorlayers", {
            'LAYERS': [loaded_shp[klasa][0],loaded_shp[klasa][1]],
            'OUTPUT': 'memory:'
        })
    
    ADJA_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace(klasa,"OT_ADJA_A"))[0]
    
    powiat = processing.run("qgis:extractbyexpression", {
        'INPUT': ADJA_A_layer,
        'EXPRESSION': '"rodzaj" = \'powiat\'',
        'FAIL_OUTPUT': 'memory:',
        'OUTPUT': 'memory:'
    })
    
    clip = processing.run("native:clip", {
        'INPUT': shp_out['OUTPUT'],
        'OVERLAY': powiat['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    shp_out_linie = processing.run("native:polygonstolines", {
        'INPUT': clip['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    posiada_numerCRFOP_linie = processing.run("native:polygonstolines", {
        'INPUT': posiada_numerCRFOP['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    bufor = processing.run("native:buffer", {
        'INPUT': shp_out_linie['OUTPUT'],
        'DISTANCE': 0.20,
        'SEGMENTS': 10,
        'DISSOLVE': True,
        'OUTPUT': 'memory:'
    })
    
    difference = processing.run("qgis:difference", {
        'INPUT': posiada_numerCRFOP_linie['OUTPUT'],
        'OVERLAY': bufor['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    pojedynczeObiekty = processing.run("native:multiparttosingleparts", {
        'INPUT': difference['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    if pojedynczeObiekty['OUTPUT'].featureCount() > 0:
        poza_GDOS = QgsVectorLayer("LineString?crs=epsg:2180&field=gml_id:string(254)", f"niezgodność geometrii {klasa} z danymi GDOŚ", "memory")
        poza_GDOS.startEditing()
        for n in pojedynczeObiekty['OUTPUT'].getFeatures():
            nowyRekord = QgsFeature(poza_GDOS.fields())
            nowyRekord.setAttribute(0,'nie dotyczy')
            nowyRekord.setGeometry(n.geometry())
            poza_GDOS.addFeature(nowyRekord)
            obiektyZbledami.append(nowyRekord)
        poza_GDOS.commitChanges()
        QgsProject.instance().addMapLayer(poza_GDOS)
    
    joinattributestable = processing.run("native:joinattributestable", {
        'INPUT': posiada_numerCRFOP['OUTPUT'],
        'FIELD': 'numerCRFOP',
        'INPUT_2': shp_out['OUTPUT'],
        'FIELD_2':'kodinspire',
        'FIELDS_TO_COPY': ['nazwa','kod'],
        'METHOD': 1,
        'DISCARD_NONMATCHING': False,
        'PREFIX': 'GDOS_',
        'OUTPUT': 'memory:',
        'NON_MATCHING':'memory:'
    })
    
    for feature in joinattributestable['OUTPUT'].getFeatures():
        if klasa != 'OT_TCON_A' and feature['nazwa'] != feature['GDOS_nazwa']:
            gml_id = str(feature["gml_id"]) + '| nazwa:' + str(feature['nazwa']) + ',GDOS_nazwa:' + str(feature['GDOS_nazwa'])
            feature.setAttribute(joinattributestable['OUTPUT'].fields().indexFromName("gml_id"), gml_id)
            joinattributestable['OUTPUT'].updateFeature(feature)
            obiektyZbledami.append(feature)
        elif klasa == 'OT_TCON_A' and (feature['nazwa'] != feature['GDOS_nazwa'] or feature['kodNatura2000'] != feature['GDOS_kod']):
            gml_id = str(feature["gml_id"]) + '| nazwa:' + str(feature['nazwa']) + ',GDOS_nazwa:' + str(feature['GDOS_nazwa']) + \
                                              ',kodNatura2000:' + str(feature['kodNatura2000']) + ',GDOS_kod:' + str(feature['GDOS_kod'])
            feature.setAttribute(joinattributestable['OUTPUT'].fields().indexFromName("gml_id"), gml_id)
            joinattributestable['OUTPUT'].updateFeature(feature)
            obiektyZbledami.append(feature)
    
    if joinattributestable['NON_MATCHING'].featureCount() > 0:
        joinattributestable['NON_MATCHING'].setName(f"obiekty {klasa} nie połączone z GDOŚ")
        QgsProject.instance().addMapLayer(joinattributestable['NON_MATCHING'])
    
    return obiektyZbledami


def kontrolaFormatuAtrybutuWysokosc(layer, expression, plikGML):
    obiektyZbledami = []
    
    extractbyexpression = processing.run("qgis:extractbyexpression", {
        'INPUT': layer,
        'EXPRESSION': expression,
        'FAIL_OUTPUT': 'memory:',
        'OUTPUT': 'memory:'
    })
    if extractbyexpression['OUTPUT'].featureCount() > 0:
        fMembers_dic = {}
        root = plikGML.getroot()
        ns = {'gml': 'http://www.opengis.net/gml/3.2', 'ot': 'urn:gugik:specyfikacje:gmlas:bazaDanychObiektowTopograficznych10k:2.0'}
        fMembers = root.findall('.//gml:featureMember', namespaces=ns)
        for fMember in fMembers:
            wysokosc = fMember.find('.//ot:wysokosc', namespaces=ns).text
            gmlids = fMember.xpath('.//*[@gml:id]', namespaces={'gml': 'http://www.opengis.net/gml/3.2'})
            fMembers_dic[gmlids[0].get('{http://www.opengis.net/gml/3.2}id')] = wysokosc
    
    for feature in extractbyexpression['OUTPUT'].getFeatures():
        new_expression = expression.replace("\\\\", "\\")
        if not bool(re.fullmatch(re.search(r"'(.*?)'", new_expression).group(1), fMembers_dic[feature['gml_id']])):
            obiektyZbledami.append(feature)
    
    return obiektyZbledami
