# -*- coding: utf-8 -*-
"""
/***************************************************************************
 walidatorPlikowGML
                                 A QGIS plugin
 Walidator plików GML baz BDOT10k, PRNG, GESUT, EGiB, BDOT500
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-12-23
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Marcin Lebiecki - Główny Urząd Geodezji i Kartografii
        email                : marcin.lebiecki@gugik.gov.pl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.core import *
from qgis.PyQt.QtCore import *
from qgis import processing
from qgis.PyQt.QtWidgets import *
import pathlib
import configparser
import copy
import sys
import re
from datetime import datetime
import lxml
from lxml import etree
import pandas as pd
import zipfile
import os
from qgis.core import QgsMessageLog, QgsProject, QgsSpatialIndex
from collections import defaultdict



loaded_csv_data = None
loaded_gml_prng_miejscowosci = None
loaded_gml_prng_obiektyfizjograficzne = None
tereny_chronione_zip = None
loaded_shp = {'OT_TCPN_A':[],'OT_TCPK_A':[],'OT_TCRZ_A':[],'OT_TCON_A':[]}


def findDuplicates(layer):
    obiektyZbledami = []
    
    extractbyexpression = processing.run("qgis:extractbyexpression", {
        'INPUT': layer,
        'EXPRESSION': '"rodzaj" != \'punkt wysokościowy w terenie\'',
        'FAIL_OUTPUT': 'memory:',
        'OUTPUT': 'memory:'
    })
    
    if layer.geometryType() == QgsWkbTypes.LineGeometry:
        obj_dl1 = {}
        for obj in extractbyexpression['OUTPUT'].getFeatures():
            dl = obj.geometry().length()
            if dl not in obj_dl1.keys():
                obj_dl1[dl] = obj
            else:
                if obj_dl1[dl].geometry().equals(obj.geometry()):
                    obiektyZbledami.append(obj)
        
        obj_dl2 = {}
        for obj in extractbyexpression['FAIL_OUTPUT'].getFeatures():
            dl = obj.geometry().length()
            if dl not in obj_dl2.keys():
                obj_dl2[dl] = obj
            else:
                if obj_dl2[dl].geometry().equals(obj.geometry()):
                    obiektyZbledami.append(obj)
    else:
        def localFun(obiektyZbledami, lyr):
            deleteduplicategeometries = processing.run("native:deleteduplicategeometries", {
                'INPUT': lyr,
                'OUTPUT': 'memory:'
            })
            
            liczbaUsunietychObiektow = layer.featureCount() - deleteduplicategeometries['OUTPUT'].featureCount()
            if liczbaUsunietychObiektow > 0:
                for obj1 in lyr.getFeatures():
                    czyObiektIstnieje = False
                    for obj2 in deleteduplicategeometries['OUTPUT'].getFeatures():
                        if obj1['gml_id'] == obj2['gml_id']:
                            czyObiektIstnieje = True
                            break
                    if not czyObiektIstnieje:
                        obiektyZbledami.append(obj1)
        
        if extractbyexpression['FAIL_OUTPUT'].featureCount() > 0:
            localFun(obiektyZbledami, extractbyexpression['FAIL_OUTPUT'])
        
        localFun(obiektyZbledami, extractbyexpression['OUTPUT'])
    
    return obiektyZbledami


def validateGeometry(layer):
    obiektyZbledami = set()
    
    checkvalidity1 = processing.run("qgis:checkvalidity", {
        'INPUT_LAYER': layer,
        'METHOD': 1, # QGIS
        'INVALID_OUTPUT': 'memory:',
        'ERROR_OUTPUT': 'memory:'
    })
    
    for obj in checkvalidity1['INVALID_OUTPUT'].getFeatures():
        geom = obj.geometry()
        if geom.type() == QgsWkbTypes.LineGeometry:
            if geom.asPolyline()[0] == geom.asPolyline()[-1] or geom.asPolyline()[0] in geom.asPolyline()[1:-1] or geom.asPolyline()[-1] in geom.asPolyline()[1:-1]:
                continue
        
        obiektyZbledami.add(obj)
    
    checkvalidity2 = processing.run("qgis:checkvalidity", {
        'INPUT_LAYER': layer,
        'METHOD': 2, # GEOS
        'INVALID_OUTPUT': 'memory:',
        'ERROR_OUTPUT': 'memory:'
    })
    
    for obj in checkvalidity2['INVALID_OUTPUT'].getFeatures():
        geom = obj.geometry()
        if geom.type() == QgsWkbTypes.LineGeometry:
            if geom.asPolyline()[0] == geom.asPolyline()[-1] or geom.asPolyline()[0] in geom.asPolyline()[1:-1] or geom.asPolyline()[-1] in geom.asPolyline()[1:-1]:
                continue
        
        obiektyZbledami.add(obj)
    
    return obiektyZbledami


def adjaMinus2cmBufor(layer):
    config = configparser.ConfigParser()
    mainPath = pathlib.Path(QgsApplication.qgisSettingsDirPath()) / pathlib.Path(r"python/plugins/Walidator_plikow_gml/")
    config.read(str(mainPath) + '/Walidator_plikow_gml.ini')
    granicePowiatowPath = config['DEFAULT']['granicepowiatow']
    granicePowiatow = QgsVectorLayer(granicePowiatowPath, 'GranicePowiatow', 'ogr')
    if not granicePowiatow.isValid():
        return QgsVectorLayer("LineString?crs=epsg:2180", "pusta", "memory")
    granicePowiatow = processing.run("native:multiparttosingleparts", {
        'INPUT': granicePowiatow,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    match = re.search(r"\.(\d{4})__", layer.name())
    if not match:
        return QgsVectorLayer("LineString?crs=epsg:2180", "pusta", "memory")
    terytPowiatu = match.group(1)
    powiat_z_PRG = QgsVectorLayer("Polygon?crs=epsg:2180&field=gml_id:string(254)", "granica powiatu z PRG", "memory")
    dopasowane = False
    for obj in granicePowiatow.getFeatures():
        if str(obj['JPT_KOD_JE']) == str(terytPowiatu):
            powiat_z_PRG.dataProvider().addFeatures([obj])
            dopasowane = True
            break
    if not dopasowane:
        print(f"Nie znaleziono powiatu o kodzie {terytPowiatu}.")
        return QgsVectorLayer("LineString?crs=epsg:2180", "pusta", "memory")
    bufor = processing.run("native:buffer", {
        'INPUT': powiat_z_PRG, 
        'DISTANCE': -0.02,
        'SEGMENTS': 10,
        'DISSOLVE': True,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    granica = processing.run("native:polygonstolines", {
        'INPUT': bufor,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    return granica


def minimalnaPowierzchnia(layer):
    minPowWarstwy = {"OT_PTWP_A":80,"OT_PTZB_A":1000,"OT_PTLZ_A":500, "OT_PTRK_A":1000,"OT_PTUT_A":1000,"OT_PTGN_A":1000,
                     "OT_PTSO_A":1000,"OT_PTWZ_A":1000,"OT_PTNZ_A":1000,"OT_BUWT_A":100,"OT_BUZT_A":175,"OT_KUSK_A":3000,
                     "OT_KUHO_A":3000,"OT_KUHU_A":3000,"OT_KUOS_A":3000,"OT_KUOZ_A":3000,"OT_KUZA_A":3000}
    obiektyZbledami = []
    klasa = layer.name()[-9:]
    granica = adjaMinus2cmBufor(layer)
    for feature in layer.getFeatures():
        geom = feature.geometry()
        if klasa == 'OT_BUZT_A' and feature['rodzaj'] != 'zbiornik':
            continue
        else:
            if geom.area() < minPowWarstwy[klasa]:
                for g in granica.getFeatures():
                    if not geom.intersects(g.geometry()):
                        obiektyZbledami.append(feature)
    
    return obiektyZbledami


def minimalnaPTRKwzgledemPTLZ(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'PTRK_A':
        PTLZ_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_PTRK_A","OT_PTLZ_A"))[0]
        PTRK_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    identyfikatory_bledow = set()
    granica = adjaMinus2cmBufor(layer)
    for PTRK_A_feature in PTRK_A_layer.getFeatures():
        for PTLZ_A_feature in PTLZ_A_layer.getFeatures():
            geom1 = PTRK_A_feature.geometry()
            geom2 = PTLZ_A_feature.geometry()
            if geom1.area() < 2000 and PTRK_A_feature.attribute('rodzaj') == 'krzewy':
                styka = False
                for g in granica.getFeatures():
                    if geom1.intersects(geom2) and not geom1.intersects(g.geometry()) and PTRK_A_feature.id() not in identyfikatory_bledow:
                        styka = True
                        obiektyZbledami.append(PTRK_A_feature)
                        identyfikatory_bledow.add(PTRK_A_feature.id())
    
    return obiektyZbledami


def minimalnaPTTRronda(layer):
    minimalnaPowierzchniaBezWod(layer)
    return obiektyZbledami


def minimalnaPowierzchniaBezWod(layer):
    global obiektyZbledami  # Przekazanie do funkcji powyżej
    obiektyZbledami = []
    minPowWarstwy = {"OT_PTGN_A": 1000, "OT_PTLZ_A": 500, "OT_PTRK_A": 1000, "OT_PTTR_A": 500}
    klasa = layer.name()[-9:]
    granica = adjaMinus2cmBufor(layer)
    index_granica = QgsSpatialIndex()
    index_pokrycie = []
    
    for layer_id, lyr in QgsProject.instance().mapLayers().items():
        if "OT_PT" in lyr.name():
            index = QgsSpatialIndex()
            for feature in lyr.getFeatures():
                index.insertFeature(feature)
            index_pokrycie.append((lyr, index))
            
    for feature in granica.getFeatures():
        index_granica.insertFeature(feature)
        
    # Dodatkowy indeks dla PTTR bez ronda
    if klasa == 'OT_PTTR_A':
        SKRW_P_layer = QgsProject().instance().mapLayersByName(layer.name().replace(klasa, "OT_SKRW_P"))[0]
        index_SKRW_P = QgsSpatialIndex()
        identyfikatory_bledow = set()
        for SKRW_P_feature in SKRW_P_layer.getFeatures():
            if SKRW_P_feature['rodzaj'] == 'rondo':
                index_SKRW_P.insertFeature(SKRW_P_feature)
                
    for feature in layer.getFeatures():
        geom = feature.geometry()
        
        # Sprawdzenie powierzchni
        if klasa in minPowWarstwy and geom.area() > minPowWarstwy[klasa]:
            continue
        
        graniczy_z = set()
        
        # Sprawdzenie sąsiedztwa
        for lyr, index in index_pokrycie:
            for fid in index.intersects(geom.boundingBox()):
                lyr_feature = lyr.getFeature(fid)
                if lyr_feature.id() != feature.id() and geom.intersects(lyr_feature.geometry()):
                    graniczy_z.add(lyr.name())
        
        # Pominięcie obiektów graniczących tylko z OT_PTWP_A
        if len(graniczy_z) == 1 and any(layer_name.endswith('OT_PTWP_A') for layer_name in graniczy_z):
            continue  
        
        if klasa == 'OT_PTTR_A':
            intersects_SKRW_P = any(geom.intersects(SKRW_P_layer.getFeature(fid).geometry()) for fid in index_SKRW_P.intersects(geom.boundingBox()))
            touches_boundary = any(geom.intersects(granica.getFeature(fid).geometry()) for fid in index_granica.intersects(geom.boundingBox()))
            
            # Obsługa wysp (PB)– sprawdzenie, czy obiekt jest w pełni otoczony wodą
            surrounded_by_water = all(any(lyr.name().endswith('OT_PTWP_A') for lyr, index in index_pokrycie if fid in index.intersects(geom.boundingBox())) for fid in index.intersects(geom.boundingBox()))
            
            if not intersects_SKRW_P and not touches_boundary and not surrounded_by_water and feature.id() not in identyfikatory_bledow:
                obiektyZbledami.append(feature)
                identyfikatory_bledow.add(feature.id())
        else:
            styka = any(geom.intersects(g.geometry()) for g in granica.getFeatures())
            if not styka:
                obiektyZbledami.append(feature)
    
    return obiektyZbledami


def minimalnaPTPL(layer):
    global obiektyZbledami
    obiektyZbledami = []
    
    minPowPTPL = 1000
    
    granica = adjaMinus2cmBufor(layer)
    if granica is None or not granica.isValid():
        return obiektyZbledami
    
    index_granica = QgsSpatialIndex(granica.getFeatures())
    
    for feature in layer.getFeatures():
        # Pomijamy place, które mają nazwę
        if "placNazwa1" in feature.fields().names() and feature["placNazwa1"]:
            continue
        
        geom = feature.geometry()
        
        # Sprawdzenie minimalnej powierzchni
        if geom.area() < minPowPTPL:
            touches_boundary = any(
                geom.intersects(granica.getFeature(fid).geometry())
                for fid in index_granica.intersects(geom.boundingBox())
            )
            
            if not touches_boundary:
                obiektyZbledami.append(feature)
    
    return obiektyZbledami


def minimalnaBUIT(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'BUIT_A':
        BUIT_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    granica = adjaMinus2cmBufor(layer)
    for BUIT_A_feature in BUIT_A_layer.getFeatures():
        geom = BUIT_A_feature.geometry()
        if geom.area() < 1000 and BUIT_A_feature['rodzaj'] in ['zespół dystrybutorów paliwa', 'zespół transformatorów']:
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(BUIT_A_feature)
    
    return obiektyZbledami


def minimalnaKUPG(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'KUPG_A':
        KUPG_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    granica = adjaMinus2cmBufor(layer)
    for KUPG_A_feature in KUPG_A_layer.getFeatures():
        geom = KUPG_A_feature.geometry()
        if geom.area() < 3000 and KUPG_A_feature['rodzaj'] not in ['oczyszczalnia ścieków', 'podstacja elektroenergetyczna', 'teren ujęcia wody']:
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(KUPG_A_feature)
    
    return obiektyZbledami


def minimalnaKUKO(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'KUKO_A':
        KUKO_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    granica = adjaMinus2cmBufor(layer)
    for KUKO_A_feature in KUKO_A_layer.getFeatures():
        geom = KUKO_A_feature.geometry()
        if geom.area() < 3000 and KUKO_A_feature['rodzaj'] != 'stacja paliw':
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(KUKO_A_feature)
    
    return obiektyZbledami


def minimalnaKUSC(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'KUSC_A':
        KUSC_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    granica = adjaMinus2cmBufor(layer)
    for KUSC_A_feature in KUSC_A_layer.getFeatures():
        geom = KUSC_A_feature.geometry()
        if geom.area() < 5000 and KUSC_A_feature['rodzaj'] == 'zespół sakralny lub klasztorny':
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(KUSC_A_feature)
    
    return obiektyZbledami


def minimalnaOIKM(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'OIKM_A':
        OIKM_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    granica = adjaMinus2cmBufor(layer)
    for OIKM_A_feature in OIKM_A_layer.getFeatures():
        geom = OIKM_A_feature.geometry()
        if geom.area() < 500 and OIKM_A_feature['rodzaj'] == 'schody':
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(OIKM_A_feature)
    
    return obiektyZbledami


def minimalnaOIORschron(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'OIOR_A':
        OIOR_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    granica = adjaMinus2cmBufor(layer)
    for OIOR_A_feature in OIOR_A_layer.getFeatures():
        geom = OIOR_A_feature.geometry()
        if geom.area() < 100 and OIOR_A_feature['rodzaj'] == 'bunkier lub schron':
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(OIOR_A_feature)
    
    return obiektyZbledami


def minimalnaOIORszklarnia(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'OIOR_A':
        OIOR_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    granica = adjaMinus2cmBufor(layer)
    for OIOR_A_feature in OIOR_A_layer.getFeatures():
        geom = OIOR_A_feature.geometry()
        if geom.area() < 100 and OIOR_A_feature['rodzaj'] == 'szklarnia niebędąca budynkiem':
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(OIOR_A_feature)
    
    return obiektyZbledami


def minimalnaOIORwiataAltana(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'OIOR_A':
        KUKO_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_OIOR_A","OT_KUKO_A"))[0]
        OIOR_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    identyfikatory_bledow = set()
    granica = adjaMinus2cmBufor(layer)
    for OIOR_A_feature in OIOR_A_layer.getFeatures():
        for KUKO_A_feature in KUKO_A_layer.getFeatures():
            geom1 = OIOR_A_feature.geometry()
            geom2 = KUKO_A_feature.geometry()
            if geom1.area() < 200 and OIOR_A_feature['rodzaj'] == 'wiata lub altana' or (geom1.intersects(geom2) and KUKO_A_feature['rodzaj'] == 'stacja paliw'): 
                styka = False
                for g in granica.getFeatures():
                    if not geom1.intersects(g.geometry()) and OIOR_A_feature.id() not in identyfikatory_bledow:
                        styka = True
                        obiektyZbledami.append(OIOR_A_feature)
                        identyfikatory_bledow.add(OIOR_A_feature.id())
    
    return obiektyZbledami


def minimalnaBUBD(layer):
    try:
        if not layer.name().endswith("OT_BUBD_A"):
            return []
        obiektyZbledami, already_marked = [], set()
        ptut_layer = next((l for l in QgsProject.instance().mapLayers().values() if l.name().endswith("OT_PTUT_A")), None)
        ptut_index, ptut_dict = QgsSpatialIndex(), {}
        if ptut_layer:
            for f in ptut_layer.getFeatures():
                if f["rodzaj"] == "ogródki działkowe":
                    geom = f.geometry()
                    if geom:
                        ptut_index.insertFeature(f)
                        ptut_dict[f.id()] = (f, geom)
        bubd_index, bubd_dict, geom_cache, area_cache, funkcja_cache = QgsSpatialIndex(), {}, {}, {}, {}
        excluded_funkcje = {
            "dzwonnica",
            "budynek kontroli ruchu kolejowego",
            "budynek kontroli ruchu powietrznego",
            "latarnia morska",
            "kapitanat lub bosmanat portu",
            "stacja kolejki górskiej lub wyciągu krzesełkowego"
        }
        for f in layer.getFeatures():
            geom = f.geometry()
            if not geom:
                continue
            fid = f.id()
            bubd_index.insertFeature(f)
            bubd_dict[fid] = f
            geom_cache[fid] = geom
            area_cache[fid] = geom.area()
            funkcja_cache[fid] = (f["funkcjaOgolnaBudynku"], f["przewazajacaFunkcjaBudynku"])
        for fid, f in bubd_dict.items():
            funkcja_og, przew_funkcja = funkcja_cache[fid]
            if funkcja_og == "budynki mieszkalne" or przew_funkcja in excluded_funkcje:
                continue
            if fid in already_marked:
                continue
            geom, area = geom_cache[fid], area_cache[fid]
            if area >= 40:
                continue
            if ptut_layer:
                for cid in ptut_index.intersects(geom.boundingBox()):
                    ptut_f, ptut_geom = ptut_dict[cid]
                    if geom.within(ptut_geom):
                        obiektyZbledami.append(f)
                        already_marked.add(fid)
                        break
        for fid, f in bubd_dict.items():
            if fid in already_marked:
                continue
            funkcja_og, przew_funkcja = funkcja_cache[fid]
            if funkcja_og == "budynki mieszkalne" or przew_funkcja in excluded_funkcje:
                continue
            geom, area = geom_cache[fid], area_cache[fid]
            if area >= 16:
                continue
            touching = [cid for cid in bubd_index.intersects(geom.boundingBox())
                        if cid != fid and geom.touches(geom_cache[cid])]
            if not touching:
                buf_ids = bubd_index.intersects(geom.buffer(50, 1).boundingBox())
                if any(area_cache[cid] > 40 for cid in buf_ids if cid != fid):
                    obiektyZbledami.append(f)
                    already_marked.add(fid)
            elif len(touching) == 1:
                sasiad_id = touching[0]
                if area_cache[sasiad_id] >= 40:
                    obiektyZbledami.append(f)
                    already_marked.add(fid)
        for fid, f in bubd_dict.items():
            if fid in already_marked:
                continue
            funkcja_og, przew_funkcja = funkcja_cache[fid]
            if funkcja_og == "budynki mieszkalne" or przew_funkcja in excluded_funkcje:
                continue
            geom, area = geom_cache[fid], area_cache[fid]
            if area >= 16:
                continue
            touching = [cid for cid in bubd_index.intersects(geom.boundingBox())
                        if cid != fid and geom.touches(geom_cache[cid])]
            if len(touching) == 1:
                oid = touching[0]
                if oid in already_marked:
                    continue
                o_geom, o_area = geom_cache[oid], area_cache[oid]
                if area + o_area < 39:
                    o_touching = [cid for cid in bubd_index.intersects(o_geom.boundingBox())
                                  if cid not in (fid, oid) and o_geom.touches(geom_cache[cid])]
                    bb = geom.combine(o_geom).boundingBox().buffered(50)
                    others = [cid for cid in bubd_index.intersects(bb) if cid not in (fid, oid)]
                    if others and not o_touching:
                        obiektyZbledami.extend([f, bubd_dict[oid]])
                        already_marked.update((fid, oid))
        for fid, f in bubd_dict.items():
            if fid in already_marked:
                continue
            funkcja_og, przew_funkcja = funkcja_cache[fid]
            if funkcja_og == "budynki mieszkalne" or przew_funkcja in excluded_funkcje:
                continue
            geom, area = geom_cache[fid], area_cache[fid]
            if area >= 39:
                continue
            touching = [cid for cid in bubd_index.intersects(geom.boundingBox())
                        if cid != fid and geom.touches(geom_cache[cid])]
            if not touching:
                buffer_geom = geom.buffer(15, 1)
                in_buf = [cid for cid in bubd_index.intersects(buffer_geom.boundingBox())
                          if cid != fid and geom_cache[cid].intersects(buffer_geom)]
                if any(area_cache[cid] >= 40 for cid in in_buf):
                    obiektyZbledami.append(f)
                    already_marked.add(fid)
        return obiektyZbledami
    except Exception as e:
        print(f"Błąd w kontroli minimalnaBUBD: {e}")
        return []


def granicePowiatow():
    config = configparser.ConfigParser()
    mainPath = pathlib.Path(QgsApplication.qgisSettingsDirPath())/pathlib.Path(r"python/plugins/Walidator_plikow_gml/")
    config.read(str(mainPath)+'/Walidator_plikow_gml.ini')
    granicePowiatowPath = config['DEFAULT']['granicepowiatow']
    granicePowiatow_A = QgsVectorLayer(granicePowiatowPath, 'GranicePowiatow', 'ogr')
    
    # rozbicie multipoligon na poligony
    pojedynczeGranice = processing.run("native:multiparttosingleparts", {
        'INPUT': granicePowiatow_A,
        'OUTPUT': 'memory:'
    })
    
    # zamiana typu geometrii z poligonu na linię
    granicePowiatow_L = processing.run("native:polygonstolines", {
        'INPUT': pojedynczeGranice['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    return granicePowiatow_L


def czyPrzecinaGranicePowiatuDlugoscPonizej50m(layer): # kompatabilnosć w szablonie kontroli
    czyPrzecinaGranicePowiatuDlugoscPonizej25m(layer)


def czyPrzecinaGranicePowiatuDlugoscPonizej25m(layer):
    try:
        obiektyZbledami = []
        granicePowiatow_L = granicePowiatow()
        alg_params = {
            'INPUT': granicePowiatow_L['OUTPUT'],
            'DISTANCE': 7.5, # Odległość bufora
            'SEGMENTS': 8, # Ilość segmentów na kwadrant, większa wartość = bardziej okrągły bufor
            'END_CAP_STYLE': 0,
            'JOIN_STYLE': 0,
            'MITER_LIMIT': 2,
            'DISSOLVE': False, # Ustawienie na True spowoduje scalenie wszystkich buforów w jeden obiekt
            'OUTPUT': 'memory:'
        }
        buforGranicy = processing.run('qgis:buffer', alg_params)['OUTPUT']
        index = QgsSpatialIndex()
        for granica in buforGranicy.getFeatures():
            index.insertFeature(granica)
        for obj in layer.getFeatures():
            if obj.geometry() is None:
                continue
            if obj.geometry().length() < 25 and obj.attribute("kodKarto10k") != NULL:
                czyPrzecina = False
                intersecting_ids = index.intersects(obj.geometry().boundingBox())
                for id in intersecting_ids:
                    granica = buforGranicy.getFeature(id)
                    distance = obj.geometry().distance(granica.geometry())
                    if 0 < distance < 25:
                        czyPrzecina = True
                        break
                if czyPrzecina:
                    obiektyZbledami.append(obj)
    except Exception as e:
        print ("błąd w funkcji czyPrzecinaGranicePowiatuDlugoscPonizej25m:", e)
    return obiektyZbledami


def czyObiektyWewnatrzPowiatu(layer, teryt):
    obiektyZbledami = []
    config = configparser.ConfigParser()
    mainPath = pathlib.Path(QgsApplication.qgisSettingsDirPath()) / pathlib.Path("python/plugins/Walidator_plikow_gml/")
    config.read(str(mainPath) + '/Walidator_plikow_gml.ini')
    granicePowiatowPath = config['DEFAULT']['granicepowiatow']
    
    granicePowiatow_A = QgsVectorLayer(granicePowiatowPath, 'GranicePowiatow', 'ogr')
    granicePowiatow = processing.run("native:multiparttosingleparts", {
        'INPUT': granicePowiatow_A,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    request = QgsFeatureRequest(QgsExpression(f"JPT_KOD_JE = '{teryt}'"))
    granica_powiatu_z_PRG = QgsVectorLayer("Polygon?crs=epsg:2180&field=gml_id:string(254)", "granica powiatu z PRG", "memory")
    granica_powiatu_z_PRG.dataProvider().addFeatures(granicePowiatow.getFeatures(request))
    
    bufor = processing.run("native:buffer", {
        'INPUT': granica_powiatu_z_PRG,
        'DISTANCE': 0.02,
        'SEGMENTS': 10,
        'DISSOLVE': True,
        'OUTPUT': 'memory:'
    })
    
    buforLinie = processing.run("native:polygonstolines", {
        'INPUT': bufor['OUTPUT'], 
        'OUTPUT': 'memory:'
    })["OUTPUT"]
    
    liniePrzecinajace = processing.run('native:extractbylocation', {
        'INPUT': layer,
        'INTERSECT': buforLinie,
        'PREDICATE': [0],
        'OUTPUT': 'memory:'
    })
    
    rozlaczne = processing.run('native:extractbylocation', {
        'INPUT': layer,
        'INTERSECT': bufor['OUTPUT'],
        'PREDICATE': [2],
        'OUTPUT': 'memory:'
    })
    
    if liniePrzecinajace['OUTPUT'].featureCount() > 0 or rozlaczne['OUTPUT'].featureCount() > 0:
        czyDodacGranice = all(lyr.name() != "granica powiatu z PRG" for lyr in QgsProject.instance().mapLayers().values())
        if czyDodacGranice:
            QgsProject.instance().addMapLayer(granica_powiatu_z_PRG)
        
        obiektyZbledami.extend(liniePrzecinajace['OUTPUT'].getFeatures())
        obiektyZbledami.extend(rozlaczne['OUTPUT'].getFeatures())
    
    return obiektyZbledami



def czyPunktyWewnatrzPowiatu(layer):
    punktowe_warstwy = {
        "OT_SKRW_P", "OT_OIPR_P", "OT_OIOR_P",
        "OT_OIKM_P", "OT_KUPG_P", "OT_KUKO_P", "OT_BUZT_P",
        "OT_BUWT_P", "OT_BUIT_P", "OT_ADMS_P"
    }
    if not any(layer.name().endswith(suf) for suf in punktowe_warstwy):
        return []
    match = re.search(r"\.(\d{4})__", layer.name())
    if not match:
        return []
    teryt = match.group(1)
    config = configparser.ConfigParser()
    settings_dir = pathlib.Path(QgsApplication.qgisSettingsDirPath())
    plugin_path = settings_dir / "python/plugins/Walidator_plikow_gml/"
    config.read(str(plugin_path / "Walidator_plikow_gml.ini"))
    granicePowiatowPath = config['DEFAULT']['granicepowiatow']
    granice = QgsVectorLayer(granicePowiatowPath, "GranicePowiatow", "ogr")
    if not granice.isValid():
        return []
    granice = processing.run("native:multiparttosingleparts", {
        'INPUT': granice,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    req = QgsFeatureRequest(QgsExpression(f"JPT_KOD_JE = '{teryt}'"))
    granica_powiatu = QgsVectorLayer("Polygon?crs=epsg:2180", "granica", "memory")
    granica_powiatu.dataProvider().addFeatures(granice.getFeatures(req))
    if granica_powiatu.featureCount() == 0:
        return []
    bufor = processing.run("native:buffer", {
        'INPUT': granica_powiatu,
        'DISTANCE': 0.005,
        'SEGMENTS': 5,
        'DISSOLVE': True,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    geometria_bufora = QgsGeometry.unaryUnion([f.geometry() for f in bufor.getFeatures()])
    if geometria_bufora is None or geometria_bufora.isEmpty():
        return []
        
    obiektyZbledami = []
    for feat in layer.getFeatures():
        geom = feat.geometry()
        if geom and not geometria_bufora.contains(geom):
            obiektyZbledami.append(feat)
            
    return obiektyZbledami


def czyPunktyWewnatrzPowiatu_RTPW(layer):

    if not layer.isValid():
        return []
    
    layer_name = layer.name()
    if not layer_name.endswith("OT_RTPW_P"):
        return []
    match = re.search(r"\.(\d{4})__", layer_name)
    if not match:
        return []
    teryt = match.group(1)
    config = configparser.ConfigParser()
    settings_dir = pathlib.Path(QgsApplication.qgisSettingsDirPath())
    plugin_path = settings_dir / "python/plugins/Walidator_plikow_gml/"
    config.read(str(plugin_path / "Walidator_plikow_gml.ini"))
    granicePowiatowPath = config['DEFAULT']['granicepowiatow']
    granice = QgsVectorLayer(granicePowiatowPath, "GranicePowiatow", "ogr")
    if not granice.isValid():
        return []
    granice_single = processing.run("native:multiparttosingleparts", {
        'INPUT': granice,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    req = QgsFeatureRequest(QgsExpression(f"JPT_KOD_JE = '{teryt}'"))
    granica_powiatu = QgsVectorLayer("Polygon?crs=epsg:2180", "granica", "memory")
    granica_powiatu.dataProvider().addFeatures(granice_single.getFeatures(req))
    if granica_powiatu.featureCount() == 0:
        return []
    bufor = processing.run("native:buffer", {
        'INPUT': granica_powiatu,
        'DISTANCE': 0.005,
        'SEGMENTS': 5,
        'DISSOLVE': True,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    geometria_bufora = QgsGeometry.unaryUnion([f.geometry() for f in bufor.getFeatures()])
    if geometria_bufora is None or geometria_bufora.isEmpty():
        return []
        
    obiektyZbledami = []
    for feat in layer.getFeatures():
        geom = feat.geometry()
        if geom and not geometria_bufora.contains(geom):
            obiektyZbledami.append(feat)
            
    return obiektyZbledami


def czyOdleglosciMiedzyPoziomicami2m(layer):
    obiekty_z_bledami = []
    
    poziomice = processing.run("qgis:extractbyexpression", {
        'INPUT': layer,
        'EXPRESSION': '"rodzaj" = \'poziomica\' and "kodKarto10k" != \'\'',
        'FAIL_OUTPUT': 'memory:',
        'OUTPUT': 'memory:'
    })
    
    # bufor
    bufor = processing.run("native:buffer", {
        'INPUT': poziomice['OUTPUT'],
        'DISTANCE': 0.999,
        'END_CAP_STYLE': 0,
        'JOIN_STYLE': 0,
        'MITER_LIMIT': 2,
        'SEGMENTS': 5,
        'DISSOLVE': False,
        'OUTPUT': 'memory:'
    })
    
    union = processing.run("qgis:union", {
        'INPUT': bufor['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    nakladanie = QgsVectorLayer("Polygon?crs=epsg:2180&field=gml_id:string(254)", "nakładania buforów poziomic", "memory")
    geom_union = []
    for f in union['OUTPUT'].getFeatures():
        g = f.geometry()
        geom_wkt = g.asWkt()
        obiektBledny = False
        if not geom_wkt in geom_union:
            geom_union.append(geom_wkt)
        else:
            wysokosci = []
            x = bufor['OUTPUT'].getFeatures(g.boundingBox())
            for obiekt_bliski in x:
                if g.intersects(obiekt_bliski.geometry()) == True:
                    if obiekt_bliski['wysokosc'] in wysokosci:
                        obiektBledny = True
                    else:
                        wysokosci.append(obiekt_bliski['wysokosc'])
            if obiektBledny:
                continue
            nakladanie.dataProvider().addFeatures([f])
    
    QgsProject.instance().addMapLayer(nakladanie)
    
    extractbylocation1 = processing.run("qgis:extractbylocation", {
        'INPUT': bufor['OUTPUT'],
        'PREDICATE': 0,
        'INTERSECT': nakladanie,
        'OUTPUT': 'memory:'
    })
    
    extractbylocation2 = processing.run("qgis:extractbylocation", {
        'INPUT': poziomice['OUTPUT'],
        'PREDICATE': 6,
        'INTERSECT':extractbylocation1['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    if extractbylocation2['OUTPUT'].featureCount() > 0:
        for obj in extractbylocation2['OUTPUT'].getFeatures():
            obiekty_z_bledami.append(obj)
    
    return obiekty_z_bledami


def nadmiernaSegmentacja(layer):
    id_to_feature = {feature.id(): feature for feature in layer.getFeatures()} # Tworzenie słownika mapującego ID obiektu na obiekt
    obiekty_z_bledami = []
    spatial_index = QgsSpatialIndex(layer.getFeatures(), flags=QgsSpatialIndex.FlagStoreFeatureGeometries)
    for obj1 in layer.getFeatures():
        nearestNeighbors = spatial_index.nearestNeighbor(obj1.geometry(), 2, 0)
        for nn in nearestNeighbors:
            if obj1.id() == nn:
                continue
            obj2 = id_to_feature[nn]
            atrybuty1 = obj1.attributes()[2:]
            atrybuty2 = obj2.attributes()[2:]
            if not obj1 in obiekty_z_bledami and obj1.geometry().distance(obj2.geometry()) < 0.01 and atrybuty1 == atrybuty2 and not obj1.geometry().equals(obj2.geometry()):
                # sprawdzenie liczby wspólnych wierzchołków. Musi być > 1
                vertices1 = [vertex for vertex in obj1.geometry().vertices()]
                vertices2 = [vertex for vertex in obj2.geometry().vertices()]
                common_vertices = [v for v in vertices1 if v in vertices2]
                if len(common_vertices) > 1:
                    if len(common_vertices) == 2:
                        if vertices1[0] == vertices1[-1] or vertices2[0] == vertices2[-1]:
                            pass
                        else:
                            obiekty_z_bledami.append(obj1)
                            break
                    else:
                        obiekty_z_bledami.append(obj1)
                        break
    
    return obiekty_z_bledami


def nadmiernaSegmentacja_rtwl(layer):
    poziomice = processing.run("qgis:extractbyexpression", {
        'INPUT': layer,
        'EXPRESSION': '"rodzaj" = \'poziomica\' and "kodKarto10k" != \'\'',
        'FAIL_OUTPUT': 'memory:',
        'OUTPUT': 'memory:'
    })
    
    id_to_feature = {feature.id(): feature for feature in poziomice['OUTPUT'].getFeatures()} # Tworzenie słownika mapującego ID obiektu na obiekt
    obiekty_z_bledami = []
    hash_to_ids = {}
    spatial_index = QgsSpatialIndex(poziomice['OUTPUT'].getFeatures(), flags=QgsSpatialIndex.FlagStoreFeatureGeometries)
    
    for feature in id_to_feature.values():
        spatial_index.addFeature(feature)
    for feature_id, feature in id_to_feature.items():
        # Utwórz hash na podstawie atrybutów (pomijając pierwsze dwa)
        attrs_hash = hash(tuple(feature.attributes()[2:]))
        if attrs_hash in hash_to_ids:
            hash_to_ids[attrs_hash].append(feature_id)
        else:
            hash_to_ids[attrs_hash] = [feature_id]
    for attrs_hash, ids in hash_to_ids.items():
       if len(ids) > 1: # Jeśli więcej niż jeden obiekt ma ten sam hash
           for id in ids:
               obj1 = id_to_feature[id]
               bbox = obj1.geometry().boundingBox()
               bbox.grow(0.01)
               candidates_ids = spatial_index.intersects(bbox)
               candidates_ids.remove(id)
               for candidate_id in candidates_ids:
                   if candidate_id in ids: # Porównujemy tylko w ramach tej samej grupy hashowej
                        obj2 = id_to_feature[candidate_id]
                        if not obj1 in obiekty_z_bledami and obj1.geometry().distance(obj2.geometry()) < 0.01 and not obj1.geometry().equals(obj2.geometry()):
                            obiekty_z_bledami.append(obj1)
                            break
    
    return obiekty_z_bledami


def przewerteksowanie(layer):
    obiekty_z_bledami = []
    
    poziomice = processing.run("qgis:extractbyexpression", {
        'INPUT': layer,
        'EXPRESSION': '"rodzaj" = \'poziomica\'',
        'FAIL_OUTPUT': 'memory:',
        'OUTPUT': 'memory:'
    })
    
    simplifygeometries = processing.run("native:simplifygeometries", {
        'INPUT': poziomice['OUTPUT'],
        'METHOD': 0, # DP
        'TOLERANCE': 0.05, # 5 cm strzałki
        'OUTPUT': 'memory:'
        })
    
    roznica = processing.run("qgis:difference", {
        'INPUT': poziomice['OUTPUT'],
        'OVERLAY': simplifygeometries['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    pojedynczeObiekty = processing.run("native:multiparttosingleparts", {
        'INPUT': roznica['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    if pojedynczeObiekty['OUTPUT'].featureCount() > 0:
        for obj in pojedynczeObiekty['OUTPUT'].getFeatures():
            obiekty_z_bledami.append(obj)
    
    return obiekty_z_bledami


def przecieciaLiniiNapieciaPodziemna(layer):
    obiekty_z_bledami = []
    OT_SULN_L_layer = None
    OT_BUWT_P_layer = None
    if layer.name()[-6:] == 'SULN_L':
        OT_BUWT_P_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_SULN_L","OT_BUWT_P"))[0]
        OT_SULN_L_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    index = QgsSpatialIndex()
    identyfikatory_bledow = set() # Zbiór do śledzenia identyfikatorów błędnych obiektów w celu uniknięcia powieleń
    for feat in OT_BUWT_P_layer.getFeatures():
        index.insertFeature(feat) # Budowanie indeksu przestrzennego do szybszego przetworzenia
    for OT_SULN_L_feature in OT_SULN_L_layer.getFeatures():
        geom = OT_SULN_L_feature.geometry()
        all_points = [vertex for vertex in geom.vertices()]
        # Usuń pierwszy i ostatni punkt (wierzchołek)
        if len(all_points) <= 3:  # Pomiń linie z trzema lub dwoma wierzchołkami
            continue
        analysis_points = [QgsPointXY(vertex.x(), vertex.y()) for vertex in all_points[1:-1]]
        new_geom = QgsGeometry.fromPolylineXY(analysis_points)
        kodkarto = OT_SULN_L_feature['kodKarto10k']
        rodzaj = OT_SULN_L_feature['rodzaj']
        if kodkarto == '0010_444' and rodzaj in ['linia elektroenergetyczna najwyższego napięcia', 'linia elektroenergetyczna wysokiego napięcia']:
            ids = index.intersects(new_geom.boundingBox()) # intersekcja z obiektem
            intersects = False
            for id in ids:
                other_feat = OT_BUWT_P_layer.getFeature(id)
                if other_feat['rodzaj'] == 'słup energetyczny' and new_geom.intersects(other_feat.geometry()) and OT_SULN_L_feature.id() not in identyfikatory_bledow:
                    intersects = True
                    obiekty_z_bledami.append(OT_SULN_L_feature)
                    identyfikatory_bledow.add(OT_SULN_L_feature.id())
        if rodzaj == 'linia elektroenergetyczna średniego napięcia' and kodkarto != '0010_444':
                 obiekty_z_bledami.append(OT_SULN_L_feature)
                 identyfikatory_bledow.add(OT_SULN_L_feature.id())
    
    return obiekty_z_bledami


def przecieciaLiniiNapieciaNadziemna(layer):
    obiekty_z_bledami = []
    OT_SULN_L_layer = None
    OT_BUWT_P_layer = None
    if layer.name()[-6:] == 'SULN_L':
        OT_BUWT_P_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_SULN_L","OT_BUWT_P"))[0]
        OT_SULN_L_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    index = QgsSpatialIndex()
    identyfikatory_bledow = set() # Zbiór do śledzenia identyfikatorów błędnych obiektów w celu uniknięcia powieleń
    for feat in OT_BUWT_P_layer.getFeatures():
        index.insertFeature(feat) # Budowanie indeksu przestrzennego do szybszego przetworzenia
    for OT_SULN_L_feature in OT_SULN_L_layer.getFeatures():
        geom = OT_SULN_L_feature.geometry()
        all_points = [vertex for vertex in geom.vertices()]
        # Usuń pierwszy i ostatni punkt (wierzchołek)
        if len(all_points) <= 3:  # Pomiń linie z trzema lub dwoma wierzchołkami
            continue
        analysis_points = [QgsPointXY(vertex.x(), vertex.y()) for vertex in all_points[1:-1]]
        new_geom = QgsGeometry.fromPolylineXY(analysis_points)
        kodkarto = OT_SULN_L_feature['kodKarto10k']
        rodzaj = OT_SULN_L_feature['rodzaj']
        if kodkarto == '0010_446' and rodzaj in ['linia elektroenergetyczna najwyższego napięcia', 'linia elektroenergetyczna wysokiego napięcia']:
            ids = index.intersects(new_geom.boundingBox()) # intersekcja z obiektem
            intersects = False
            for id in ids:
                other_feat = OT_BUWT_P_layer.getFeature(id)
                if new_geom.intersects(other_feat.geometry()) and other_feat['rodzaj'] == 'słup energetyczny':
                    intersects = True
                    break
            if not intersects and OT_SULN_L_feature.id() not in identyfikatory_bledow:
                obiekty_z_bledami.append(OT_SULN_L_feature)
                identyfikatory_bledow.add(OT_SULN_L_feature.id())
    
    return obiekty_z_bledami


def kontrola_OT_ADMS_P_z_OT_ADMS_A(layer):
    obiekty_z_bledami = []
    OT_ADMS_A_layer = None
    OT_ADMS_P_layer = None
    if layer.name()[-6:] == 'ADMS_P':
        try:
            OT_ADMS_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_ADMS_P","OT_ADMS_A"))[0]
            OT_ADMS_P_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
        except:
            return obiekty_z_bledami
    if OT_ADMS_A_layer and OT_ADMS_P_layer:
        identyfikatory_bledow = set() # Zbiór do śledzenia identyfikatorów błędnych obiektów
        nazwy_adms_p = set([feature['nazwa'] for feature in OT_ADMS_P_layer.getFeatures()])
        nazwy_adms_a = set([feature['nazwa'] for feature in OT_ADMS_A_layer.getFeatures()])
        # Sprawdzenie przecięcia i nazw dla obiektów z OT_ADMS_A
        for OT_ADMS_A_feature in OT_ADMS_A_layer.getFeatures():
            is_intersected = False
            nazwa_adms_a = OT_ADMS_A_feature['nazwa']
            # Sprawdzenie przecięcia dla każdego obiektu z OT_ADMS_P
            for OT_ADMS_P_feature in OT_ADMS_P_layer.getFeatures():
                nazwa_adms_p = OT_ADMS_P_feature['nazwa']
                if OT_ADMS_P_feature.geometry().intersects(OT_ADMS_A_feature.geometry()) or OT_ADMS_A_feature.geometry().contains(OT_ADMS_P_feature.geometry()):
                    is_intersected = True
                    break
            if not is_intersected or nazwa_adms_a not in nazwy_adms_p: #... oraz czy nazwy z OT_ADMS_A występują w OT_ADMS_P
                if OT_ADMS_A_feature.id() not in identyfikatory_bledow:
                    obiekty_z_bledami.append(OT_ADMS_A_feature)
                    identyfikatory_bledow.add(OT_ADMS_A_feature.id())
            # Sprawdzenie, czy nazwy z OT_ADMS_P występują w OT_ADMS_A
            if OT_ADMS_P_feature['nazwa'] not in nazwy_adms_a and OT_ADMS_P_feature.id() not in identyfikatory_bledow:
                obiekty_z_bledami.append(OT_ADMS_P_feature)
                identyfikatory_bledow.add(OT_ADMS_P_feature.id())
    
    return obiekty_z_bledami


def kontrolaTERCpunkt(layer):
    obiektyZbledami = []
    adms = None
    adja = None
    if layer.name()[-6:] == 'ADMS_P':
        try:
            adja = QgsProject().instance().mapLayersByName(layer.name().replace("OT_ADMS_P","OT_ADJA_A"))[0]
            adms = QgsProject().instance().mapLayersByName(layer.name())[0]
        except:
            return obiektyZbledami 
    # Zestaw do śledzenia już dodanych identyfikatorów TERYT
    przetworzone_teryt = set()
    
    # Sprawdzenie, czy są warstwy
    if adms and adja:
        expression = """ "rodzaj" = 'gmina' """ 
        # Wykonaj selekcję
        adja.selectByExpression(expression, QgsVectorLayer.SetSelection)
        selected = adja.selectedFeatures()
        # Przygotuj listę identyfikatorów TERYT z warstwy ADJA jako tekst
        identyfikatory_teryt = {str(feature["identyfikatorTerytJednostki"]).zfill(7): feature for feature in selected}
        # Przygotuj słownik dla ADMS_P: klucz to IdentyfikatorTERC, wartość to lista nazw
        identyfikatory_terc_adms = {}
        for feature in adms.getFeatures():
           teryt_adms = str(feature["IdentyfikatorTERC"]).zfill(7)
           if teryt_adms in identyfikatory_terc_adms:
               identyfikatory_terc_adms[teryt_adms].append(feature)
           else:
               identyfikatory_terc_adms[teryt_adms] = [feature]
        # Dla każdego identyfikatora TERYT/TERC
        for teryt_adms, adms_features in identyfikatory_terc_adms.items():
           if teryt_adms not in identyfikatory_teryt:
               for adms_feature in adms_features:
                   obiektyZbledami.append(adms_feature)
        adja.removeSelection()
    
    return obiektyZbledami


def kontrolaTERCpowierzchnia(layer):
    obiektyZbledami = []
    adms = None
    adja = None
    if layer.name()[-6:] == 'ADMS_A':
        try:
            adja = QgsProject().instance().mapLayersByName(layer.name().replace("ADMS","ADJA"))[0]
            adms = QgsProject().instance().mapLayersByName(layer.name())[0]
        except:
            return obiektyZbledami
    # Zestaw do śledzenia już dodanych identyfikatorów TERYT
    przetworzone_teryt = set()
    
    # Sprawdzenie, czy jsą warstwy
    if adms and adja:
        # Iteruj przez warstwy
        expression = """ "rodzaj" = 'gmina' """ 
        # Wykonaj selekcję na ADJA_A
        adja.selectByExpression(expression, QgsVectorLayer.SetSelection)
        selected = adja.selectedFeatures()
        # Przygotuj listę identyfikatorów TERYT z warstwy ADJA jako tekst
        identyfikatory_teryt = {str(feature["identyfikatorTerytJednostki"]).zfill(7): feature  for feature in selected}
        # Przygotuj słownik dla ADMS_A: klucz to IdentyfikatorTERC, wartość to lista nazw
        identyfikatory_terc_adms = {}
        for feature in adms.getFeatures():
            teryt_adms = str(feature["IdentyfikatorTERC"]).zfill(7)
            if teryt_adms in identyfikatory_terc_adms:
                identyfikatory_terc_adms[teryt_adms].append(feature)
            else:
                identyfikatory_terc_adms[teryt_adms] = [feature]
        #Sprawdzenie: kod TERYT w ADMS_A, ale nie w ADJA
        for teryt_adms, adms_features in identyfikatory_terc_adms.items():
           if teryt_adms not in identyfikatory_teryt:
               for adms_feature in adms_features:
                    obiektyZbledami.append(adms_feature)
        adja.removeSelection()
    
    return obiektyZbledami


def fullCoverage(layer):
    obiektyZbledami = []
    pokrycie = []
    wszystkieObiektyZPokrycia = QgsVectorLayer("Polygon?crs=epsg:2180", "Wszystkie obiekty z pokrycia", "memory")
    config = configparser.ConfigParser()
    mainPath = pathlib.Path(QgsApplication.qgisSettingsDirPath()) / "python/plugins/Walidator_plikow_gml"
    config.read(str(mainPath / "Walidator_plikow_gml.ini"))
    granicePowiatowPath = config['DEFAULT']['granicepowiatow']
    granicePowiatow = QgsVectorLayer(granicePowiatowPath, 'GranicePowiatow', 'ogr')
    
    granicePowiatow = processing.run("native:multiparttosingleparts", {
        'INPUT': granicePowiatow,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    match = re.search(r"\.(\d{4})__", layer.name())
    if not match:
        return []
    terytPowiatu = match.group(1)
    powiat_z_PRG = QgsVectorLayer("Polygon?crs=epsg:2180&field=gml_id:string(254)", "granica powiatu z PRG", "memory")
    adja_geom = None
    for obj in granicePowiatow.getFeatures():
        if str(obj['JPT_KOD_JE']) == str(terytPowiatu):
            powiat_z_PRG.dataProvider().addFeatures([obj])
            adja_geom = obj.geometry()
            break
    for lyr in QgsProject.instance().mapLayers().values():
        if "OT_PT" in lyr.name():
            pokrycie.append(lyr)
    for l in pokrycie:
        for feature in l.getFeatures():
            wszystkieObiektyZPokrycia.dataProvider().addFeatures([feature])
            
    # WALIDACJA GEOMETRII
    isvalid = processing.run("qgis:checkvalidity", {
        'INPUT_LAYER': wszystkieObiektyZPokrycia,
        'METHOD': 2,
        'IGNORE_RING_SELF_INTERSECTION': False,
        'VALID_OUTPUT': 'memory:',
        'INVALID_OUTPUT': 'memory:',
        'ERROR_OUTPUT': 'memory:'
    })
    
    if isvalid['INVALID_OUTPUT'].featureCount() > 0:
        isvalid['INVALID_OUTPUT'].setName("błędne geometrie obiektów pokrycia terenu")
        QgsProject.instance().addMapLayer(isvalid['INVALID_OUTPUT'])
    if isvalid['ERROR_OUTPUT'].featureCount() > 0:
        isvalid['ERROR_OUTPUT'].setName("lokalizacje błędów geometrii obiektów pokrycia terenu")
        QgsProject.instance().addMapLayer(isvalid['ERROR_OUTPUT'])
    valid = isvalid['VALID_OUTPUT']
    
    # NAKŁADANIA
    nakladanie = QgsVectorLayer("Polygon?crs=epsg:2180&field=gml_id:string(254)", "nakładania w pokryciu terenu", "memory")
    geom_union = set()
    union = processing.run("qgis:union", {
        'INPUT': valid,
        'OUTPUT': 'memory:'
    })
    index_layer = QgsSpatialIndex(layer.getFeatures())
    for f in union['OUTPUT'].getFeatures():
        g = f.geometry()
        if g.isEmpty():
            continue
        geom_hash = hash(g.asWkb())
        if geom_hash in geom_union:
            if g.area() > 0.009:
                nakladanie.dataProvider().addFeatures([f])
                point = g.centroid().asPoint()
                nearest_ids = index_layer.nearestNeighbor(point, 1)
                if nearest_ids:
                    nearest = layer.getFeature(nearest_ids[0])
                    if nearest.id() not in [o.id() for o in obiektyZbledami]:
                        obiektyZbledami.append(nearest)
        else:
            geom_union.add(geom_hash)
            
    if nakladanie.featureCount() > 0:
        nakladanie.setName("nakładania w pokryciu terenu")
        nakladanie.startEditing()
        for n in nakladanie.getFeatures():
            n.setAttribute(0, 'nie dotyczy')
            nakladanie.updateFeature(n)
        nakladanie.commitChanges()
        QgsProject.instance().addMapLayer(nakladanie)
        
    # DZIURY
    dziury = QgsVectorLayer("Polygon?crs=epsg:2180&field=gml_id:string(254)", "dziury w pokryciu terenu", "memory")
    buforMinus1cm = processing.run("native:buffer", {
        'INPUT': powiat_z_PRG,
        'DISTANCE': -0.01,
        'SEGMENTS': 10,
        'DISSOLVE': True,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    roznica = processing.run("qgis:difference", {
        'INPUT': buforMinus1cm,
        'OVERLAY': valid,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    pojedynczeDziury = processing.run("native:multiparttosingleparts", {
        'INPUT': roznica,
        'OUTPUT': 'memory:'
    })['OUTPUT']

    dziury.startEditing()
    spatial_index_layer = QgsSpatialIndex(layer.getFeatures())
    for n in pojedynczeDziury.getFeatures():
        if n.geometry().area() > 0.009:
            
            nowy = QgsFeature(dziury.fields())
            nowy.setGeometry(n.geometry())
            nowy.setAttribute(0, 'nie dotyczy')
            dziury.addFeature(nowy)
            obiektyZbledami.append(nowy)
            
            rect = n.geometry().boundingBox()
            ids = spatial_index_layer.intersects(rect)
            for fid in ids:
                f = layer.getFeature(fid)
                if f.geometry().intersects(n.geometry()):
                    if f.id() not in [o.id() for o in obiektyZbledami]:
                        obiektyZbledami.append(f)
                    break
    dziury.commitChanges()
    if dziury.featureCount() > 0:
        QgsProject.instance().addMapLayer(dziury)
        
    # NIESPÓJNOŚCI WERTEKSÓW
    niespojnosci = QgsVectorLayer("Point?crs=epsg:2180&field=gml_id:string(254)", "niespójność werteksów", "memory")
    pr = niespojnosci.dataProvider()
    geometrie_dict = {}
    licznik_wierzcholkow = defaultdict(set)
    index = QgsSpatialIndex()
    for f in valid.getFeatures():
        fid = f.id()
        geometrie_dict[fid] = f
        index.insertFeature(f)
        geom = f.geometry()
        for v in geom.vertices():
            xy = (round(v.x(), 2), round(v.y(), 2))
            licznik_wierzcholkow[xy].add(fid)
            
    tolerancja = 0.01
    for xy, ids in licznik_wierzcholkow.items():
        if len(ids) != 1:
            continue
        fid = list(ids)[0]
        geom1 = geometrie_dict[fid].geometry()
        pt = QgsPointXY(*xy)
        geom_pt = QgsGeometry.fromPointXY(pt)
        candidates = index.intersects(geom1.boundingBox())
        for cid in candidates:
            if cid == fid:
                continue
            geom2 = geometrie_dict[cid].geometry()
            if geom2.touches(geom_pt):
                if any(QgsPointXY(round(p.x(), 2), round(p.y(), 2)).distance(pt) < tolerancja for p in geom2.vertices()):
                    continue
                feat = QgsFeature(niespojnosci.fields())
                feat.setGeometry(geom_pt)
                feat.setAttribute(0, 'nie dotyczy')
                pr.addFeature(feat)
                for f_layer in layer.getFeatures(QgsFeatureRequest().setFilterRect(geom_pt.boundingBox())):
                    if f_layer.geometry().intersects(geom_pt):
                        if f_layer.id() not in [o.id() for o in obiektyZbledami]:
                            obiektyZbledami.append(f_layer)
                        break
    if niespojnosci.featureCount() > 0:
        QgsProject.instance().addMapLayer(niespojnosci)
    for niesp in niespojnosci.getFeatures():
        if niesp.id() not in [o.id() for o in obiektyZbledami]:
            obiektyZbledami.append(niesp)
            
    return obiektyZbledami


def jednostkaEwidencyjnaFullCoverage(layer):
    obiektyZbledami = []
    wszystkieJednostkiEwidencyjne = QgsVectorLayer("Polygon?crs=epsg:" + str(4326), "Wszystkie jednostki ewidencyjne", "memory")
    warstwy = []
    for layer_id, lyr in QgsProject.instance().mapLayers().items():
        if lyr.name().__contains__("EGB_JednostkaEwidencyjna"):
            reprojectlayer = processing.run("native:reprojectlayer", {
                'INPUT': lyr,
                'TARGET_CRS':QgsCoordinateReferenceSystem('EPSG:4326'),
                'OUTPUT': 'memory:'
            })
            warstwy.append(reprojectlayer['OUTPUT'])
    
    for l in warstwy:
        for feature in l.getFeatures():
            wszystkieJednostkiEwidencyjne.dataProvider().addFeatures([feature])
    
    # Iteracja przez każdą parę warstw do sprawdzenia pokryć
    if not QgsProject.instance().mapLayersByName("nakładania w pokryciu jednostek ewidencyjnych") and not QgsProject.instance().mapLayersByName("dziury w pokryciu jednostek ewidencyjnych"):
        nakladanie = QgsVectorLayer("Polygon?crs=epsg:4326&field=gml_id:string(254)", "nakładania w pokryciu jednostek ewidencyjnych", "memory")
        dziury = QgsVectorLayer("Polygon?crs=epsg:4326&field=gml_id:string(254)", "dziury pomiędzy jednostkami ewidencyjnymi", "memory")
        
        isvalid_wszystkieObiektyZPokrycia = processing.run("qgis:checkvalidity", {
            'INPUT_LAYER': wszystkieJednostkiEwidencyjne,
            'METHOD': 2,
            'IGNORE_RING_SELF_INTERSECTION': False,
            'VALID_OUTPUT': 'memory:',
            'INVALID_OUTPUT': 'memory:',
            'ERROR_OUTPUT': 'memory:'
        })
        
        if isvalid_wszystkieObiektyZPokrycia['INVALID_OUTPUT'].featureCount() > 0:
            isvalid_wszystkieObiektyZPokrycia['INVALID_OUTPUT'].setName("błędne geometrie obiektów jednostek ewidencyjnych")
            QgsProject.instance().addMapLayer(isvalid_wszystkieObiektyZPokrycia['INVALID_OUTPUT'])
        
        if isvalid_wszystkieObiektyZPokrycia['ERROR_OUTPUT'].featureCount() > 0:
            isvalid_wszystkieObiektyZPokrycia['ERROR_OUTPUT'].setName("lokalizacje błędów geometrii obiektów jednostek ewidencyjnych")
            QgsProject.instance().addMapLayer(isvalid_wszystkieObiektyZPokrycia['ERROR_OUTPUT'])
        
        union = processing.run("qgis:union", {
            'INPUT': isvalid_wszystkieObiektyZPokrycia['VALID_OUTPUT'],
            'OUTPUT': 'memory:'
        })
        
        pojedynczeNakladania = processing.run("native:multiparttosingleparts", {
            'INPUT': union['OUTPUT'],
            'OUTPUT': 'memory:'
        })
        
        geom_union = []
        for f in pojedynczeNakladania['OUTPUT'].getFeatures():
            g = f.geometry()
            geom_wkt = g.asWkt()
            if not geom_wkt in geom_union:
                geom_union.append(geom_wkt)
            else:
                nakladanie.dataProvider().addFeatures([f])
        
        if nakladanie.featureCount() > 0:
            nakladanie.startEditing()
            for n in nakladanie.getFeatures():
                n.setAttribute(0,'nie dotyczy')
                nakladanie.updateFeature(n)
                obiektyZbledami.append(n)
            nakladanie.commitChanges()
            QgsProject.instance().addMapLayer(nakladanie)
        
        dissolve = processing.run("qgis:dissolve", {
            'INPUT': isvalid_wszystkieObiektyZPokrycia['VALID_OUTPUT'],
            'FIELD': [],
            'OUTPUT': 'memory:'
        })
        
        deleteholes = processing.run("native:deleteholes", {
            'INPUT': dissolve['OUTPUT'],
            'OUTPUT': 'memory:'
        })
        
        roznica = processing.run("qgis:difference", {
            'INPUT': deleteholes['OUTPUT'],
            'OVERLAY': dissolve['OUTPUT'],
            'OUTPUT': 'memory:'
        })
        
        multiparttosingleparts = processing.run("qgis:multiparttosingleparts", {
            'INPUT': roznica['OUTPUT'],
            'OUTPUT': 'memory:'
        })
        
        if not QgsProject.instance().mapLayersByName("dziury pomiędzy jednostkami ewidencyjnymi"):
            dziury.startEditing()
            for n in multiparttosingleparts['OUTPUT'].getFeatures():
                if n.geometry().area() > 0: # 0- bez tolerancji
                    nowyRekord = QgsFeature(dziury.fields())
                    nowyRekord.setAttribute(0,'nie dotyczy')
                    nowyRekord.setGeometry(n.geometry())
                    dziury.addFeature(nowyRekord)
                    obiektyZbledami.append(nowyRekord)
            dziury.commitChanges()
            
            if dziury.featureCount() > 0:
                QgsProject.instance().addMapLayer(dziury)
    
    return obiektyZbledami


def boundaryPTWP(layer):
    try:
        obiektyZbledami = []
        ptwp = None
        if layer.name().__contains__('RTLW_L'):
            ptwp = QgsProject().instance().mapLayersByName(layer.name().replace("RTLW_L","PTWP_A"))[0]
        if ptwp:
            # bufor -0.02 m
            bufor = processing.run("native:buffer", {
                'INPUT': ptwp,
                'DISTANCE': -0.02,
                'SEGMENTS': 10,
                'DISSOLVE': True,
                'OUTPUT': 'memory:'
            })
            
            pojedynczePTWP = processing.run("native:multiparttosingleparts", {
                'INPUT': bufor['OUTPUT'],
                'OUTPUT': 'memory:'
            })
            
            extractbyexpression = processing.run("qgis:extractbyexpression", {
                'INPUT': layer,
                'EXPRESSION': '"rodzaj" in (\'skarpa\',\'wąwóz\')',
                'FAIL_OUTPUT': 'memory:',
                'OUTPUT': 'memory:'
            })
            
            extractbylocation = processing.run("native:extractbylocation", {
                'INPUT': extractbyexpression['OUTPUT'],
                'INTERSECT': pojedynczePTWP['OUTPUT'],
                'PREDICATE': [0],
                'OUTPUT': 'memory:'
            })
            
            if extractbylocation['OUTPUT'].featureCount() > 0:
                for obj in extractbylocation['OUTPUT'].getFeatures():
                    obiektyZbledami.append(obj)
    except Exception as e:
        print ("błąd w funkcji boundaryPTWP:", e)
    
    return obiektyZbledami


def boundaryPTWP_poziomica(layer):
    obiektyZbledami = []
    try:
        ptwp = None
        if layer.name().__contains__('RTLW_L'):
            ptwp = QgsProject().instance().mapLayersByName(layer.name().replace("RTLW_L","PTWP_A"))[0]
        if ptwp:
            # bufor -0.04 m
            bufor = processing.run("native:buffer", {
                'INPUT': ptwp,
                'DISTANCE': -0.04,
                'SEGMENTS': 10,
                'DISSOLVE': True,
                'OUTPUT': 'memory:'
            })
        
            pojedynczePTWP = processing.run("native:multiparttosingleparts", {
                'INPUT': bufor['OUTPUT'],
                'OUTPUT': 'memory:'
            })
        
            extractbyexpression = processing.run("qgis:extractbyexpression", {
                'INPUT': layer,
                'EXPRESSION': '"rodzaj" in (\'poziomica\') and "kodKarto10k" != \'\'',
                'FAIL_OUTPUT': 'memory:',
                'OUTPUT': 'memory:'
            })
        
            extractbylocation = processing.run("native:extractbylocation", {
                'INPUT': extractbyexpression['OUTPUT'],
                'INTERSECT': pojedynczePTWP['OUTPUT'],
                'PREDICATE': [0],
                'OUTPUT': 'memory:'
            })
        
            if extractbylocation['OUTPUT'].featureCount() > 0:
                for obj in extractbylocation['OUTPUT'].getFeatures():
                    obiektyZbledami.append(obj)
    except Exception as e:
        print ("błąd w funkcji boundaryPTWP_poziomica:", e)
    return obiektyZbledami


def kontrolaZdublowaniaAtrybutuFunkcjaSzczegolowaBudynku(layer):
    obiektyZbledami = []
    idenBledow = set()
    for feature in layer.getFeatures():
        funkcje_szczegolowe = feature['funkcjaSzczegolowaBudynku'] 
        if isinstance(funkcje_szczegolowe, list):
           wystapienia = {}
           for funkcja in funkcje_szczegolowe:
                if funkcja in wystapienia:
                    wystapienia[funkcja] += 1
                else:
                    wystapienia[funkcja] = 1
            # Sprawdzenie, czy występują powtórzenia (wartość większa niż 1)
           powtorzenia = [key for key, count in wystapienia.items() if count > 1]
           if powtorzenia and feature.id() not in idenBledow:
                obiektyZbledami.append(feature)
                idenBledow.add(feature.id())
    return obiektyZbledami


def kontrolaZgodnosciFunkcjaSzczegolowaBudynkuZprzewazajacaFunkcjaBudynku(layer):
    obiektyZbledami = []
    idenBledow = set()
    
    for feature in layer.getFeatures():
        if "funkcjaSzczegolowaBudynku" not in feature.fields().names() or "przewazajacaFunkcjaBudynku" not in feature.fields().names():
            continue
        
        funkcje_szczegolowe = feature.attribute("funkcjaSzczegolowaBudynku")
        funkcja_przewazajaca = feature.attribute("przewazajacaFunkcjaBudynku")
        
        if not funkcje_szczegolowe or not funkcja_przewazajaca:
            continue
            
        if not isinstance(funkcje_szczegolowe, (list, set)):
            funkcje_szczegolowe = {funkcje_szczegolowe}
        else:
            funkcje_szczegolowe = set(funkcje_szczegolowe)
            
        if funkcja_przewazajaca not in funkcje_szczegolowe:
            if feature.id() not in idenBledow:
                obiektyZbledami.append(feature)
                idenBledow.add(feature.id())
                
    return obiektyZbledami


def KontrolaAtrybutuGeometriaBudynek(layer, plikGML):
    obiektyZbledami = []
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'egb': 'ewidencjaGruntowIBudynkow:1.0'}
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces = ns):
        budynek = featureMember.find('.//egb:EGB_ObiektTrwaleZwiazanyZBudynkiem', namespaces=ns)
        if budynek is not None:
            rodzajObiektu = budynek.find('.//egb:rodzajObiektuZwiazanegoZBudynkiem', namespaces=ns)
            rodzajObiektu_text = rodzajObiektu.text if rodzajObiektu is not None else "Nieznane ID"
            if rodzajObiektu_text in ['t', 'w', 'i','s','r','j','d']:
                lokalnyId = budynek.find('.//egb:lokalnyId', namespaces=ns)
                lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
                geometria = budynek.findall('.//egb:geometria', namespaces=ns)
                for g in geometria:
                    polygon = g.find('.//gml:Polygon', namespaces=ns)
                    surface = g.find('.//gml:Surface', namespaces=ns)
                    if polygon is None and surface in None:
                        expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
                        request = QgsFeatureRequest().setFilterExpression(expression)
                        for feature in layer.getFeatures(request):
                           obiektyZbledami.append(feature)
                           
    return obiektyZbledami


def KontrolaAtrybutuKlasouzytek(layer, plikGML):
    obiektyZbledami = []
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'egb': 'ewidencjaGruntowIBudynkow:1.0'}
    
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces = ns):
        dzialka = featureMember.find('.//egb:EGB_DzialkaEwidencyjna', namespaces = ns)
        if dzialka is not None:
           # Dla każdego Klasouzytek w obrębie Działki Ewidencyjnej
           for klasouzytek in dzialka.findall('.//egb:EGB_Klasouzytek', namespaces = ns):
               lokalnyId = dzialka.find('.//egb:lokalnyId', namespaces=ns)
               lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
               OFU = klasouzytek.find('.//egb:OFU', namespaces=ns)
               ofu_value = OFU.text if OFU is not None else None
               if ofu_value in ['Ls', 'W']:
                   OZU = klasouzytek.find('.//egb:OZU', namespaces=ns)
                   ozu_value = OZU.text if OZU is not None else None
                   if ozu_value == 'Ls':
                       OZK = klasouzytek.find('.//egb:OZK', namespaces=ns)
                       ozk_value = OZK.text if OZK is not None else None
                       if ozk_value in ['IIIa', 'IIIb', 'IVa', 'IVb']:
                           expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
                           request = QgsFeatureRequest().setFilterExpression(expression)
                           for feature in layer.getFeatures(request):
                               obiektyZbledami.append(feature)
    
    return obiektyZbledami


def KontrolaAtrybutuKlasouzytek6(layer, plikGML):
    obiektyZbledami = []
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'egb': 'ewidencjaGruntowIBudynkow:1.0'}
    
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces = ns):
        dzialka = featureMember.find('.//egb:EGB_DzialkaEwidencyjna', namespaces = ns)
        if dzialka is not None:
           # Dla każdego Klasouzytek w obrębie Działki Ewidencyjnej
           for klasouzytek in dzialka.findall('.//egb:EGB_Klasouzytek', namespaces = ns):
               lokalnyId = dzialka.find('.//egb:lokalnyId', namespaces=ns)
               lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
               OFU = klasouzytek.find('.//egb:OFU', namespaces=ns)
               ofu_value = OFU.text if OFU is not None else None
               if ofu_value in ['Lz', 'W']:
                   OZU = klasouzytek.find('.//egb:OZU', namespaces=ns)
                   ozu_value = OZU.text if OZU is not None else None
                   if ozu_value == 'Lz':
                       OZK = klasouzytek.find('.//egb:OZK', namespaces=ns)
                       ozk_value = OZK.text if OZK is not None else None
                       if ozk_value in ['IIIa', 'IIIb', 'IVa', 'IVb']:
                           expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
                           request = QgsFeatureRequest().setFilterExpression(expression)
                           for feature in layer.getFeatures(request):
                               obiektyZbledami.append(feature)
    
    return obiektyZbledami


def KontrolaAtrybutuKlasouzytek2(layer, plikGML):
    obiektyZbledami = []
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'egb': 'ewidencjaGruntowIBudynkow:1.0'}
    
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        dzialka = featureMember.find('.//egb:EGB_DzialkaEwidencyjna', namespaces=ns)
        if dzialka is not None:
           # Dla każdego Klasouzytek w obrębie Działki Ewidencyjnej
           for klasouzytek in dzialka.findall('.//egb:EGB_Klasouzytek', namespaces=ns):
               lokalnyId = dzialka.find('.//egb:lokalnyId', namespaces=ns)
               lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
               OFU = klasouzytek.find('.//egb:OFU', namespaces=ns)
               ofu_value = OFU.text if OFU is not None else None
               if ofu_value in ['R','S', 'Br','Wsr','W','Lzr']:
                   OZU = klasouzytek.find('.//egb:OZU', namespaces=ns)
                   ozu_value = OZU.text if OZU is not None else None
                   if ozu_value == 'R':
                       OZK = klasouzytek.find('.//egb:OZK', namespaces=ns)
                       ozk_value = OZK.text if OZK is not None else None
                       if not ozk_value in ['I','II','IIIa', 'IIIb', 'IVa', 'IVb','V','VI','VIz']:
                           expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
                           request = QgsFeatureRequest().setFilterExpression(expression)
                           for feature in layer.getFeatures(request):
                               obiektyZbledami.append(feature)
    
    return obiektyZbledami


def KontrolaAtrybutuKlasouzytek3(layer, plikGML):
    obiektyZbledami = []
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'egb': 'ewidencjaGruntowIBudynkow:1.0'}
    
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        dzialka = featureMember.find('.//egb:EGB_DzialkaEwidencyjna', namespaces=ns)
        if dzialka is not None:
           # Dla każdego Klasouzytek w obrębie Działki Ewidencyjnej
           for klasouzytek in dzialka.findall('.//egb:EGB_Klasouzytek', namespaces=ns):
               lokalnyId = dzialka.find('.//egb:lokalnyId', namespaces=ns)
               lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
               OFU = klasouzytek.find('.//egb:OFU', namespaces=ns)
               ofu_value = OFU.text if OFU is not None else None
               if ofu_value in ['Ł','S','Br','Wsr','W','Lzr']:
                   OZU = klasouzytek.find('.//egb:OZU', namespaces=ns)
                   ozu_value = OZU.text if OZU is not None else None
                   if ozu_value == 'Ł':
                       OZK = klasouzytek.find('.//egb:OZK', namespaces=ns)
                       ozk_value = OZK.text if OZK is not None else None
                       if not ozk_value in ['I','II','III', 'IV','V','VI']:
                           expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
                           request = QgsFeatureRequest().setFilterExpression(expression)
                           for feature in layer.getFeatures(request):
                               obiektyZbledami.append(feature)
    
    return obiektyZbledami


def KontrolaAtrybutuKlasouzytek4(layer, plikGML):
    obiektyZbledami = []
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'egb': 'ewidencjaGruntowIBudynkow:1.0'}
    
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        dzialka = featureMember.find('.//egb:EGB_DzialkaEwidencyjna', namespaces=ns)
        if dzialka is not None:
           # Dla każdego Klasouzytek w obrębie Działki Ewidencyjnej
           for klasouzytek in dzialka.findall('.//egb:EGB_Klasouzytek', namespaces=ns):
               lokalnyId = dzialka.find('.//egb:lokalnyId', namespaces=ns)
               lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
               OFU = klasouzytek.find('.//egb:OFU', namespaces=ns)
               ofu_value = OFU.text if OFU is not None else None
               if ofu_value in ['Ps','S','Br','Wsr','W','Lzr']:
                   OZU = klasouzytek.find('.//egb:OZU', namespaces=ns)
                   ozu_value = OZU.text if OZU is not None else None
                   if ozu_value == 'Ps':
                       OZK = klasouzytek.find('.//egb:OZK', namespaces=ns)
                       ozk_value = OZK.text if OZK is not None else None
                       if not ozk_value in ['I','II','III', 'IV','V','VI']:
                           expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
                           request = QgsFeatureRequest().setFilterExpression(expression)
                           for feature in layer.getFeatures(request):
                               obiektyZbledami.append(feature)
    
    return obiektyZbledami

def kontrolaGeometriaOtWody(layer, plikGML):
    obiektyZbledami = []
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'ot': 'bazaDanychObiektowTopograficznych500:1.0'}
    
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        ot_wody = featureMember.find('.//ot:OT_Wody', namespaces=ns)
        
        if ot_wody is not None:
            rodzajObiektu = ot_wody.find('.//ot:rodzajObiektu', namespaces=ns)
            rodzajObiektu_text = rodzajObiektu.text if rodzajObiektu is not None else "Nieznane ID"
            
            if rodzajObiektu_text in ['p','s','j','l','z','t','o']:
                ot_geometria =  ot_wody.findall('.//ot:geometria', namespaces=ns)
                lokalnyId = ot_wody.find('.//ot:lokalnyId', namespaces=ns)
                lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
                expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
                request = QgsFeatureRequest().setFilterExpression(expression)
                
                if not ot_geometria: # całkowity brak atrybutu
                    for feature in layer.getFeatures(request):
                        obiektyZbledami.append(feature)
                else: # obiekt posiada niepoprawną geometrię w atrybucie
                    
                    for g in ot_geometria:
                        # QgsMessageLog.logMessage(f"3.g:\t{g}", "Walidator", level=Qgis.Info)
                        isValid = False
                        validGeometry = ['Polygon', 'Surface'] # akceptowalna geometria
                        for vg in validGeometry:
                            if g.find(f'.//gml:{vg}', namespaces=ns) is not None:
                                isValid = True
                                break # wyjście jeśli znajdzie poprawny obiekt
                        if isValid: continue
                        request = QgsFeatureRequest().setFilterExpression(expression)
                        for feature in layer.getFeatures(request):
                            obiektyZbledami.append(feature)
    
    return obiektyZbledami


def kontrolaGeometriaOtWody2(layer, plikGML):
    obiektyZbledami = []
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'ot': 'bazaDanychObiektowTopograficznych500:1.0'}
    
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        ot_wody = featureMember.find('.//ot:OT_Wody', namespaces=ns)
        
        if ot_wody is not None:
            rodzajObiektu = ot_wody.find('.//ot:rodzajObiektu', namespaces=ns)
            rodzajObiektu_text = rodzajObiektu.text if rodzajObiektu is not None else "Nieznane ID"
            
            if rodzajObiektu_text in ['w','g']:
                ot_geometria =  ot_wody.findall('.//ot:geometria', namespaces=ns)
                lokalnyId = ot_wody.find('.//ot:lokalnyId', namespaces=ns)
                lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
                expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
                request = QgsFeatureRequest().setFilterExpression(expression)
                
                if not ot_geometria: # całkowity brak atrybutu
                    for feature in layer.getFeatures(request):
                        obiektyZbledami.append(feature)
                else: # obiekt posiada niepoprawną geometrię w atrybucie
                    for g in ot_geometria:
                        isValid = False
                        validGeometry = ['Polygon', 'Surface', 'MultiSurface'] # akceptowalna geometria
                        for vg in validGeometry:
                            if g.find(f'.//gml:{vg}', namespaces=ns) is not None:
                                isValid = True
                                break # wyjście jeśli znajdzie poprawny obiekt
                        if isValid: continue
                        request = QgsFeatureRequest().setFilterExpression(expression)
                        for feature in layer.getFeatures(request):
                            obiektyZbledami.append(feature)
    
    return obiektyZbledami


def KontrolaGeometriaSchody(layer, plikGML):
    obiektyZbledami = []
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'egb': 'ewidencjaGruntowIBudynkow:1.0'}
    
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        budynek = featureMember.find('.//egb:EGB_ObiektTrwaleZwiazanyZBudynkiem', namespaces=ns)
        if budynek is not None:
            rodzajObiektu = budynek.find('.//egb:rodzajObiektuZwiazanegoZBudynkiem', namespaces=ns)
            rodzajObiektu_text = rodzajObiektu.text if rodzajObiektu is not None else "Nieznane ID"
            if rodzajObiektu_text == 's': # tylko schody
                polKier =  budynek.findall('.//egb:poliliniaKierunkowa', namespaces=ns)
                lokalnyId = budynek.find('.//egb:lokalnyId', namespaces=ns)
                lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
                expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
                request = QgsFeatureRequest().setFilterExpression(expression)
                if not polKier: # całkowity brak atrybutu
                    for feature in layer.getFeatures(request):
                        obiektyZbledami.append(feature)
                else: # schody nie posiadają poprawnej lini kierunkowej
                    for pk in polKier:
                        posList = pk.find('.//gml:posList', namespaces=ns)
                        pos = pk.find('.//gml:pos', namespaces=ns)
                        if pos is not None: # punkt
                            pos_wsp = pos.text 
                            if pos_wsp is None:
                                for feature in layer.getFeatures(request):
                                    obiektyZbledami.append(feature)
                        if posList is not None: # linie i powierzchnie
                            posList_wsp = posList.text
                            if posList_wsp is None:
                                for feature in layer.getFeatures(request):
                                    obiektyZbledami.append(feature)
    
    return obiektyZbledami


def gminyCzyNakladajaSie(layer):
    obiektyZbledami = []
    
    gm = processing.run("qgis:extractbyexpression", {
        'INPUT':layer,
        'EXPRESSION':'"rodzaj" = \'gmina\'',
        'OUTPUT':'memory:'
    })
    gminy = gm['OUTPUT']
    
    invalid_layer = processing.run("qgis:checkvalidity", {
        'INPUT_LAYER': gminy,
        'METHOD': 0, 
        'IGNORE_RING_SELF_INTERSECTION': True,
        'VALID_OUTPUT': 'memory:',
        'INVALID_OUTPUT': 'memory:',
        'ERROR_OUTPUT': 'memory:'
    })
    
    # zawiera warstwę z niepoprawnymi geometriami
    if invalid_layer['INVALID_OUTPUT']:
              # Wykonanie naprawy geometrii
              naprawiona = processing.run("native:fixgeometries", {
                  'INPUT': gminy,
                  'OUTPUT': 'memory:'
              })
              gminy = naprawiona['OUTPUT']
    
    union = processing.run("qgis:union", {
        'INPUT': gminy,
        'OUTPUT': 'memory:'
    })
    
    multiparttosingleparts = processing.run("native:multiparttosingleparts", {
        'INPUT': union['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    geom_union = []
    for f in multiparttosingleparts['OUTPUT'].getFeatures():
        g = f.geometry()
        geom_wkt = g.asWkt()
        if not geom_wkt in geom_union:
            geom_union.append(geom_wkt)
        else:
            if f.geometry().area() > 2:
                obiektyZbledami.append(f)
    
    return obiektyZbledami


def miastoWiesCzyNakladajaSie(layer):
    obiektyZbledami = []
    
    extractbyexpression = processing.run("qgis:extractbyexpression",{
        'INPUT': layer,
        'EXPRESSION':'"rodzaj"=\'miasto\' or "rodzaj"=\'wieś\'',
        'OUTPUT':'memory:'})
    miastoWies = extractbyexpression['OUTPUT']
    miastoWies.setName("miasto_wies")
    
    checkvalidity = processing.run("qgis:checkvalidity",{
        'INPUT_LAYER': miastoWies,
        'METHOD': 0,
        'IGNORE_RING_SELF_INTERSECTION': True,
        'VALID_OUTPUT': 'memory:',
        'INVALID_OUTPUT': 'memory:',
        'ERROR_OUTPUT': 'memory:'
    })
    
    # zawiera warstwę z niepoprawnymi geometriami
    if checkvalidity['INVALID_OUTPUT']:
              # Wykonanie naprawy geometrii
              naprawiona = processing.run("native:fixgeometries", {
                  'INPUT': miastoWies,
                  'OUTPUT': 'memory:'
              })
              miastoWies = naprawiona['OUTPUT']
    
    union = processing.run("qgis:union", {
        'INPUT': miastoWies,
        'OUTPUT': 'memory:'
    })
    
    multiparttosingleparts = processing.run("native:multiparttosingleparts", {
        'INPUT': union['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    geom_union = []
    for f in multiparttosingleparts['OUTPUT'].getFeatures():
        g = f.geometry()
        geom_wkt = g.asWkt()
        if not geom_wkt in geom_union:
            geom_union.append(geom_wkt)
        else:
            if f.geometry().area() > 2:
                obiektyZbledami.append(f)
    
    return obiektyZbledami


def sprawdzLokalnyId(layer):
    obiektyZbledami = []
    if layer.name()[-6:] in ['RTLW_L', 'RTPW_P']:
        return obiektyZbledami
    uuid_pattern = re.compile(r'^[A-Za-z0-9]{8}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{12}$')
    unique_ids = set()
    for f in layer.getFeatures():
        lokalny = f.attribute('lokalnyId')
        try:
            lokalny_str = str(lokalny)
        except Exception:
            obiektyZbledami.append(f)
            continue
        if not uuid_pattern.match(lokalny_str):
            obiektyZbledami.append(f)
            continue
        if lokalny_str in unique_ids:
            obiektyZbledami.append(f)
        else:
            unique_ids.add(lokalny_str)
    return obiektyZbledami


def sprawdzPrzestrzenNazw(layer):
    obiektyZbledami = []
    if layer.name()[-6:] in ['RTLW_L', 'RTPW_P']:
        return obiektyZbledami
        
    dozwolone_kody = {
        '02': '337',  # dolnośląskie
        '04': '994',  # kujawsko-pomrskie
        '06': '3700', # lubelskie
        '26': '370',  # świętokrzyskie
        '08': '333',  # lubuskie
        '10': '340',  # łódzkie
        '12': '283',  # małopolskie
        '14': '330',  # mazowieckie
        '16': '1833', # opolskie
        '18': '332',  # podlaskie
        '20': '335',  # podkarpackie
        '22': '336',  # pomorskie
        '24': '238',  # śląskie
        '28': '341',  # warmińsko-mazurskie
        '30': '308',  # wielkopolskie
        '32': '339'   # zachodniopomorskie
    }
    pattern = re.compile(r'^PL\.PZGiK\.(\d{3,4})\.BDOT10k$')
    for f in layer.getFeatures():
        przestrzen = f.attribute('przestrzenNazw')
        try:
            przestrzen_str = str(przestrzen)
        except Exception:
            obiektyZbledami.append(f)
            continue
        match = pattern.match(przestrzen_str)
        if not match:
            obiektyZbledami.append(f)
            continue
        woj = layer.name()[13:15]
        if woj in ['.1', '.0']:
            woj = layer.name()[14:16]
        cyfry = match.group(1) if match.group(1) else None
        expected_cyfry = dozwolone_kody.get(woj, None)
        
        valid = cyfry == expected_cyfry if expected_cyfry else False
        if not valid:
            obiektyZbledami.append(f)
            
    return obiektyZbledami


def sprawdzWersja(layer):
    obiektyZbledami = []
    if layer.name()[-6:] in ['RTLW_L', 'RTPW_P']:
        # funkcja nie wykona się dla warstw z rzeźbą terenu
        return obiektyZbledami
    uuid_pattern = re.compile(r'^[0-9]{4}-[01][0-9]-[0-3][0-9]T[0-2][0-9]:[0-5][0-9]:[0-5][0-9]$|^$')
    # Zbiór do sprawdzania unikalności
    unique_ids = set()
    for f in layer.getFeatures():
        wersja = f.attribute('wersja')
        matches_pattern = bool(uuid_pattern.match(wersja))
        if not isinstance(wersja, str):
            wersja = str(wersja) # konwersja pustej wartosci na string
        is_unique = wersja not in unique_ids
        if is_unique and not matches_pattern:
            unique_ids.add(wersja)
            obiektyZbledami.append(f)
    
    return obiektyZbledami


def sprawdzPoczatekWersjiObiektu(layer):
    obiektyZbledami = []
    if layer.name()[-6:] in ['RTLW_L', 'RTPW_P']:
        # funkcja nie wykona się dla warstw z rzeźbą terenu
        return obiektyZbledami
    uuid_pattern = re.compile(r'^[0-9]{4}-[01][0-9]-[0-3][0-9]T[0-2][0-9]:[0-5][0-9]:[0-5][0-9]$')
    # Zbiór do sprawdzania unikalności
    unique_ids = set()
    for f in layer.getFeatures():
        poczatek = f.attribute('poczatekWersjiObiektu')
        wersja = f.attribute('wersja')
        if not isinstance(wersja, str):
            wersja = str(wersja)
        if not isinstance(poczatek, str):
            poczatek = str(poczatek) # konwersja pustej wartosci na string
        if wersja != poczatek and f.id() not in unique_ids:
             unique_ids.add(f.id())
             obiektyZbledami.append(f)
        if not uuid_pattern.match(wersja) and f.id() not in unique_ids:
             unique_ids.add(f.id())
             obiektyZbledami.append(f)
        if not uuid_pattern.match(poczatek) and f.id() not in unique_ids:
             unique_ids.add(f.id())
             obiektyZbledami.append(f)
    
    return obiektyZbledami


def przestrzenNazw(layer,teryt):
    obiektyZbledami = []
    slownik = {
    '02': '337',  # dolnośląskie
    '04': '994',  # kujawsko-pomrskie
    '06': '3700', # lubelskie
    '08': '333',  # lubuskie
    '10': '340',  # łódzkie
    '12': '283',  # małopolskie
    '14': '330',  # mazowieckie
    '16': '1833', # opolskie
    '18': '332',  # podlaskie
    '20': '335',  # podkarpackie
    '22': '336',  # pomorskie
    '24': '238',  # śląskie
    '26': '370',  # świętokrzyskie
    '28': '341',  # warmińsko-mazurskie
    '30': '308',  # wielkopolskie
    '32': '339'   # zachodniopomorskie
    }
    pattern = re.compile(r'^PL\.PZGiK\.(\d{3,4})\.BDOT10k$')
    # Zbiór do sprawdzania unikalności
    unique_ids = set()
    for f in layer.getFeatures():
        przestrzen = f.attribute('przestrzenNazw')
        if not isinstance(przestrzen, str):
            przestrzen = str(przestrzen) # konwersja pustej wartosci na string
            obiektyZbledami.append(f)
        else:
            match = pattern.match(przestrzen)
            if not match: # sprawdza, czy są niezgodne z schematem
                match = pattern.match(przestrzen)
                obiektyZbledami.append(f)
            else:
                woj = teryt[:2]
                cyfry = match.group(1) if match.group(1) else None
                expected_cyfry = slownik.get(woj, None)
                if isinstance(expected_cyfry, list):
                    valid = cyfry in expected_cyfry
                else:
                    valid = cyfry == expected_cyfry
                if not valid:
                    obiektyZbledami.append(f)
    
    return obiektyZbledami


def zapisWspolrzednych(layer, plikGML):
    obiektyZbledami = []
    plikGML = plikGML.getroot()
    ns = {
        'gml': 'http://www.opengis.net/gml/3.2',
        'ot': 'urn:gugik:specyfikacje:gmlas:bazaDanychObiektowTopograficznych10k:2.0'
    }
    otklasa = f'.//ot:{layer.name()[-9:]}'
    lokalnyId_to_feature = {f["lokalnyId"]: f for f in layer.getFeatures()}
    wsp_pattern = re.compile(r'^[1-9][0-9]{5}\.[0-9]{2}$')
    
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        matches = featureMember.find(otklasa, namespaces=ns)
        if matches is None:
            continue
        lokalnyId_elem = matches.find('.//ot:lokalnyId', namespaces=ns)
        lokalnyId_text = lokalnyId_elem.text.strip() if lokalnyId_elem is not None else "Nieznane ID"
        feature = lokalnyId_to_feature.get(lokalnyId_text)
        if not feature:
            continue
        geometrie = matches.findall('.//ot:geometria', namespaces=ns)
        for g in geometrie:
            geom = g.find('.//gml:posList', namespaces=ns)
            geomPkt = g.find('.//gml:pos', namespaces=ns)
            if geom is not None:
                wsp_str = geom.text
                wsp_list = wsp_str.split()
                if len(wsp_list) % 2 != 0:
                    obiektyZbledami.append(feature)
                    continue
                num_pairs = len(wsp_list) // 2
                if num_pairs < 1:
                    obiektyZbledami.append(feature)
                    continue
                elif num_pairs == 1:
                    obiektyZbledami.append(feature)
                    continue
                elif num_pairs < 3 and g.find('.//gml:Polygon', namespaces=ns) is not None:
                    obiektyZbledami.append(feature)
                    continue
                if any(not wsp_pattern.match(coord) for coord in wsp_list):
                    obiektyZbledami.append(feature)
                    continue
            elif geomPkt is not None:
                wsp_str = geomPkt.text
                wsp_list = wsp_str.split()
                if len(wsp_list) != 2:
                    obiektyZbledami.append(feature)
                    continue
                if any(not wsp_pattern.match(coord) for coord in wsp_list):
                    obiektyZbledami.append(feature)
                    continue
    return obiektyZbledami


def minDlugoscOIPR(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'OIPR_L':
        OIPR_L_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    granica = adjaMinus2cmBufor(layer)
    for OIPR_L_feature in OIPR_L_layer.getFeatures():
        geom = OIPR_L_feature.geometry()
        if geom.length() < 40 and OIPR_L_feature['rodzaj'] in ['rząd drzew','pas krzewów lub żywopłot']:
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(OIPR_L_feature)
    
    return obiektyZbledami


def minDlugoscBUUO(layer):
    try:
        if not layer.isValid():
            return []
        obiektyZbledami = []
        layer_name = layer.name()
        if not layer_name.endswith("BUUO_L"):
            return []
        BUUO_L_layers = QgsProject.instance().mapLayersByName(layer_name)
        if not BUUO_L_layers:
            return []
        BUUO_L_layer = BUUO_L_layers[0]
        buuo_features = list(BUUO_L_layer.getFeatures())
        granica = adjaMinus2cmBufor(layer)
        if granica is None or not granica.isValid():
            return []
        granica_geoms = [g.geometry() for g in granica.getFeatures()]
        for feat in buuo_features:
            geom = feat.geometry()
            if geom is None or geom.isEmpty():
                continue
            if geom.length() < 10 and feat['rodzaj'] in ['falochron', 'ostroga']:
                styka_z_granica = any(geom.intersects(g) or geom.crosses(g) for g in granica_geoms)
                if not styka_z_granica:
                    obiektyZbledami.append(feat)
        return obiektyZbledami
    except Exception as e:
        print(f"Błąd w minDlugoscBUUO: {e}")
        return []


def minDlugoscSUPRnaKUPG(layer):
    try:
        if not layer.isValid():
            return []
        obiektyZbledami = []
        layer_name = layer.name()
        if not layer_name.endswith("SUPR_L"):
            return []
        kupg_name = layer_name.replace("OT_SUPR_L", "OT_KUPG_A")
        supr_layers = QgsProject.instance().mapLayersByName(layer_name)
        kupg_layers = QgsProject.instance().mapLayersByName(kupg_name)
        if not supr_layers or not kupg_layers:
            return []
        SUPR_L_layer = supr_layers[0]
        KUPG_A_layer = kupg_layers[0]
        supr_features = list(SUPR_L_layer.getFeatures())
        kupg_features = list(KUPG_A_layer.getFeatures())
        granica = adjaMinus2cmBufor(layer)
        if granica is None or not granica.isValid():
            return []
        granica_geoms = [g.geometry() for g in granica.getFeatures()]
        kupg_geoms = [f.geometry() for f in kupg_features]
        for feat in supr_features:
            geom = feat.geometry()
            if geom is None or geom.isEmpty():
                continue
            if geom.length() < 100:
                styka_z_granica = any(geom.intersects(g) or geom.crosses(g) for g in granica_geoms)
                if styka_z_granica:
                    continue
                styka_z_kupg = any(geom.intersects(k) or geom.crosses(k) for k in kupg_geoms)
                if not styka_z_kupg:
                    continue
                styka_z_innym_SUPR = any(
                    feat.id() != f.id() and (geom.intersects(f.geometry()) or geom.crosses(f.geometry()))
                    for f in supr_features
                )
                if styka_z_innym_SUPR:
                    continue
                obiektyZbledami.append(feat)
        return obiektyZbledami
    except Exception as e:
        print(f"Błąd w minDlugoscSUPRnaKUPG: {e}")
        return []


def kontrolaZgodnosciIdentyfikatoraUlicyZNazwa(layer, plikcsv_ulic, plikcsv_simc):
    obiektyZbledami = []
    global loaded_csv_data_ulic, loaded_csv_data_simc
    
    loaded_csv_data_ulic = loaded_csv_data_ulic if 'loaded_csv_data_ulic' in globals() else None
    loaded_csv_data_simc = loaded_csv_data_simc if 'loaded_csv_data_simc' in globals() else None
    
    if loaded_csv_data_ulic is None:
        loaded_csv_data_ulic = pd.read_csv(plikcsv_ulic, sep=';', encoding='utf-8', dtype=str).apply(lambda x: x.str.strip() if x.dtype == "object" else x).fillna('NULL')
    
    if loaded_csv_data_simc is None:
        loaded_csv_data_simc = pd.read_csv(plikcsv_simc, sep=';', encoding='utf-8', dtype=str).apply(lambda x: x.str.strip() if x.dtype == "object" else x).fillna('NULL')
    
    sym_ul_set = set(loaded_csv_data_ulic['SYM_UL'].astype(str).values)
    sym_set = set(loaded_csv_data_simc['SYM'].astype(str).values)
    
    csv_map_ulic = {(str(row['SYM_UL'])): (str(row['CECHA']), str(row['NAZWA_1']), str(row['NAZWA_2'])) for _, row in loaded_csv_data_ulic.iterrows()}
    
    for f in layer.getFeatures():
        identyfikatorULIC = str(f.attribute('identyfikatorULIC')).strip() if 'identyfikatorULIC' in layer.fields().names() and f.attribute('identyfikatorULIC') is not None else 'NULL'
        identyfikatorSIMC = str(f.attribute('identyfikatorSIMC')).strip() if 'identyfikatorSIMC' in layer.fields().names() and f.attribute('identyfikatorSIMC') is not None else 'NULL'
        
        komunikaty_bledu = []
        if identyfikatorULIC == 'NULL' or identyfikatorSIMC == 'NULL':
            continue
        
        if identyfikatorULIC not in sym_ul_set:
            komunikaty_bledu.append(f"NIEZNALEZIONY identyfikatorULIC: {identyfikatorULIC}")
        if identyfikatorSIMC not in sym_set:
            komunikaty_bledu.append(f"NIEZNALEZIONY identyfikatorSIMC: {identyfikatorSIMC}")
        
        if 'OT_PTPL_A' in layer.name():
            nazwa1 = str(f.attribute('placNazwa1')).strip() if 'placNazwa1' in layer.fields().names() and f.attribute('placNazwa1') is not None else 'NULL'
            nazwa2 = str(f.attribute('placNazwa2')).strip() if 'placNazwa2' in layer.fields().names() and f.attribute('placNazwa2') is not None else 'NULL'
            cecha = str(f.attribute('placCecha')).strip() if 'placCecha' in layer.fields().names() and f.attribute('placCecha') is not None else 'NULL'
        else:
            nazwa1 = str(f.attribute('ulicaNazwa1')).strip() if 'ulicaNazwa1' in layer.fields().names() and f.attribute('ulicaNazwa1') is not None else 'NULL'
            nazwa2 = str(f.attribute('ulicaNazwa2')).strip() if 'ulicaNazwa2' in layer.fields().names() and f.attribute('ulicaNazwa2') is not None else 'NULL'
            cecha = str(f.attribute('ulicaCecha')).strip() if 'ulicaCecha' in layer.fields().names() and f.attribute('ulicaCecha') is not None else 'NULL'
        
        cecha_GUS, nazwa1_GUS, nazwa2_GUS = csv_map_ulic.get(identyfikatorULIC, ('NULL', 'NULL', 'NULL'))
        
        if cecha_GUS != cecha or nazwa1_GUS != nazwa1 or nazwa2_GUS != nazwa2:
            komunikaty_bledu.append(f"CECHA:{cecha_GUS},NAZWA_1:{nazwa1_GUS},NAZWA_2:{nazwa2_GUS}; ulicaCecha:{cecha},ulicaNazwa1:{nazwa1},ulicaNazwa2:{nazwa2}")
        
        if komunikaty_bledu:
            gml_id = str(f.attribute("gml_id")) if f.attribute("gml_id") is not None else 'NULL'
            gml_id = (gml_id + " | " if gml_id != 'NULL' else "") + " | ".join(komunikaty_bledu)
            f.setAttribute(layer.fields().indexFromName("gml_id"), gml_id)
            layer.updateFeature(f)
            obiektyZbledami.append(f)
    
    layer.commitChanges()
    return obiektyZbledami


def pyExpression(layer, sqltxt):
    obiektyZbledami = []
    
    def lexpression(layer, sqltxt):
        expression = QgsExpression(sqltxt)
        
        if expression.hasParserError():
            return f"Parser error: {expression.parserErrorString()}"
        
        if not expression.isValid():
            print("błąd w szablonie kontroli")
        
        # Tworzenie kontekstu wyrażenia
        context = QgsExpressionContext()
        context.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layer))
        
        # Iteracja przez wszystkie obiekty w kontekcie expression
        for feature in layer.getFeatures():
            context.setFeature(feature)
            expression.evaluate(context)
            
            if expression.hasEvalError():
                field_name = expression.evalErrorString().split("'")[1]
                layer.addExpressionField(field_name, QgsField(field_name, QVariant.String))
                
                # iteracyjnie dodaje brakujące pola do warstwy
                lexpression(layer, sqltxt)
                break
    
    lexpression(layer, sqltxt)
    
    request = QgsFeatureRequest(QgsExpression(sqltxt))
    requestFeatures = layer.getFeatures(request)
    for f in requestFeatures:
        obiektyZbledami.append(f)
    
    return obiektyZbledami


def mgrExpression(layer, gml, sqltxt):
    obiektyZbledami = []
    
    if not QgsProject.instance().mapLayersByName(layer.name() + "_dodane_pola"):
        newFields = ['numerPodloza','podloze','szkieletowosc','rodzajGlebyOrganicznej','miazszosc','gatunekMady','gatunekRedziny','informacjeDodatkowe']
        nowePola = []
        
        layer_dodane_pola = QgsVectorLayer('Polygon?crs=EPSG:2180', layer.name() + "_dodane_pola", 'memory')
        memory_provider = layer_dodane_pola.dataProvider()
        memory_provider.addAttributes(layer.fields())
        layer_dodane_pola.updateFields()
        
        for field in newFields:
            for n in [1,2,3,4,5]:
                newFieldName = field + str(n)
                nowePola.append(newFieldName)
                memory_provider.addAttributes([QgsField(newFieldName, QVariant.String)])
        
        for feature in layer.getFeatures():
            memory_provider.addFeature(feature)
        
        layer_dodane_pola.startEditing()
        ns = {'gml': 'http://www.opengis.net/gml/3.2', 'gr': 'urn:gugik:specyfikacje:gmlas:mapaGlebowoRolnicza:1.0'}
        konturyGlebowe = gml.getroot().findall('.//gr:GR_KonturGlebowy', namespaces=ns)
        for konturGlebowy in konturyGlebowe:
            lokalnyId = konturGlebowy.find('.//gr:lokalnyId', namespaces=ns).text
            expression = f"\"lokalnyId\" = '{lokalnyId}'"
            request = QgsFeatureRequest().setFilterExpression(expression)
            lyr_request = layer_dodane_pola.getFeatures(request)
            for feature in lyr_request:
                QCoreApplication.processEvents()
                opisyPodlozy = konturGlebowy.findall('.//gr:opisPodloza', namespaces=ns)
                for opisPodloza in opisyPodlozy:
                    numerPodloza = opisPodloza.find('.//gr:numerPodloza', namespaces=ns).text
                    for field in newFields:
                        value = opisPodloza.find('.//gr:' + field, namespaces=ns)
                        if value == None:
                            wartosc = NULL
                        else:
                            wartosc = value.text
                        feature.setAttribute(layer_dodane_pola.fields().indexFromName(field + numerPodloza), wartosc)
                layer_dodane_pola.updateFeature(feature)
        layer_dodane_pola.commitChanges()
        
        QgsProject.instance().addMapLayer(layer_dodane_pola)
    else:
        layer_dodane_pola = QgsProject.instance().mapLayersByName(layer.name() + "_dodane_pola")[0]
    
    request = QgsFeatureRequest(QgsExpression(sqltxt))
    requestFeatures = layer_dodane_pola.getFeatures(request)
    for f in requestFeatures:
        obiektyZbledami.append(f)
    
    return obiektyZbledami


def numerPodloza(layer, plikGML):
    obiektyZbledami = []
    idenBledow = set()
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'gr': 'urn:gugik:specyfikacje:gmlas:mapaGlebowoRolnicza:1.0'}
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        kontur = featureMember.find('.//gr:GR_KonturGlebowy', namespaces=ns)
        if kontur is not None:
            opisyPodloza =  kontur.findall('.//gr:opisPodloza', namespaces=ns)
            lokalnyId = kontur.find('.//gr:lokalnyId', namespaces=ns)
            lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
            for opisPodloza in opisyPodloza:
                nrPodloza = opisPodloza.find('.//gr:numerPodloza', namespaces=ns)
                nrPodloza_value = nrPodloza.text if nrPodloza is not None else None
                if nrPodloza_value not in ['1','2','3','4','5']:
                    if lokalnyId_text not in idenBledow:
                        expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
                        request = QgsFeatureRequest().setFilterExpression(expression)
                        for feature in layer.getFeatures(request):
                                obiektyZbledami.append(feature)
                        idenBledow.add(lokalnyId_text)
    return obiektyZbledami


def miazszoscPodloza(layer, plikGML):
    obiektyZbledami = []
    idenBledow = set()
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'gr': 'urn:gugik:specyfikacje:gmlas:mapaGlebowoRolnicza:1.0'}
    warunki = {
         '-': '2',
         '=': ['2', '3'],
         '.': '3',
         ':': '4',
        ':.': '5',
    }
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        kontur = featureMember.find('.//gr:GR_KonturGlebowy', namespaces=ns)
        if kontur is not None:
            opisyPodloza =  kontur.findall('.//gr:opisPodloza', namespaces=ns)
            lokalnyId = kontur.find('.//gr:lokalnyId', namespaces=ns)
            lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
            for opisPodloza in opisyPodloza:
                nrPodloza = opisPodloza.find('.//gr:numerPodloza', namespaces=ns)
                miazszosc = opisPodloza.find('.//gr:miazszosc', namespaces=ns)
                nrPodloza_value = nrPodloza.text if nrPodloza is not None else None
                miazszosc_value = miazszosc.text if miazszosc is not None else None
                # Iteracja przez warunki w słowniku
                znaleziono_warunek = False
                for miazszosc_key, nrPodloza_values in warunki.items():
                    if miazszosc_value == miazszosc_key:
                        if isinstance(nrPodloza_values, list):
                            for value in nrPodloza_values:
                                if nrPodloza_value != value:
                                    if lokalnyId_text not in idenBledow:
                                        expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
                                        request = QgsFeatureRequest().setFilterExpression(expression)
                                        for feature in layer.getFeatures(request):
                                            obiektyZbledami.append(feature)
                                        idenBledow.add(lokalnyId_text)
                        else:
                            if nrPodloza_value != nrPodloza_values:
                                # Jeśli spełnia warunek, dodaj do obiektyZbledami
                                if lokalnyId_text not in idenBledow:
                                    expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
                                    request = QgsFeatureRequest().setFilterExpression(expression)
                                    for feature in layer.getFeatures(request):
                                        obiektyZbledami.append(feature)
                                    idenBledow.add(lokalnyId_text)
    
    return obiektyZbledami


def podlozeKompleks(layer, plikGML):
    obiektyZbledami = []
    idenBledow = set()
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'gr': 'urn:gugik:specyfikacje:gmlas:mapaGlebowoRolnicza:1.0'}
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        kontur = featureMember.find('.//gr:GR_KonturGlebowy', namespaces=ns)
        if kontur is not None:
            opisyPodloza =  kontur.findall('.//gr:opisPodloza', namespaces=ns)
            lokalnyId = kontur.find('.//gr:lokalnyId', namespaces=ns)
            lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
            kompleks = kontur.find('.//gr:kompleks', namespaces=ns)
            kompleks_text = kompleks.text if kompleks is not None else "Nieznane ID"
            typPodtyp = kontur.find('.//gr:typPodtyp', namespaces=ns)
            typPodtyp_text = typPodtyp.text if typPodtyp is not None else "Nieznane ID"
            if kompleks_text == 'Tnk':
                for opisPodloza in opisyPodloza:
                    nrPodloza = opisPodloza.find('.//gr:numerPodloza', namespaces=ns)
                    nrPodloza_value = nrPodloza.text if nrPodloza is not None else None
                    podloze = opisPodloza.find('.//gr:podloze', namespaces=ns)
                    podloze_value = podloze.text if podloze is not None else None
                    if typPodtyp_text is not None or podloze_value is not None or nrPodloza_value is not None:
                        if lokalnyId_text not in idenBledow:
                            expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
                            request = QgsFeatureRequest().setFilterExpression(expression)
                            for feature in layer.getFeatures(request):
                                obiektyZbledami.append(feature)
                            idenBledow.add(lokalnyId_text)
                    
    return obiektyZbledami


def kontrola_OT_ADJA_A_z_A02_Granice_powiatow(layer):
    obiektyZbledami = []
    
    extractbyexpression = processing.run("qgis:extractbyexpression", {
        'INPUT': layer,
        'EXPRESSION': '"rodzaj" IN (\'państwo\', \'województwo\', \'powiat\')',
        'FAIL_OUTPUT': 'memory:',
        'OUTPUT': 'memory:'
    })
    
    terytyPowiatow = []
    for obj in extractbyexpression['OUTPUT'].getFeatures():
        terytyPowiatow.append(str(obj['identyfikatorTERYTjednostki']))
        
    config = configparser.ConfigParser()
    mainPath = pathlib.Path(QgsApplication.qgisSettingsDirPath()) / pathlib.Path("python/plugins/Walidator_plikow_gml/")
    config.read(str(mainPath) + '/Walidator_plikow_gml.ini')
    granicePowiatowPath = config['DEFAULT']['granicepowiatow']
    granicePowiatow = QgsVectorLayer(granicePowiatowPath, 'GranicePowiatow', 'ogr')
    granicePowiatow_z_PRG = QgsVectorLayer("Polygon?crs=epsg:2180&field=gml_id:string(254)", "granica powiatu z PRG", "memory")
    
    granicePowiatow = processing.run("native:multiparttosingleparts", {
        'INPUT': granicePowiatow,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    for obj in granicePowiatow.getFeatures():
        JPT_KOD_JE = str(obj['JPT_KOD_JE'])
        if JPT_KOD_JE in terytyPowiatow:
            granicePowiatow_z_PRG.dataProvider().addFeatures([obj])
            
    extractbyexpression_linia = processing.run("native:polygonstolines", {
        'INPUT': extractbyexpression['OUTPUT'],
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    granicePowiatow_z_PRG_linia = processing.run("native:polygonstolines", {
        'INPUT': granicePowiatow_z_PRG,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    bufor = processing.run("native:buffer", {
        'INPUT': granicePowiatow_z_PRG_linia,
        'DISTANCE': 0.02,
        'SEGMENTS': 10,
        'DISSOLVE': True,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    difference = processing.run("qgis:difference", {
        'INPUT': extractbyexpression_linia,
        'OVERLAY': bufor,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    pojedynczeObiekty = processing.run("native:multiparttosingleparts", {
        'INPUT': difference,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    if pojedynczeObiekty.featureCount() > 0:
        is_error_found = True
        for lyr in QgsProject.instance().mapLayers().values():
            if lyr.name() == "granica powiatu z PRG":
                is_error_found = False
        if is_error_found:
            QgsProject.instance().addMapLayer(granicePowiatow_z_PRG)
            
        for obj in pojedynczeObiekty.getFeatures():
            obiektyZbledami.append(obj)
            
    return obiektyZbledami


def kontrola_OT_ADJA_A_z_A03_Granice_gmin(layer):
    obiektyZbledami = []
    
    extractbyexpression = processing.run("qgis:extractbyexpression", {
        'INPUT': layer,
        'EXPRESSION': '"rodzaj" = \'gmina\'',
        'FAIL_OUTPUT': 'memory:',
        'OUTPUT': 'memory:'
    })
    
    terytyGmin = []
    for obj in extractbyexpression['OUTPUT'].getFeatures():
        terytyGmin.append(str(obj['identyfikatorTERYTjednostki']))
        
    config = configparser.ConfigParser()
    mainPath = pathlib.Path(QgsApplication.qgisSettingsDirPath()) / pathlib.Path("python/plugins/Walidator_plikow_gml/")
    config.read(str(mainPath) + '/Walidator_plikow_gml.ini')
    graniceGminPath = config['DEFAULT']['granicegmin']
    graniceGmin = QgsVectorLayer(graniceGminPath, 'GraniceGmin', 'ogr')
    graniceGmin_z_PRG = QgsVectorLayer("Polygon?crs=epsg:2180&field=gml_id:string(254)", "granice gmin z PRG", "memory")
    
    graniceGmin = processing.run("native:multiparttosingleparts", {
        'INPUT': graniceGmin,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    for obj in graniceGmin.getFeatures():
        JPT_KOD_JE = str(obj['JPT_KOD_JE'])
        if JPT_KOD_JE in terytyGmin:
            graniceGmin_z_PRG.dataProvider().addFeatures([obj])
            
    extractbyexpression_linia = processing.run("native:polygonstolines", {
        'INPUT': extractbyexpression['OUTPUT'],
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    graniceGmin_z_PRG_linia = processing.run("native:polygonstolines", {
        'INPUT': graniceGmin_z_PRG,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    bufor = processing.run("native:buffer", {
        'INPUT': graniceGmin_z_PRG_linia,
        'DISTANCE': 0.02,
        'SEGMENTS': 10,
        'DISSOLVE': True,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    difference = processing.run("qgis:difference", {
        'INPUT': extractbyexpression_linia,
        'OVERLAY': bufor,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    pojedynczeObiekty = processing.run("native:multiparttosingleparts", {
        'INPUT': difference,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    if pojedynczeObiekty.featureCount() > 0:
        is_error_found = True
        for lyr in QgsProject.instance().mapLayers().values():
            if lyr.name() == "granice gmin z PRG":
                is_error_found = False
        if is_error_found:
            QgsProject.instance().addMapLayer(graniceGmin_z_PRG)
            
        for obj in pojedynczeObiekty.getFeatures():
            obiektyZbledami.append(obj)
            
    return obiektyZbledami


def kontrola_OT_ADJA_A_z_A05_Granice_jednostek_ewidencyjnych(layer):
    obiektyZbledami = []
    
    extractbyexpression = processing.run("qgis:extractbyexpression", {
        'INPUT': layer,
        'EXPRESSION': '"rodzaj" = \'miasto w gminie miejsko-wiejskiej\'',
        'FAIL_OUTPUT': 'memory:',
        'OUTPUT': 'memory:'
    })
    
    terytyMiast = []
    teryt = ''
    
    for obj in extractbyexpression['OUTPUT'].getFeatures():
        if obj['rodzaj'] == 'miasto w gminie miejsko-wiejskiej':
            if len(str(obj['identyfikatorTERYTjednostki'])) < 7:
                Teryt = str(obj['identyfikatorTERYTjednostki']).zfill(7)
            else:
                Teryt = str(obj['identyfikatorTERYTjednostki'])
            terytyMiast.append(Teryt)
            teryt = Teryt[:4]
    
    config = configparser.ConfigParser()
    mainPath = pathlib.Path(QgsApplication.qgisSettingsDirPath()) / pathlib.Path("python/plugins/Walidator_plikow_gml/")
    config.read(str(mainPath) + '/Walidator_plikow_gml.ini')
    graniceJednostekEwidencyjnychPath = config['DEFAULT']['granicejednostekewidencyjnych']
    graniceJednostekEwidencyjnych = QgsVectorLayer(graniceJednostekEwidencyjnychPath, 'GraniceJednostekEwidencyjnych', 'ogr')
    graniceJednostekEwidencyjnych_z_PRG = QgsVectorLayer("Polygon?crs=epsg:2180&field=gml_id:string(254)", "granice jednostek ewidencyjnych z PRG", "memory")
    
    graniceJednostekEwidencyjnych = processing.run("native:multiparttosingleparts", {
        'INPUT': graniceJednostekEwidencyjnych,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    for obj in graniceJednostekEwidencyjnych.getFeatures():
        JPT_KOD_JE = str(obj['JPT_KOD_JE']).replace("_", "")
        if JPT_KOD_JE in terytyMiast:
            graniceJednostekEwidencyjnych_z_PRG.dataProvider().addFeatures([obj])
        else:
            if JPT_KOD_JE[:4] == teryt and JPT_KOD_JE[-1] in ['4', '3']:
                nowyRekord = QgsFeature(graniceJednostekEwidencyjnych_z_PRG.fields())
                nowyRekord.setAttribute(0, 'nie dotyczy')
                nowyRekord.setGeometry(obj.geometry())
                obiektyZbledami.append(nowyRekord)
    
    extractbyexpression_linia = processing.run("native:polygonstolines", {
        'INPUT': extractbyexpression['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    jednostkiEwidencyjne_z_PRG_linia = processing.run("native:polygonstolines", {
        'INPUT': graniceJednostekEwidencyjnych_z_PRG,
        'OUTPUT': 'memory:'
    })
   
    bufor = processing.run("native:buffer", {
        'INPUT': jednostkiEwidencyjne_z_PRG_linia['OUTPUT'],
        'DISTANCE': 0.02,
        'SEGMENTS': 10,
        'DISSOLVE': True,
        'OUTPUT': 'memory:'
    })
    
    difference = processing.run("qgis:difference", {
        'INPUT': extractbyexpression_linia['OUTPUT'],
        'OVERLAY': bufor['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    pojedynczeObiekty = processing.run("native:multiparttosingleparts", {
        'INPUT': difference['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    if pojedynczeObiekty['OUTPUT'].featureCount() > 0:
        is_error_found = True
        for lyr in QgsProject.instance().mapLayers().values():
            if lyr.name() == "granice jednostek ewidencyjnych z PRG":
                is_error_found = False
        if is_error_found:
            QgsProject.instance().addMapLayer(graniceJednostekEwidencyjnych_z_PRG)
        
        for obj in pojedynczeObiekty['OUTPUT'].getFeatures():
            obiektyZbledami.append(obj)
    
    return obiektyZbledami


def kompletnoscPlikowBDOT10k(pliki):
    obiektyZbledami = []
    
    listaKlas = ['OT_ADJA_A','OT_ADMS_A','OT_ADMS_P','OT_BUBD_A','OT_BUHD_A','OT_BUHD_L','OT_BUIB_A','OT_BUIB_L','OT_BUIN_L','OT_BUIT_A',
                 'OT_BUIT_P','OT_BUSP_A','OT_BUSP_L','OT_BUTR_L','OT_BUTR_P','OT_BUUO_L','OT_BUWT_A','OT_BUWT_P','OT_BUZM_L','OT_BUZT_A',
                 'OT_BUZT_P','OT_KUHO_A','OT_KUHU_A','OT_KUKO_A','OT_KUKO_P','OT_KUMN_A','OT_KUOS_A','OT_KUOZ_A','OT_KUPG_A','OT_KUPG_P',
                 'OT_KUPW_A','OT_KUSC_A','OT_KUSK_A','OT_KUZA_A','OT_OIKM_A','OT_OIKM_L','OT_OIKM_P','OT_OIMK_A','OT_OIOR_A','OT_OIOR_L',
                 'OT_OIOR_P','OT_OIPR_L','OT_OIPR_P','OT_OISZ_A','OT_PTGN_A','OT_PTKM_A','OT_PTLZ_A','OT_PTNZ_A','OT_PTPL_A','OT_PTRK_A',
                 'OT_PTSO_A','OT_PTTR_A','OT_PTUT_A','OT_PTWP_A','OT_PTWZ_A','OT_PTZB_A','OT_RTLW_L','OT_RTPW_P','OT_SKDR_L','OT_SKJZ_L',
                 'OT_SKPP_L','OT_SKRP_L','OT_SKRW_P','OT_SKTR_L','OT_SULN_L','OT_SUPR_L','OT_SWKN_L','OT_SWRM_L','OT_SWRS_L','OT_TCON_A',
                 'OT_TCPK_A','OT_TCPN_A','OT_TCRZ_A']
    
    brakujaceKlasy = QgsVectorLayer("Point?crs=epsg:2180&field=gml_id:string(254)", "brakujace klasy", "memory")
    
    for klasa in listaKlas:
        brakKlasy = True
        for plik in pliki:
            if plik.__contains__(klasa):
                brakKlasy = False
                break
        if brakKlasy:
            brakujaceKlasy.startEditing()
            nowyRekord = QgsFeature(brakujaceKlasy.fields())
            nowyRekord.setAttribute(0, klasa)
            nowyRekord.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(0, 0)))
            brakujaceKlasy.addFeature(nowyRekord)
            brakujaceKlasy.commitChanges()
            obiektyZbledami.append(nowyRekord)
    
    return obiektyZbledami


def kompletnoscObiektowBDOT10k(layer, plikGMLzrodlowy, plikGML):
    obiektyZbledami = []
    ns = {
        'gml': 'http://www.opengis.net/gml/3.2',
        'ot': 'urn:gugik:specyfikacje:gmlas:bazaDanychObiektowTopograficznych10k:2.0'
    }
    rootKontrolowane = lxml.etree.parse(plikGML).getroot()
    lokalnyIdsKontrolowane = [
        el.text for el in rootKontrolowane.findall('.//ot:lokalnyId', namespaces=ns)
    ]
    try:
        rootZrodla = lxml.etree.parse(plikGMLzrodlowy).getroot()
        lokalnyIdsZrodla = [
            el.text for el in rootZrodla.findall('.//ot:lokalnyId', namespaces=ns)
        ]
    except Exception:
        return obiektyZbledami
        
    if not lokalnyIdsZrodla:
        return obiektyZbledami
    brakujace = set(lokalnyIdsZrodla) - set(lokalnyIdsKontrolowane)
    if brakujace:
        layerZrodlo = QgsVectorLayer(plikGMLzrodlowy, 'BDOT10k_dane_zrodlowe', 'ogr')
        if not layerZrodlo.isValid():
            return obiektyZbledami
        for lokalnyId in brakujace:
            expr = QgsExpression(f'"lokalnyId" = \'{lokalnyId}\'')
            request = QgsFeatureRequest(expr)
            for feat in layerZrodlo.getFeatures(request):
                obiektyZbledami.append(feat)
    return obiektyZbledami
    

def kontrolaZmianAtrybutowWzgledemWersji(layer, plikGMLzrodlowy, plikGML):
    obiektyZbledami = set()
    parser = etree.XMLParser(remove_blank_text=True)
    k_root = etree.parse(plikGML, parser).getroot()
    try:
        z_root = etree.parse(plikGMLzrodlowy, parser).getroot()
    except Exception:
        return obiektyZbledami
        
    for elem in k_root.xpath('//*[@gml:id]', namespaces={'gml': 'http://www.opengis.net/gml/3.2'}):
        del elem.attrib['{http://www.opengis.net/gml/3.2}id']
    for elem in z_root.xpath('//*[@gml:id]', namespaces={'gml': 'http://www.opengis.net/gml/3.2'}):
        del elem.attrib['{http://www.opengis.net/gml/3.2}id']
    for root in (k_root, z_root):
        for posList_elem in root.xpath('//gml:posList', namespaces={'gml': 'http://www.opengis.net/gml/3.2'}):
            if posList_elem.text:
                posList_elem.text = posList_elem.text.strip()
    ns = {
        'gml': 'http://www.opengis.net/gml/3.2',
        'ot': 'urn:gugik:specyfikacje:gmlas:bazaDanychObiektowTopograficznych10k:2.0'
    }
    fMembers_K = k_root.findall('.//gml:featureMember', namespaces=ns)
    fMembers_Z = z_root.findall('.//gml:featureMember', namespaces=ns)
    
    if not fMembers_K or not fMembers_Z:
        return obiektyZbledami
    
    fMembers_K_dic = {}
    fMembers_Z_dic = {}
    badfMember_Z_dic = {}
    
    for fMember in fMembers_K:
        lokalnyIdEl = fMember.find('.//ot:lokalnyId', namespaces=ns)
        if lokalnyIdEl is not None and lokalnyIdEl.text:
            fMembers_K_dic[lokalnyIdEl.text] = fMember
    for fMember in fMembers_Z:
        lokalnyIdEl = fMember.find('.//ot:lokalnyId', namespaces=ns)
        if lokalnyIdEl is not None and lokalnyIdEl.text:
            fMembers_Z_dic[lokalnyIdEl.text] = fMember
            
    if not fMembers_K_dic or not fMembers_Z_dic:
        return obiektyZbledami
    
    for lokalnyId in fMembers_Z_dic:
        if lokalnyId in fMembers_K_dic:
            k_fm = fMembers_K_dic[lokalnyId]
            z_fm = fMembers_Z_dic[lokalnyId]
            wersja_k = k_fm.find('.//ot:wersja', namespaces=ns)
            wersja_z = z_fm.find('.//ot:wersja', namespaces=ns)
            
            # NIEUZASADNIONA ZMIANA WERSJI
            if wersja_k is not None and wersja_z is not None and wersja_k.text != wersja_z.text:
                
                k_fm_copy = copy.deepcopy(k_fm)
                z_fm_copy = copy.deepcopy(z_fm)
                
                for fm in (k_fm_copy, z_fm_copy):
                    wersja_elem = fm.find('.//ot:wersja', namespaces=ns)
                    if wersja_elem is not None:
                        wersja_elem.getparent().remove(wersja_elem)
                        
                wykluczone = ['lokalnyId', 'przestrzenNazw', 'poczatekWersjiObiektu', 'oznaczenieZmiany']
                
                for fm_copy in (k_fm_copy, z_fm_copy):
                    for tag in wykluczone:
                        for elem in fm_copy.findall('.//gml:' + tag, namespaces=ns):
                            elem.getparent().remove(elem)
                k_fm_str = etree.tostring(k_fm_copy, method="c14n", exclusive=True)
                z_fm_str = etree.tostring(z_fm_copy, method="c14n", exclusive=True)
                if k_fm_str == z_fm_str:
                    badfMember_Z_dic[lokalnyId] = {'nieuzasadniona zmiana wersji'}
                    
            # ZMIANA ATRYBUTÓW BEZ ZMIANY WERSJI
            elif wersja_k is not None and wersja_z is not None and wersja_k.text == wersja_z.text:
                if etree.tostring(k_fm, method="c14n", exclusive=True) != etree.tostring(z_fm, method="c14n", exclusive=True):
                    atrybutyZRoznica = set()
                    for elem_z in z_fm.iter():
                        if elem_z.tag.endswith('featureMember'):
                            continue
                        tagname = elem_z.tag.split("}")[-1]
                        if not tagname.startswith('OT_'):
                            znaleziono = any(elem_k.text == elem_z.text for elem_k in k_fm.findall('.//' + elem_z.tag))
                            if not znaleziono:
                                if tagname in ['posList', 'LinearRing', 'LineString', 'exterior', 'interior',
                                               'Polygon', 'segments', 'LineStringSegment', 'Curve', 'pos', 'Point']:
                                    atrybutyZRoznica.add('geometria')
                                else:
                                    atrybutyZRoznica.add(tagname)
                    for elem_k in k_fm.iter():
                        if elem_k.tag.endswith('featureMember'):
                            continue
                        tagname = elem_k.tag.split("}")[-1]
                        if not tagname.startswith('OT_'):
                            znaleziono = any(elem_z.text == elem_k.text for elem_z in z_fm.findall('.//' + elem_k.tag))
                            if not znaleziono:
                                if tagname in ['posList', 'LinearRing', 'LineString', 'exterior', 'interior',
                                               'Polygon', 'segments', 'LineStringSegment', 'Curve', 'pos', 'Point']:
                                    atrybutyZRoznica.add('geometria')
                                else:
                                    atrybutyZRoznica.add(tagname)
                    if atrybutyZRoznica:
                        badfMember_Z_dic[lokalnyId] = {'obiekt ma tą samą wersję i zmienione atrybuty: ' + ','.join(atrybutyZRoznica)}
                        
    if badfMember_Z_dic:
        for feature in layer.getFeatures():
            lokalnyId = feature['lokalnyId']
            if lokalnyId in badfMember_Z_dic:
                komunikat = '|'.join(badfMember_Z_dic[lokalnyId])
                gml_id = feature["gml_id"] + "|" + komunikat
                feature.setAttribute(layer.fields().indexFromName("gml_id"), gml_id)
                layer.updateFeature(feature)
                obiektyZbledami.add(feature)
        layer.commitChanges()
        
    del fMembers_Z_dic, fMembers_K_dic, badfMember_Z_dic
    
    return obiektyZbledami


def kontrolaZgodnosciZDanymiPRNG(layer, plik_prng, klasa):
    global loaded_gml_prng_miejscowosci, loaded_gml_prng_obiektyfizjograficzne
    obiektyZbledami = []
    
    if not 'identyfikatorPRNG' in [field.name() for field in layer.fields()]:
        return []
    
    if loaded_gml_prng_miejscowosci is None and 'PRNG_MIEJSCOWOSCI' in plik_prng:
        loaded_gml_prng_miejscowosci = QgsVectorLayer(plik_prng, 'Warstwa GML', 'ogr')
    
    if loaded_gml_prng_obiektyfizjograficzne is None and 'PRNG_OBIEKTY_FIZJOGRAFICZNE' in plik_prng:
        loaded_gml_prng_obiektyfizjograficzne = QgsVectorLayer(plik_prng, 'Warstwa GML', 'ogr')
    
    if 'PRNG_MIEJSCOWOSCI' in plik_prng:
        loaded_gml_prng = loaded_gml_prng_miejscowosci
    else:
        loaded_gml_prng = loaded_gml_prng_obiektyfizjograficzne
    
    posiada_ID_PRNG = processing.run("qgis:extractbyexpression", {
        'INPUT': layer,
        'EXPRESSION': '"identyfikatorPRNG" IS NOT NULL',
        'OUTPUT': 'memory:'
    })
    layer_with_id = posiada_ID_PRNG['OUTPUT']
    # Pobierz indeks pola 'identyfikatorPRNG'
    idx_id_field = layer_with_id.fields().indexFromName('identyfikatorPRNG')
    nazwa =layer_with_id.fields()[idx_id_field].name()
    # Sprawdź typ pola
    field_type = layer_with_id.fields()[idx_id_field].type()
    # Jeśli typ pola jest różny od int, wykonaj konwersję
    if field_type != QVariant.Int: 
        layer_with_id.startEditing() # utworzenie nowego pola
        idx_new_field =layer_with_id.dataProvider().addAttributes([QgsField("identyfikatorPRNG_int", QVariant.Int)])
        layer_with_id.updateFields()
        zmiana = processing.run("qgis:fieldcalculator", {
            'INPUT': layer_with_id,
            'FIELD_NAME': 'identyfikatorPRNG_int',
            'FIELD_TYPE': 0,  # typ danych: Integer
            'FORMULA': 'toint("identyfikatorPRNG")',
            'OUTPUT': 'memory:'
        })
        # Zaktualizuj indeks pola
        idx_id_field = layer_with_id.fields().indexFromName('identyfikatorPRNG_int')
        nazwa =layer_with_id.fields()[idx_id_field].name()
        layer_with_id = zmiana['OUTPUT'] # podstawienie do zmiennej
    joinattributestable = processing.run("native:joinattributestable", {
        'INPUT': layer_with_id, #poprzednio: posiada_ID_PRNG['OUTPUT'],
        'FIELD':  nazwa, #'identyfikatorPRNG',
        'INPUT_2': loaded_gml_prng,
        'FIELD_2':'identyfikatorPRNG',
        'FIELDS_TO_COPY': ['identyfikatorPRNG','nazwaGlowna'],
        'METHOD': 1,
        'DISCARD_NONMATCHING': False,
        'OUTPUT': 'memory:',
        'NON_MATCHING':'memory:'
    })
    
    for feature in joinattributestable['OUTPUT'].getFeatures():
        if feature['nazwa'] != feature['nazwaGlowna']:
            gml_id = str(feature["gml_id"]) + '| nazwaGlowna:' + str(feature['nazwaGlowna']) + ',nazwa:' + str(feature['nazwa'])
            feature.setAttribute(joinattributestable['OUTPUT'].fields().indexFromName("gml_id"), gml_id)
            joinattributestable['OUTPUT'].updateFeature(feature)
            obiektyZbledami.append(feature)
    
    if joinattributestable['NON_MATCHING'].featureCount() > 0:
        joinattributestable['NON_MATCHING'].setName(f"obiekty {klasa} nie połączone z PRNG")
        QgsProject.instance().addMapLayer(joinattributestable['NON_MATCHING'])
    
    return obiektyZbledami


def kontrolaZgodnosciZDanymiGDOS(layer, tc_zip, klasa):
    global tereny_chronione_zip
    obiektyZbledami = []
    klasaPliki = {'OT_TCPN_A': ['ParkiNarodowePolygon.shp'],
                  'OT_TCPK_A': ['ParkiKrajobrazowePolygon.shp'],
                  'OT_TCRZ_A': ['RezerwatyPolygon.shp'],
                  'OT_TCON_A': ['ObszarySpecjalnejOchronyPolygon.shp', 'SpecjalneObszaryOchronyPolygon.shp']}
    
    if tereny_chronione_zip is None:
        tereny_chronione_zip = tc_zip
        if zipfile.is_zipfile(tereny_chronione_zip):
            with zipfile.ZipFile(tereny_chronione_zip, 'r') as plikZIP:
                plikZIP.extractall(os.path.dirname(tereny_chronione_zip))
    
    loaded_shp = {klasa: [] for klasa in klasaPliki.keys()}
    
    for i, klasaPlik in enumerate(klasaPliki[klasa]):
        sciezka = os.path.join(os.path.dirname(tereny_chronione_zip), klasaPlik)
        loaded_shp[klasa].append(QgsVectorLayer(sciezka, f'Warstwa {i} SHP dla klasy {klasa}', 'ogr'))
    
    posiada_numerCRFOP = processing.run("qgis:extractbyexpression", {
        'INPUT': layer,
        'EXPRESSION': '"numerCRFOP" IS NOT NULL',
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    if klasa != 'OT_TCON_A':
        shp_out = processing.run("qgis:extractbyexpression", {
            'INPUT': loaded_shp[klasa][0],
            'EXPRESSION': "not nazwa like '%otulina%'",
            'OUTPUT': 'memory:'
        })['OUTPUT']
    else:
        shp_out = processing.run("native:mergevectorlayers", {
            'LAYERS': loaded_shp[klasa],
            'OUTPUT': 'memory:'
        })['OUTPUT']
    
    config = configparser.ConfigParser()
    mainPath = pathlib.Path(QgsApplication.qgisSettingsDirPath()) / pathlib.Path(r"python/plugins/Walidator_plikow_gml/")
    config.read(str(mainPath) + '/Walidator_plikow_gml.ini')
    granicePowiatowPath = config['DEFAULT']['granicepowiatow']
    granicePowiatow = QgsVectorLayer(granicePowiatowPath, 'GranicePowiatow', 'ogr')
    
    granicePowiatow = processing.run("native:multiparttosingleparts", {
        'INPUT': granicePowiatow,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    powiat_z_PRG = QgsVectorLayer("Polygon?crs=epsg:2180&field=gml_id:string(254)", "granica powiatu z PRG", "memory")
    terytPowiatu = int(layer.name()[-15:-11])
    
    for obj in granicePowiatow.getFeatures():
        if str(obj['JPT_KOD_JE']) == str(terytPowiatu):
            powiat_z_PRG.dataProvider().addFeatures([obj])
            break
    
    clip = processing.run("native:clip", {
        'INPUT': shp_out,
        'OVERLAY': powiat_z_PRG,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    shp_out_linie = processing.run("native:polygonstolines", {
        'INPUT': clip,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    posiada_numerCRFOP_linie = processing.run("native:polygonstolines", {
        'INPUT': posiada_numerCRFOP,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    bufor = processing.run("native:buffer", {
        'INPUT': shp_out_linie,
        'DISTANCE': 0.20,
        'SEGMENTS': 10,
        'DISSOLVE': True,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    difference = processing.run("qgis:difference", {
        'INPUT': posiada_numerCRFOP_linie,
        'OVERLAY': bufor,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    pojedynczeObiekty = processing.run("native:multiparttosingleparts", {
        'INPUT': difference,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    if pojedynczeObiekty.featureCount() > 0:
        poza_GDOS = QgsVectorLayer("LineString?crs=epsg:2180&field=gml_id:string(254)", f"niezgodność geometrii {klasa} z danymi GDOŚ", "memory")
        poza_GDOS.startEditing()
        for n in pojedynczeObiekty.getFeatures():
            nowyRekord = QgsFeature(poza_GDOS.fields())
            nowyRekord.setAttribute(0, 'nie dotyczy')
            nowyRekord.setGeometry(n.geometry())
            poza_GDOS.addFeature(nowyRekord)
            obiektyZbledami.append(nowyRekord)
        poza_GDOS.commitChanges()
        QgsProject.instance().addMapLayer(poza_GDOS)
    
    return obiektyZbledami


def kontrolaFormatuAtrybutuWysokoscRT(layer, plikGML):
    obiektyZbledami = []
    pattern_kopiec = re.compile(r"^-?\d+\.(0|5)$")
    pattern_punkt = re.compile(r"^-?\d+\.\d$")
    pattern_poziomica = re.compile(r"^-?\d+\.(00|25|50|75)$")
    plikGML = plikGML.getroot()
    otklasa = f".//ot:{layer.name()[-9:]}"
    ns = {
        'gml': 'http://www.opengis.net/gml/3.2',
        "ot": "urn:gugik:specyfikacje:gmlas:bazaDanychObiektowTopograficznych10k:2.0"
    }
    lokalnyId_to_feature = {f["lokalnyId"]: f for f in layer.getFeatures()}
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        match = featureMember.find(otklasa, namespaces=ns)
        if match is None:
            continue
        lokalnyId_elem = match.find('.//ot:lokalnyId', namespaces=ns)
        wysokosc_elem = match.find('.//ot:wysokosc', namespaces=ns)
        rodzaj_elem = match.find('.//ot:rodzaj', namespaces=ns)
        if lokalnyId_elem is None or wysokosc_elem is None or rodzaj_elem is None:
            continue
        lokalnyId = lokalnyId_elem.text.strip()
        wysokosc = wysokosc_elem.text.strip()
        rodzaj = rodzaj_elem.text.strip()
        if lokalnyId not in lokalnyId_to_feature:
            continue
        feature = lokalnyId_to_feature[lokalnyId]
        if wysokosc in ['-0.0', '-0.00']:
            obiektyZbledami.append(feature)
        else:
            if rodzaj in ['dół', 'kopiec lub hałda']:
                if not pattern_kopiec.fullmatch(wysokosc):
                    obiektyZbledami.append(feature)
            elif rodzaj == 'punkt wysokościowy w terenie':
                if not pattern_punkt.fullmatch(wysokosc):
                    obiektyZbledami.append(feature)
            elif rodzaj == 'poziomica':
                if not pattern_poziomica.fullmatch(wysokosc):
                    obiektyZbledami.append(feature)
            elif rodzaj in ['skarpa', 'wąwóz']:
                if not pattern_kopiec.fullmatch(wysokosc):
                    obiektyZbledami.append(feature)
    
    return obiektyZbledami


def kontrolaFormatuAtrybutuSzerokoscSW(layer, plikGML):
    obiektyZbledami = []
    pattern = re.compile(r"^\d+\.([05])$")
    plikGML = plikGML.getroot()
    otklasa = f'.//ot:{layer.name()[-9:]}'
    ns = {'gml': 'http://www.opengis.net/gml/3.2', "ot": "urn:gugik:specyfikacje:gmlas:bazaDanychObiektowTopograficznych10k:2.0"}
    
    lokalnyId_to_feature = {f["lokalnyId"]: f for f in layer.getFeatures()}
    
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        matches = featureMember.find(otklasa, namespaces=ns)
        if matches is not None:
            lokalnyId = matches.find('.//ot:lokalnyId', namespaces=ns)
            szerokosc_elem = matches.find('.//ot:szerokosc', namespaces=ns)
            lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
            
            if lokalnyId_text not in lokalnyId_to_feature or szerokosc_elem is None:
                continue
            
            feature = lokalnyId_to_feature[lokalnyId_text]
            szerokosc_value = szerokosc_elem.text.strip()
            if not pattern.fullmatch(szerokosc_value):
                obiektyZbledami.append(feature)
    
    return obiektyZbledami


def kontrolaFormatuAtrybutuSzerokoscSK(layer, plikGML):
    obiektyZbledami = []
    
    klasa = layer.name()[-9:]  
    valid_layer_names = ['OT_SKJZ_L', 'OT_SKDR_L', 'OT_SKRP_L']
    
    if klasa not in valid_layer_names:
        return []
    
    atrybut_do_sprawdzenia = "szerokoscNawierzchni" if klasa in ['OT_SKJZ_L', 'OT_SKDR_L'] else "szerokosc"    
    pattern = re.compile(r"^\d+\.\d$")  
    
    plikGML = plikGML.getroot()
    otklasa = f'.//ot:{klasa}'
    ns = {'gml': 'http://www.opengis.net/gml/3.2', "ot": "urn:gugik:specyfikacje:gmlas:bazaDanychObiektowTopograficznych10k:2.0"}
    
    lokalnyId_to_feature = {f["lokalnyId"]: f for f in layer.getFeatures()}
    
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        matches = featureMember.find(otklasa, namespaces=ns)
        if matches is not None:
            lokalnyId = matches.find('.//ot:lokalnyId', namespaces=ns)
            szerokosc_elem = matches.find(f'.//ot:{atrybut_do_sprawdzenia}', namespaces=ns)
            lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
            
            if lokalnyId_text not in lokalnyId_to_feature or szerokosc_elem is None:
                continue
            
            feature = lokalnyId_to_feature[lokalnyId_text]
            szerokosc_value = szerokosc_elem.text.strip()
            if not pattern.fullmatch(szerokosc_value):
                obiektyZbledami.append(feature)
    
    return obiektyZbledami


def kontrolaFormatuAtrybutuWysokoscZapory(layer, plikGML):
    obiektyZbledami = []
    pattern = re.compile(r"^[1-9]\d*$")
    plikGML = plikGML.getroot()
    otklasa = f'.//ot:{layer.name()[-9:]}'
    ns = {'gml': 'http://www.opengis.net/gml/3.2', "ot": "urn:gugik:specyfikacje:gmlas:bazaDanychObiektowTopograficznych10k:2.0"}
    
    lokalnyId_to_feature = {f["lokalnyId"]: f for f in layer.getFeatures()}
    
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        matches = featureMember.find(otklasa, namespaces=ns)
        if matches is not None:
            lokalnyId = matches.find('.//ot:lokalnyId', namespaces=ns)
            wysokosc_elem = matches.find('.//ot:wysokoscZapory', namespaces=ns)
            lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
            
            if lokalnyId_text not in lokalnyId_to_feature or wysokosc_elem is None:
                continue
            
            feature = lokalnyId_to_feature[lokalnyId_text]
            wysokosc_value = wysokosc_elem.text.strip()
            if not pattern.fullmatch(str(wysokosc_value)):
                obiektyZbledami.append(feature)
    
    return obiektyZbledami


def kontrolaFormatuAtrybutuWysokoscBUWT(layer, plikGML):
    obiektyZbledami = []
    pattern = re.compile(r"^[1-9]\d*$")
    plikGML = plikGML.getroot()
    otklasa = f'.//ot:{layer.name()[-9:]}'
    ns = {'gml': 'http://www.opengis.net/gml/3.2', "ot": "urn:gugik:specyfikacje:gmlas:bazaDanychObiektowTopograficznych10k:2.0"}
    
    lokalnyId_to_feature = {f["lokalnyId"]: f for f in layer.getFeatures()}
    
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        matches = featureMember.find(otklasa, namespaces=ns)
        if matches is not None:
            lokalnyId = matches.find('.//ot:lokalnyId', namespaces=ns)
            wysokosc_elem = matches.find('.//ot:wysokosc', namespaces=ns)
            lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
            
            if lokalnyId_text not in lokalnyId_to_feature or wysokosc_elem is None:
                continue
            
            feature = lokalnyId_to_feature[lokalnyId_text]
            wysokosc_value = wysokosc_elem.text.strip()
            if not pattern.fullmatch(str(wysokosc_value)):
                obiektyZbledami.append(feature)
    
    return obiektyZbledami


def kontrolaFormatuParametrowBUZM(layer, plikGML):
    obiektyZbledami = []
    pattern = re.compile(r"^\d+\.[05]$")
    plikGML = plikGML.getroot()
    otklasa = f'.//ot:{layer.name()[-9:]}'
    ns = {'gml': 'http://www.opengis.net/gml/3.2', "ot": "urn:gugik:specyfikacje:gmlas:bazaDanychObiektowTopograficznych10k:2.0"}
    
    lokalnyId_to_feature = {f["lokalnyId"]: f for f in layer.getFeatures()}
    
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        matches = featureMember.find(otklasa, namespaces=ns)
        if matches is not None:
            lokalnyId = matches.find('.//ot:lokalnyId', namespaces=ns)
            wysokosc_elem = matches.find('.//ot:wysokosc', namespaces=ns)
            szerokoscPodstawy_elem = matches.find('.//ot:szerokoscPodstawy', namespaces=ns)
            szerokoscKorony_elem = matches.find('.//ot:szerokoscKorony', namespaces=ns)
            lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
            
            if lokalnyId_text not in lokalnyId_to_feature:
                continue
            
            feature = lokalnyId_to_feature[lokalnyId_text]
            komunikaty_bledu = []
            
            for attr_name, elem in [
                ('wysokosc', wysokosc_elem),
                ('szerokoscPodstawy', szerokoscPodstawy_elem),
                ('szerokoscKorony', szerokoscKorony_elem)
            ]:
                if elem is not None:
                    value = elem.text.strip()
                    if not pattern.fullmatch(value):
                        komunikaty_bledu.append(f"{attr_name}")
            
            if komunikaty_bledu:
                gml_id = str(feature.attribute("gml_id")) if feature.attribute("gml_id") is not None else 'NULL'
                gml_id = (gml_id + " | " if gml_id != 'NULL' else "")  + ", ".join(komunikaty_bledu)
                feature.setAttribute(layer.fields().indexFromName("gml_id"), gml_id)
                layer.updateFeature(feature)
                obiektyZbledami.append(feature)
    
    return obiektyZbledami


def kontrolaFormatuParametrowBUIN(layer, plikGML):
    obiektyZbledami = []
    pattern_nosnosc = re.compile(r"^[1-9]\d*$")
    pattern_szerokosc = re.compile(r"^\d+\.\d$")
    
    plikGML = plikGML.getroot()
    otklasa = f'.//ot:{layer.name()[-9:]}'
    ns = {'gml': 'http://www.opengis.net/gml/3.2', "ot": "urn:gugik:specyfikacje:gmlas:bazaDanychObiektowTopograficznych10k:2.0"}
    
    lokalnyId_to_feature = {f["lokalnyId"]: f for f in layer.getFeatures()}
    
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        matches = featureMember.find(otklasa, namespaces=ns)
        if matches is not None:
            lokalnyId = matches.find('.//ot:lokalnyId', namespaces=ns)
            nosnosc_elem = matches.find('.//ot:nosnosc', namespaces=ns)
            szerokosc_elem = matches.find('.//ot:szerokosc', namespaces=ns)
            lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
            
            if lokalnyId_text not in lokalnyId_to_feature:
                continue
            
            feature = lokalnyId_to_feature[lokalnyId_text]
            komunikaty_bledu = []
            
            if nosnosc_elem is not None:
                value = nosnosc_elem.text.strip()
                if not pattern_nosnosc.fullmatch(value):
                    komunikaty_bledu.append("nosnosc")
            
            if szerokosc_elem is not None:
                value = szerokosc_elem.text.strip()
                if not pattern_szerokosc.fullmatch(value):
                    komunikaty_bledu.append("szerokosc")
            
            if komunikaty_bledu:
                gml_id = str(feature.attribute("gml_id")) if feature.attribute("gml_id") is not None else 'NULL'
                gml_id = (gml_id + " | " if gml_id != 'NULL' else "")  + ", ".join(komunikaty_bledu)
                feature.setAttribute(layer.fields().indexFromName("gml_id"), gml_id)
                layer.updateFeature(feature)
                obiektyZbledami.append(feature)
    
    return obiektyZbledami


def kontrolaFormatuAtrybutuSzerokoscBUTR(layer, plikGML):
    obiektyZbledami = []
    pattern = re.compile(r"^[1-9]\d*$")
    plikGML = plikGML.getroot()
    otklasa = f'.//ot:{layer.name()[-9:]}'
    ns = {'gml': 'http://www.opengis.net/gml/3.2', "ot": "urn:gugik:specyfikacje:gmlas:bazaDanychObiektowTopograficznych10k:2.0"}
    
    lokalnyId_to_feature = {f["lokalnyId"]: f for f in layer.getFeatures()}
    
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        matches = featureMember.find(otklasa, namespaces=ns)
        if matches is not None:
            lokalnyId = matches.find('.//ot:lokalnyId', namespaces=ns)
            wysokosc_elem = matches.find('.//ot:szerokosc', namespaces=ns)
            lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
            
            if lokalnyId_text not in lokalnyId_to_feature or wysokosc_elem is None:
                continue
            
            feature = lokalnyId_to_feature[lokalnyId_text]
            wysokosc_value = wysokosc_elem.text.strip()
            if not pattern.fullmatch(str(wysokosc_value)):
                obiektyZbledami.append(feature)
    
    return obiektyZbledami


def kontrolaAtrybutuNazwa(layer, plikGML):
    obiektyZbledami = []
    if 'nazwa' not in [field.name() for field in layer.fields()]:
        return obiektyZbledami
    plikGML = plikGML.getroot()
    ns = {
        'gml': 'http://www.opengis.net/gml/3.2',
        'ot': 'urn:gugik:specyfikacje:gmlas:bazaDanychObiektowTopograficznych10k:2.0'
    }
    otklasa = f'.//ot:{layer.name()[-9:]}'
    lokalnyId_to_feature = {f["lokalnyId"]: f for f in layer.getFeatures()}
    wzorzec_min_dwie_litery = re.compile(r'[a-ząćęłńóśźżĄĆĘŁŃÓŚŹŻ]{2,}', re.IGNORECASE)
    
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        matches = featureMember.find(otklasa, namespaces=ns)
        if matches is None:
            continue
        lokalnyId_elem = matches.find('.//ot:lokalnyId', namespaces=ns)
        lokalnyId_text = lokalnyId_elem.text.strip() if lokalnyId_elem is not None else "Nieznane ID"
        feature = lokalnyId_to_feature.get(lokalnyId_text)
        if not feature:
            continue
        nazwa_elem = matches.find('.//ot:nazwa', namespaces=ns)
        if nazwa_elem is None:
            continue
        nazwa_text = nazwa_elem.text.strip() if nazwa_elem.text else ""
        if not nazwa_text:
            obiektyZbledami.append(feature)
            continue
        if not wzorzec_min_dwie_litery.search(nazwa_text):
            obiektyZbledami.append(feature)
    
    return obiektyZbledami


def kontrolaReferencjiBDOT500GESUT(layer, plikGML):
    obiektyZbledami = []
    if "OT_RT" in layer.name():
        return obiektyZbledami
    valid_layer_names_gesut = ['OT_SUPR_L', 'OT_SULN_L', 'OT_BUIT_P', 'OT_BUIT_A']
    klasa = layer.name()[-9:]
    is_gesut_layer = klasa in valid_layer_names_gesut
    ns = {
        'gml': 'http://www.opengis.net/gml/3.2',
        'ot': 'urn:gugik:specyfikacje:gmlas:bazaDanychObiektowTopograficznych10k:2.0'
    }
    otklasa_xpath = f".//ot:{klasa}"
    lokalnyId_to_feature = {f["lokalnyId"]: f for f in layer.getFeatures()}
    root = plikGML.getroot()
    for featureMember in root.xpath('.//gml:featureMember', namespaces=ns):
        matches = featureMember.find(otklasa_xpath, namespaces=ns)
        if matches is None:
            continue
        lokalnyId_elem = matches.find('.//ot:lokalnyId', namespaces=ns)
        if lokalnyId_elem is None or not lokalnyId_elem.text:
            continue
        lokalnyId_text = lokalnyId_elem.text.strip()
        feature = lokalnyId_to_feature.get(lokalnyId_text)
        if feature is None:
            continue
        komunikaty_bledu = []
        # BDOT500
        bdot500_elem = matches.find('.//ot:BDOT500', namespaces=ns)
        if bdot500_elem is not None:
            ref = bdot500_elem.find('.//ot:OT_ReferencjaDoObiektu', namespaces=ns)
            if ref is not None:
                lokalnyId_ref = ref.find('.//ot:lokalnyId', namespaces=ns)
                przestrzenNazw_ref = ref.find('.//ot:przestrzenNazw', namespaces=ns)
                if (lokalnyId_ref is None or not lokalnyId_ref.text or not lokalnyId_ref.text.strip()) or \
                   (przestrzenNazw_ref is None or not przestrzenNazw_ref.text or not przestrzenNazw_ref.text.strip()):
                    komunikaty_bledu.append("BDOT500")
        # GESUT
        if is_gesut_layer:
            gesut_elem = matches.find('.//ot:GESUT', namespaces=ns)
            if gesut_elem is not None:
                ref = gesut_elem.find('.//ot:OT_ReferencjaDoObiektu', namespaces=ns)
                if ref is not None:
                    lokalnyId_ref = ref.find('.//ot:lokalnyId', namespaces=ns)
                    przestrzenNazw_ref = ref.find('.//ot:przestrzenNazw', namespaces=ns)
                    if (lokalnyId_ref is None or not lokalnyId_ref.text or not lokalnyId_ref.text.strip()) or \
                       (przestrzenNazw_ref is None or not przestrzenNazw_ref.text or not przestrzenNazw_ref.text.strip()):
                        komunikaty_bledu.append("GESUT")
        if komunikaty_bledu:
            gml_id = str(feature.attribute("gml_id")) if feature.attribute("gml_id") else 'NULL'
            nowy_gml_id = (gml_id + " | " if gml_id != 'NULL' else "") + ", ".join(komunikaty_bledu)
            feature.setAttribute(layer.fields().indexFromName("gml_id"), nowy_gml_id)
            layer.updateFeature(feature)
            obiektyZbledami.append(feature)
            
    return obiektyZbledami


def kontrolaSpojnosciSKDR_SKJZ(layer):
    try:
        obiektyZbledami = []
        dodane_bledy_ids = set()
        if not layer.isValid():
            return []
        skjz_layer_name = layer.name().replace("OT_SKDR_L", "OT_SKJZ_L")
        skjz_layers = QgsProject.instance().mapLayersByName(skjz_layer_name)
        if not skjz_layers:
            return []
        skjz_layer = skjz_layers[0]
        skrw_layer_name = layer.name().replace("OT_SKDR_L", "OT_SKRW_P")
        skrw_layers = QgsProject.instance().mapLayersByName(skrw_layer_name)
        if not skrw_layers:
            return []
        skrw_layer = skrw_layers[0]
        index_skjz = QgsSpatialIndex()
        skjz_dict = {}
        for f in skjz_layer.getFeatures():
            geom = f.geometry()
            if geom and not geom.isEmpty():
                index_skjz.insertFeature(f)
                skjz_dict[f.id()] = {
                    "geometry": geom,
                    "attributes": {attr: f[attr] for attr in f.fields().names()}
                }
        index_skrw = QgsSpatialIndex()
        ronda_dict = {}
        for f in skrw_layer.getFeatures():
            if str(f['rodzaj']).lower() == 'rondo':
                geom = f.geometry()
                if geom and not geom.isEmpty():
                    index_skrw.insertFeature(f)
                    ronda_dict[f.id()] = geom
        wspolne_atrybuty = [
            'kategoriaIstnienia', 'kategoriaZarzadzania', 'klasaDrogi',
            'materialNawierzchni', 'polozenie', 'szerokoscNawierzchni',
            'numerDrogi', 'zrodloDanychGeometrycznych', 'nazwaDrogi'
        ]
        for f in layer.getFeatures():
            komunikaty_bledu = []
            geom = f.geometry()
            if not geom or geom.isEmpty():
                continue
            liczba_jezdni = f['liczbaJezdniDrogi']
            try:
                liczba_jezdni = int(liczba_jezdni)
            except:
                liczba_jezdni = None
            candidate_ids = index_skjz.intersects(geom.boundingBox())
            matching_found = False
            for cid in candidate_ids:
                skjz_geom = skjz_dict[cid]["geometry"]
                if skjz_geom.intersects(geom):
                    intersection = skjz_geom.intersection(geom)
                    if intersection.length() > 0:
                        matching_found = True
                        skjz_attrs = skjz_dict[cid]["attributes"]
                        for attr in wspolne_atrybuty:
                            try:
                                val_skdr = str(f[attr]).strip() if f[attr] is not None else ''
                                val_skjz = str(skjz_attrs[attr]).strip() if skjz_attrs[attr] is not None else ''
                            except:
                                continue
                            if val_skdr != val_skjz:
                                komunikaty_bledu.append(f"{attr}: SKDR='{val_skdr}' ≠ SKJZ='{val_skjz}'")
                        break
            if not matching_found and liczba_jezdni == 1:
                info_dodatkowa = str(f['informacjaDodatkowa']) if 'informacjaDodatkowa' in f.fields().names() else ''
                uwagi = str(f['uwagi']) if 'uwagi' in f.fields().names() else ''
                if "linia umowna" in info_dodatkowa.lower() or "linia umowna" in uwagi.lower():
                    continue
                skrw_found = False
                candidate_ids_skrw = index_skrw.intersects(geom.boundingBox())
                for cid in candidate_ids_skrw:
                    skrw_geom = ronda_dict[cid]
                    if skrw_geom.buffer(0.1, 5).intersects(geom):
                        skrw_found = True
                        break
                if not skrw_found:
                    komunikaty_bledu.append("niespójność geometrii lub brak odpowiednika w OT_SKJZ_L")
            if komunikaty_bledu:
                gml_id = str(f['gml_id']) if f['gml_id'] is not None else 'NULL'
                gml_id = (gml_id + " | " if gml_id != 'NULL' else "") + ", ".join(komunikaty_bledu)
                f.setAttribute(layer.fields().indexFromName("gml_id"), gml_id)
                layer.updateFeature(f)
                if f.id() not in dodane_bledy_ids:
                    obiektyZbledami.append(f)
                    dodane_bledy_ids.add(f.id())
        return obiektyZbledami
    except Exception as e:
        print(f"Błąd w kontroli: {e}")
        return []


def sztucznyL_SW(layer):
    try:
        obiektyZbledami = []
        dodane_ids = set()
        valid_layer_names = ['OT_SWRS_L', 'OT_SWKN_L']
        if not layer or not layer.isValid():
            return []
        if not any(layer.name().endswith(n) for n in valid_layer_names):
            return []
        ptwp_layer = next((l for l in QgsProject.instance().mapLayers().values() if l.name().endswith("OT_PTWP_A")), None)
        if not ptwp_layer:
            return []
        ptwp_index = QgsSpatialIndex()
        ptwp_geometrie = {}
        liczba_ptwp = 0
        for feat in ptwp_layer.getFeatures():
            if str(feat["rodzaj"]).strip().lower() == "woda stojąca":
                geom = feat.geometry()
                if geom and not geom.isEmpty():
                    ptwp_index.insertFeature(feat)
                    ptwp_geometrie[feat.id()] = geom
                    liczba_ptwp += 1
        liczba_ciekow = 0
        liczba_ciekow_wewnatrz = 0
        for feat in layer.getFeatures():
            liczba_ciekow += 1
            geom = feat.geometry()
            if not geom or geom.isEmpty():
                continue
            cecha = str(feat["cechaGeometrii"]).strip().lower() if feat["cechaGeometrii"] else ""
            candidate_ids = ptwp_index.intersects(geom.boundingBox())
            for pid in candidate_ids:
                ptwp_geom = ptwp_geometrie.get(pid)
                if ptwp_geom and geom.within(ptwp_geom):
                    liczba_ciekow_wewnatrz += 1
                    if cecha != "sztuczny łącznik":
                        if feat.id() not in dodane_ids:
                            dodane_ids.add(feat.id())
                            obiektyZbledami.append(feat)
                    break
        return obiektyZbledami
    except Exception as e:
        print(f"Błąd w funkcji sztucznyL_SW: {e}")
        return []


def liniaUmowna_SK(layer):
    try:
        obiektyZbledami = []
        dodane_ids = set()
        valid_layer_name = 'OT_SKJZ_L'
        if not layer or not layer.isValid():
            return []
        if not layer.name().endswith(valid_layer_name):
            return []
        ptpl_layer = next((l for l in QgsProject.instance().mapLayers().values() if l.name().endswith("OT_PTPL_A")), None)
        if not ptpl_layer:
            return []
        ptpl_index = QgsSpatialIndex()
        ptpl_geometrie = {}
        for feat in ptpl_layer.getFeatures():
            geom = feat.geometry()
            if geom and not geom.isEmpty():
                ptpl_index.insertFeature(feat)
                ptpl_geometrie[feat.id()] = geom
        for feat in layer.getFeatures():
            geom = feat.geometry()
            if not geom or geom.isEmpty():
                continue
            cecha = str(feat["cechaGeometrii"]).strip().lower() if feat["cechaGeometrii"] else ""
            candidate_ids = ptpl_index.intersects(geom.boundingBox())
            for pid in candidate_ids:
                ptpl_geom = ptpl_geometrie.get(pid)
                if ptpl_geom and geom.within(ptpl_geom):
                    if cecha != "linia umowna":
                        if feat.id() not in dodane_ids:
                            obiektyZbledami.append(feat)
                            dodane_ids.add(feat.id())
                    break      
        return obiektyZbledami
    except Exception as e:
        print(f"Błąd w funkcji liniaUmowna_SK: {e}")
        return []


def zawieranieSWRM(layer):
    try:
        obiektyZbledami = []
        dodane_ids = set()
        valid_layer_name = 'OT_SWRM_L'
        if not layer or not layer.isValid():
            return []
        if not layer.name().endswith(valid_layer_name):
            return []
        ptwp_layer = next((l for l in QgsProject.instance().mapLayers().values() if l.name().endswith("OT_PTWP_A")), None)
        if not ptwp_layer:
            return []
        ptwp_index = QgsSpatialIndex()
        ptwp_geometrie = {}
        for feat in ptwp_layer.getFeatures():
            geom = feat.geometry()
            if geom and not geom.isEmpty():
                ptwp_index.insertFeature(feat)
                ptwp_geometrie[feat.id()] = geom
        for feat in layer.getFeatures():
            geom = feat.geometry()
            if not geom or geom.isEmpty():
                continue
            candidate_ids = ptwp_index.intersects(geom.boundingBox())
            for pid in candidate_ids:
                ptwp_geom = ptwp_geometrie.get(pid)
                if ptwp_geom and (geom.within(ptwp_geom) or geom.crosses(ptwp_geom)):
                    if feat.id() not in dodane_ids:
                        obiektyZbledami.append(feat)
                        dodane_ids.add(feat.id())
                    break
        return obiektyZbledami
    except Exception as e:
        print(f"Błąd w funkcji zawieranieSWRM: {e}")
        return []


def zawieranieOI(layer):
    try:
        obiektyZbledami = []
        dodane_ids = set()
        if not layer or not layer.isValid(): return []
        klasy_OI = ("OT_OIPR_L", "OT_OIPR_P", "OT_OIMK_A")
        klasa_layer = layer.name()[-9:]
        if klasa_layer not in klasy_OI: return []
        warstwy_powierzchniowe_nazwy = ["OT_PTLZ_A", "OT_PTZB_A", "OT_PTUT_A", "OT_PTRK_A", "OT_PTPL_A", "OT_PTWP_A"]
        warstwy_powierzchniowe = {}
        for lyr in QgsProject.instance().mapLayers().values():
            for nazwa in warstwy_powierzchniowe_nazwy:
                if lyr.name().endswith(nazwa): warstwy_powierzchniowe[nazwa] = lyr
        indeksy = {}
        geometrie = {}
        for nazwa, lyr in warstwy_powierzchniowe.items():
            idx = QgsSpatialIndex()
            geom_dict = {}
            for feat in lyr.getFeatures():
                geom = feat.geometry()
                if geom and not geom.isEmpty():
                    idx.insertFeature(feat)
                    geom_dict[feat.id()] = geom
            indeksy[nazwa] = idx
            geometrie[nazwa] = geom_dict
        raport_bledu = []
        warunki_OIPR_P = {
            "OT_PTLZ_A": lambda rodzaj, pomnik: rodzaj in ["drzewo lub grupa drzew", "kępa krzewów lub kosodrzewiny", "mały las"] and (pomnik == "obiekt niebędący pomnikiem przyrody" or not pomnik),
            "OT_PTZB_A": lambda rodzaj, pomnik: rodzaj not in ["drzewo lub grupa drzew", "mały las", "źródło", "kępa krzewów lub kosodrzewiny", "głaz narzutowy lub grupa głazów"],
            "OT_PTUT_A": lambda rodzaj, pomnik: rodzaj in ["drzewo lub grupa drzew", "kępa krzewów lub kosodrzewiny", "mały las"] and (pomnik == "obiekt niebędący pomnikiem przyrody" or not pomnik),
            "OT_PTRK_A": lambda rodzaj, pomnik: rodzaj in ["drzewo lub grupa drzew", "kępa krzewów lub kosodrzewiny", "mały las"] and (pomnik == "obiekt niebędący pomnikiem przyrody" or not pomnik),
            "OT_PTPL_A": lambda rodzaj, pomnik: rodzaj not in ["drzewo lub grupa drzew", "głaz narzutowy lub grupa głazów"]
        }
        warunki_OIPR_L = {
            "OT_PTLZ_A": lambda rodzaj, pomnik: rodzaj in ["pas krzewów lub żywopłot", "rząd drzew"] and (pomnik == "obiekt niebędący pomnikiem przyrody" or not pomnik),
            "OT_PTZB_A": lambda rodzaj, pomnik: rodzaj not in ["pas krzewów lub żywopłot", "rząd drzew"],
            "OT_PTUT_A": lambda rodzaj, pomnik: rodzaj in ["wodospad", "próg skalny", "linia oddziałowa"] and (pomnik == "obiekt niebędący pomnikiem przyrody" or not pomnik),
            "OT_PTRK_A": lambda rodzaj, pomnik: rodzaj in ["pas krzewów lub żywopłot", "rząd drzew"] and (pomnik == "obiekt niebędący pomnikiem przyrody" or not pomnik),
            "OT_PTPL_A": lambda rodzaj, pomnik: rodzaj in ["wodospad", "próg skalny", "linia oddziałowa"] and (pomnik == "obiekt niebędący pomnikiem przyrody" or not pomnik)
        }
        for feat in layer.getFeatures():
            geom = feat.geometry()
            if not geom or geom.isEmpty(): continue
            rodzaj = (feat["rodzaj"] or "").strip().lower()
            wartosc_pomnik = ''
            if 'pomnikPrzyrody' in feat.fields().names(): wartosc_pomnik = feat.attribute('pomnikPrzyrody') or ''
            pomnik = wartosc_pomnik.strip().lower()
            id_feat = feat.id()
            komunikaty_bledu = []
            warstwy_docelowe = ["OT_PTLZ_A", "OT_PTZB_A", "OT_PTUT_A", "OT_PTRK_A", "OT_PTPL_A", "OT_PTWP_A"]
            for nazwa_warstwy in warstwy_docelowe:
                if nazwa_warstwy not in indeksy: continue
                kandydaci = indeksy[nazwa_warstwy].intersects(geom.boundingBox())
                for cid in kandydaci:
                    geom_cel = geometrie[nazwa_warstwy].get(cid)
                    if not geom_cel: continue
                    if geom.within(geom_cel):
                        if id_feat in dodane_ids: break
                        bledny = False
                        if klasa_layer == "OT_OIPR_P":
                            if nazwa_warstwy in warunki_OIPR_P and warunki_OIPR_P[nazwa_warstwy](rodzaj, pomnik):
                                bledny = True
                        elif klasa_layer == "OT_OIPR_L":
                            if nazwa_warstwy in warunki_OIPR_L and warunki_OIPR_L[nazwa_warstwy](rodzaj, pomnik):
                                bledny = True
                        if bledny:
                            komunikaty_bledu.append(f"obiekt typu '{rodzaj}' błędnie na warstwie '{nazwa_warstwy}'")
                            dodane_ids.add(id_feat)
                        break
            if klasa_layer == "OT_OIMK_A":
                if "OT_PTWP_A" in indeksy:
                    kandydaci = indeksy["OT_PTWP_A"].intersects(geom.boundingBox())
                    for cid in kandydaci:
                        geom_cel = geometrie["OT_PTWP_A"].get(cid)
                        if geom_cel and geom.within(geom_cel):
                            if id_feat not in dodane_ids:
                                komunikaty_bledu.append(f"obiekt typu '{rodzaj}' błędnie na warstwie 'OT_PTWP_A'")
                                dodane_ids.add(id_feat)
                            break
            if komunikaty_bledu:
                tekst_bledu = "; ".join(komunikaty_bledu)
                gml_id = str(feat['gml_id']) if 'gml_id' in feat.fields().names() else 'NULL'
                if gml_id != 'NULL': gml_id = f"{gml_id} | {tekst_bledu}"
                feat.setAttribute(layer.fields().indexFromName("gml_id"), gml_id)
                layer.updateFeature(feat)
                obiektyZbledami.append(feat)
        return obiektyZbledami
    except Exception as e:
        print(f"Błąd w funkcji zawieranieOI: {e}")
        return []


def przecinanieRTLW_BUZT(layer):
    try:
        obiektyZbledami = []
        dodane_ids = set()
        valid_layer_name = 'OT_RTLW_L'
        if not layer or not layer.isValid():
            return []
        if not layer.name().endswith(valid_layer_name):
            return []
        buzt_layer = next((l for l in QgsProject.instance().mapLayers().values() if l.name().endswith("OT_BUZT_A")), None)
        if not buzt_layer:
            return []
        buzt_index = QgsSpatialIndex()
        buzt_geometrie = {}
        for feat in buzt_layer.getFeatures():
            geom = feat.geometry()
            if geom and not geom.isEmpty():
                buzt_index.insertFeature(feat)
                buzt_geometrie[feat.id()] = geom
        for feat in layer.getFeatures():
            geom = feat.geometry()
            if not geom or geom.isEmpty():
                continue
            if not feat['kodKarto10k']:
                continue
            candidate_ids = buzt_index.intersects(geom.boundingBox())
            for pid in candidate_ids:
                buzt_geom = buzt_geometrie.get(pid)
                if buzt_geom and (geom.crosses(buzt_geom) or geom.within(buzt_geom)):
                    if feat.id() not in dodane_ids:
                        obiektyZbledami.append(feat)
                        dodane_ids.add(feat.id())
                    break
        return obiektyZbledami
    except Exception as e:
        print(f"Błąd w funkcji przecinanieRTLW_BUZT: {e}")
        return []


def przecinanieRTLW_SK_BUZM(layer):
    try:
        obiektyZbledami = []
        dodane_ids = set()
        valid_layer_name = 'OT_RTLW_L'
        if not layer or not layer.isValid() or not layer.name().endswith(valid_layer_name):
            return []
        warstwy_docelowe = ['OT_SKJZ_L', 'OT_SKDR_L', 'OT_SKTR_L', 'OT_SKRP_L',
                            'OT_BUZM_L', 'OT_SWKN_L', 'OT_SWRS_L', 'OT_SWRM_L']
        indeksy = {}
        for nazwa in warstwy_docelowe:
            w = next((l for l in QgsProject.instance().mapLayers().values() if l.name().endswith(nazwa)), None)
            if w:
                idx = QgsSpatialIndex()
                geometrie = {}
                for f in w.getFeatures():
                    if f.fields().indexOf("polozenie") >= 0:
                        if nazwa.startswith("OT_SK") and f["polozenie"] != "na powierzchni gruntu":
                            continue
                        elif nazwa.startswith("OT_SW") and f["polozenie"] != "na powierzchni":
                            continue
                    g = f.geometry()
                    if g and not g.isEmpty():
                        idx.insertFeature(f)
                        geometrie[f.id()] = g
                indeksy[nazwa] = (idx, geometrie)
        for feat in layer.getFeatures():
            geom = feat.geometry()
            if not geom or geom.isEmpty():
                continue
            rodzaj = str(feat['rodzaj']).strip().lower() if feat['rodzaj'] else ""
            if rodzaj not in ('skarpa', 'wąwóz') or not feat['kodKarto10k']:
                continue
            kolizje = []
            for nazwa, (idx, geometrie) in indeksy.items():
                for pid in idx.intersects(geom.boundingBox()):
                    cel_geom = geometrie.get(pid)
                    if cel_geom and geom.crosses(cel_geom):
                        kolizje.append(nazwa)
                        break
            if kolizje:
                komunikat = f"obiekt typu '{rodzaj}' błędnie przecina " + ", ".join(kolizje)
                gml_val = str(feat['gml_id']) if feat['gml_id'] else 'NULL'
                nowa_wartosc = (gml_val + " | " if gml_val != 'NULL' else "") + komunikat
                feat.setAttribute(layer.fields().indexFromName("gml_id"), nowa_wartosc)
                layer.updateFeature(feat)
                if feat.id() not in dodane_ids:
                    obiektyZbledami.append(feat)
                    dodane_ids.add(feat.id())
        return obiektyZbledami
    except Exception as e:
        print(f"Błąd w funkcji przecinanieRTLW_SK_BUZM: {e}")
        return []


def kodKarto10kNULL(layer):
    obiektyZbledami = []
    try:
        oimka = None
        ptsoa = None
        ptwza = None
        ptgna = None
        if layer.name().__contains__('RTLW_L'):
            oimka=layer.name().replace("RTLW_L","OIMK_A") # Bagno
            if QgsProject().instance().mapLayersByName(oimka):
               oimka = QgsProject().instance().mapLayersByName(oimka)[0]
            ptsoa=layer.name().replace("RTLW_L","PTSO_A")[0] # teren z odpadami komunalnymi i przemysłowymi
            if QgsProject().instance().mapLayersByName(ptsoa):
                ptsoa = QgsProject().instance().mapLayersByName(ptsoa)[0]
            ptwza = layer.name().replace("RTLW_L","PTWZ_A")[0] # zwałowisko, wyrobisko
            if QgsProject().instance().mapLayersByName(ptwza):
                ptwza = QgsProject().instance().mapLayersByName(ptwza)[0]
            ptgna=layer.name().replace("RTLW_L","PTGN_A")
            if  QgsProject().instance().mapLayersByName(ptgna):
                QgsProject().instance().mapLayersByName(ptgna)[0] # teren piaszczysty, żwirowy, kamienisty i rumowisko  skalne
            
        extractbyexpression = processing.run("qgis:extractbyexpression", {
            'INPUT': layer,
            'EXPRESSION': '"rodzaj" in (\'poziomica\') and "kodKarto10k" != \'\'',
            'FAIL_OUTPUT': 'memory:',
            'OUTPUT': 'memory:'
        })
        if isinstance(oimka, QgsVectorLayer): 
            # bufor -0.04 m
            bufor = processing.run("native:buffer", {
                'INPUT': oimka,
                'DISTANCE': -0.04,
                'SEGMENTS': 10,
                'DISSOLVE': False,
                'OUTPUT': 'memory:'
            })
            pojedynczeOIMKA = processing.run("native:multiparttosingleparts", {
                'INPUT': bufor['OUTPUT'],
                'OUTPUT': 'memory:'
            })
            extractBagno = processing.run("qgis:extractbyexpression", {
                'INPUT': pojedynczeOIMKA['OUTPUT'],
                'EXPRESSION': '"rodzaj" in (\'bagno\')',
                'FAIL_OUTPUT': 'memory:',
                'OUTPUT': 'memory:'
            })
            extractbylocation = processing.run("native:extractbylocation", {
                'INPUT': extractbyexpression['OUTPUT'],
                'INTERSECT': extractBagno['OUTPUT'],
                'PREDICATE': [0],
                'OUTPUT': 'memory:'
            })
            if extractbylocation['OUTPUT'].featureCount() > 0:
                for obj in extractbylocation['OUTPUT'].getFeatures():
                    obiektyZbledami.append(obj)
        if isinstance(ptgna, QgsVectorLayer):
            # bufor -0.04 m
            bufor = processing.run("native:buffer", {
                'INPUT': ptgna,
                'DISTANCE': -0.04,
                'SEGMENTS': 10,
                'DISSOLVE': False,
                'OUTPUT': 'memory:'
            })
            pojedynczePTGNA = processing.run("native:multiparttosingleparts", {
                'INPUT': bufor['OUTPUT'],
                'OUTPUT': 'memory:'
            })
            extractGrunt = processing.run("qgis:extractbyexpression", {
                'INPUT': pojedynczePTGNA['OUTPUT'],
                'EXPRESSION': '"rodzaj" in (\'piarg, usypisko lub rumowisko skalne\', \'teren kamienisty\', \'teren piaszczysty lub żwirowy\')',
                'FAIL_OUTPUT': 'memory:',
                'OUTPUT': 'memory:'
            })
            extractbylocation = processing.run("native:extractbylocation", {
                'INPUT': extractbyexpression['OUTPUT'],
                'INTERSECT': extractGrunt['OUTPUT'],
                'PREDICATE': [0],
                'OUTPUT': 'memory:'
            })
            if extractbylocation['OUTPUT'].featureCount() > 0:
                for obj in extractbylocation['OUTPUT'].getFeatures():
                    obiektyZbledami.append(obj)
        if isinstance(ptsoa, QgsVectorLayer):
              # bufor -0.04 m
              bufor = processing.run("native:buffer", {
                  'INPUT': ptsoa,
                  'DISTANCE': -0.04,
                  'SEGMENTS': 10,
                  'DISSOLVE': False,
                  'OUTPUT': 'memory:'
              })
              pojedynczePTSOA = processing.run("native:multiparttosingleparts", {
                  'INPUT': bufor['OUTPUT'],
                  'OUTPUT': 'memory:'
              })
              extractbylocation = processing.run("native:extractbylocation", {
                  'INPUT': extractbyexpression['OUTPUT'],
                  'INTERSECT': pojedynczePTSOA['OUTPUT'],
                  'PREDICATE': [0],
                  'OUTPUT': 'memory:'
              })
              if extractbylocation['OUTPUT'].featureCount() > 0:
                  for obj in extractbylocation['OUTPUT'].getFeatures():
                      obiektyZbledami.append(obj)
        if isinstance(ptwza, QgsVectorLayer):
              # bufor -0.04 m
              bufor = processing.run("native:buffer", {
                  'INPUT': ptwza,
                  'DISTANCE': -0.04,
                  'SEGMENTS': 10,
                  'DISSOLVE': False,
                  'OUTPUT': 'memory:'
              })
              pojedynczePTWZA = processing.run("native:multiparttosingleparts", {
                  'INPUT': bufor['OUTPUT'],
                  'OUTPUT': 'memory:'
              })
              extractbylocation = processing.run("native:extractbylocation", {
                  'INPUT': extractbyexpression['OUTPUT'],
                  'INTERSECT': pojedynczePTWZA['OUTPUT'],
                  'PREDICATE': [0],
                  'OUTPUT': 'memory:'
              })
              if extractbylocation['OUTPUT'].featureCount() > 0:
                  for obj in extractbylocation['OUTPUT'].getFeatures():
                      obiektyZbledami.append(obj)
    except Exception as e:
        print ("błąd w funkcji kodKarto10kNULL: ", e)
    return obiektyZbledami


def blednePolozeniePktWys(layer):
    obiektyZbledami = []
    try:
        bubda = None
        buzta = None
        oiora = None
        buwta = None
        ptnza = None
        ptsoa = None
        ptwpa = None
        ptwza = None
        if layer.name().__contains__('RTPW_P'):
            bubda=layer.name().replace("RTPW_P","BUBD_A")
            if QgsProject().instance().mapLayersByName(bubda):
               bubda= QgsProject().instance().mapLayersByName(bubda)[0]
            buwta=layer.name().replace("RTPW_P","BUWT_A")
            if QgsProject().instance().mapLayersByName(buwta):
                buwta=QgsProject().instance().mapLayersByName(buwta)[0]
            buzta=layer.name().replace("RTPW_P","BUZT_A")
            if QgsProject().instance().mapLayersByName(buzta):
                buzta=QgsProject().instance().mapLayersByName(buzta)[0]
            oiora=layer.name().replace("RTPW_P","OIOR_A")
            if QgsProject().instance().mapLayersByName(oiora):
                oiora=QgsProject().instance().mapLayersByName(oiora)[0]
            ptnza=layer.name().replace("RTPW_P","PTNZ_A")
            if QgsProject().instance().mapLayersByName(ptnza):
                ptnza=QgsProject().instance().mapLayersByName(ptnza)[0]
            ptsoa=layer.name().replace("RTPW_P","PTSO_A")
            if QgsProject().instance().mapLayersByName(ptsoa):
                ptsoa=QgsProject().instance().mapLayersByName(ptsoa)[0]
            ptwpa=layer.name().replace("RTPW_P","PTWP_A")
            if QgsProject().instance().mapLayersByName(ptwpa): 
               ptwpa= QgsProject().instance().mapLayersByName(ptwpa)[0]
            ptwza=layer.name().replace("RTPW_P","PTWZ_A")
            if QgsProject().instance().mapLayersByName(ptwza): 
                ptwza=QgsProject().instance().mapLayersByName(ptwza)[0]
            if isinstance(bubda, QgsVectorLayer):
                # bufor -0.02 m
                bufor = processing.run("native:buffer", {
                    'INPUT': bubda,
                    'DISTANCE': -0.02,
                    'SEGMENTS': 10,
                    'DISSOLVE': False,
                    'OUTPUT': 'memory:'
                })
                pojedynczeBUBDA = processing.run("native:multiparttosingleparts", {
                    'INPUT': bufor['OUTPUT'],
                    'OUTPUT': 'memory:'
                })
                extractbylocation = processing.run("native:extractbylocation", {
                    'INPUT': layer,
                    'INTERSECT': pojedynczeBUBDA['OUTPUT'],
                    'PREDICATE': [0],
                    'OUTPUT': 'memory:'
                })
                if extractbylocation['OUTPUT'].featureCount() > 0:
                    for obj in extractbylocation['OUTPUT'].getFeatures():
                        obiektyZbledami.append(obj)
            if isinstance(buwta, QgsVectorLayer):
                # bufor -0.02 m
                bufor = processing.run("native:buffer", {
                    'INPUT': buwta,
                    'DISTANCE': -0.02,
                    'SEGMENTS': 10,
                    'DISSOLVE': False,
                    'OUTPUT': 'memory:'
                })
                pojedynczeBUBDA = processing.run("native:multiparttosingleparts", {
                    'INPUT': bufor['OUTPUT'],
                    'OUTPUT': 'memory:'
                })
                extractbylocation = processing.run("native:extractbylocation", {
                    'INPUT': layer,
                    'INTERSECT': pojedynczeBUBDA['OUTPUT'],
                    'PREDICATE': [0],
                    'OUTPUT': 'memory:'
                })
                if extractbylocation['OUTPUT'].featureCount() > 0:
                    for obj in extractbylocation['OUTPUT'].getFeatures():
                        obiektyZbledami.append(obj)
            if isinstance(buzta, QgsVectorLayer):
                # bufor -0.02 m
                bufor = processing.run("native:buffer", {
                    'INPUT': buzta,
                    'DISTANCE': -0.02,
                    'SEGMENTS': 10,
                    'DISSOLVE': False,
                    'OUTPUT': 'memory:'
                })
                pojedynczeBUZTA = processing.run("native:multiparttosingleparts", {
                    'INPUT': bufor['OUTPUT'],
                    'OUTPUT': 'memory:'
                })
                extractbylocation = processing.run("native:extractbylocation", {
                    'INPUT': layer,
                    'INTERSECT': pojedynczeBUZTA['OUTPUT'],
                    'PREDICATE': [0],
                    'OUTPUT': 'memory:'
                })
                if extractbylocation['OUTPUT'].featureCount() > 0:
                    for obj in extractbylocation['OUTPUT'].getFeatures():
                        obiektyZbledami.append(obj)
            if isinstance(oiora, QgsVectorLayer):
                 # bufor -0.02 m
                 bufor = processing.run("native:buffer", {
                     'INPUT': oiora,
                     'DISTANCE': -0.02,
                     'SEGMENTS': 10,
                     'DISSOLVE': False,
                     'OUTPUT': 'memory:'
                 })
                 pojedynczeOIORA = processing.run("native:multiparttosingleparts", {
                     'INPUT': bufor['OUTPUT'],
                     'OUTPUT': 'memory:'
                 })
                 extractWiata = processing.run("qgis:extractbyexpression", {
                     'INPUT': pojedynczeOIORA['OUTPUT'],
                     'EXPRESSION': '"rodzaj" in (\'wiata lub altana\')',
                     'FAIL_OUTPUT': 'memory:',
                     'OUTPUT': 'memory:'
                 })
                 extractbylocation = processing.run("native:extractbylocation", {
                     'INPUT': layer, 
                     'INTERSECT': extractWiata['OUTPUT'],
                     'PREDICATE': [0],
                     'OUTPUT': 'memory:'
                 })
                 if extractbylocation['OUTPUT'].featureCount() > 0:
                     for obj in extractbylocation['OUTPUT'].getFeatures():
                        obiektyZbledami.append(obj)
            if isinstance(ptnza, QgsVectorLayer):
                # bufor -0.02 m
                bufor = processing.run("native:buffer", {
                    'INPUT': ptnza,
                    'DISTANCE': -0.02,
                    'SEGMENTS': 10,
                    'DISSOLVE': False,
                    'OUTPUT': 'memory:'
                })
                pojedynczePTNZA = processing.run("native:multiparttosingleparts", {
                    'INPUT': bufor['OUTPUT'],
                    'OUTPUT': 'memory:'
                })
                extractbylocation = processing.run("native:extractbylocation", {
                    'INPUT': layer,
                    'INTERSECT': pojedynczePTNZA['OUTPUT'],
                    'PREDICATE': [0],
                    'OUTPUT': 'memory:'
                })
                if extractbylocation['OUTPUT'].featureCount() > 0:
                    for obj in extractbylocation['OUTPUT'].getFeatures():
                        obiektyZbledami.append(obj)
            if isinstance(ptsoa, QgsVectorLayer):
                # bufor -0.02 m
                bufor = processing.run("native:buffer", {
                    'INPUT': ptsoa,
                    'DISTANCE': -0.02,
                    'SEGMENTS': 10,
                    'DISSOLVE': False,
                    'OUTPUT': 'memory:'
                })
                pojedynczePTSOA = processing.run("native:multiparttosingleparts", {
                    'INPUT': bufor['OUTPUT'],
                    'OUTPUT': 'memory:'
                })
                extractbylocation = processing.run("native:extractbylocation", {
                    'INPUT': layer, 
                    'INTERSECT': pojedynczePTSOA['OUTPUT'],
                    'PREDICATE': [0],
                    'OUTPUT': 'memory:'
                })
                if extractbylocation['OUTPUT'].featureCount() > 0:
                    for obj in extractbylocation['OUTPUT'].getFeatures():
                        obiektyZbledami.append(obj)
            if isinstance(ptwpa, QgsVectorLayer):
                # bufor -0.02 m
                bufor = processing.run("native:buffer", {
                    'INPUT': ptwpa,
                    'DISTANCE': -0.02,
                    'SEGMENTS': 10,
                    'DISSOLVE': False,
                    'OUTPUT': 'memory:'
                })
                pojedynczePTWPA = processing.run("native:multiparttosingleparts", {
                    'INPUT': bufor['OUTPUT'],
                    'OUTPUT': 'memory:'
                })
                extractbylocation = processing.run("native:extractbylocation", {
                    'INPUT': layer, 
                    'INTERSECT': pojedynczePTWPA['OUTPUT'],
                    'PREDICATE': [0],
                    'OUTPUT': 'memory:'
                })
                if extractbylocation['OUTPUT'].featureCount() > 0:
                    for obj in extractbylocation['OUTPUT'].getFeatures():
                        obiektyZbledami.append(obj)
            if isinstance(ptwza, QgsVectorLayer):
                # bufor -0.02 m
                bufor = processing.run("native:buffer", {
                    'INPUT': ptwza,
                    'DISTANCE': -0.02,
                    'SEGMENTS': 10,
                    'DISSOLVE': False,
                    'OUTPUT': 'memory:'
                })
                pojedynczePTWZA = processing.run("native:multiparttosingleparts", {
                    'INPUT': bufor['OUTPUT'],
                    'OUTPUT': 'memory:'
                })
                extractbylocation = processing.run("native:extractbylocation", {
                    'INPUT': layer, 
                    'INTERSECT': pojedynczePTWZA['OUTPUT'],
                    'PREDICATE': [0],
                    'OUTPUT': 'memory:'
                })
                if extractbylocation['OUTPUT'].featureCount() > 0:
                    for obj in extractbylocation['OUTPUT'].getFeatures():
                        obiektyZbledami.append(obj)
    except Exception as e:
        print (f"błąd w  funkcji blednePolozeniePktWys: ", e)
    return obiektyZbledami


def kontrolaKodKarto10k219_1(layer):
    try:
        obiektyZbledami = []
        dodane_bledy_ids = set()  # Analiza unikalnych Id obiektów błędnych
        
        if not layer.isValid():
            return []
        
        # Wyszukiwanie warstw OT_SKTR_L i OT_SKJZ_L
        sktr_layer_name = layer.name().replace("OT_BUIN_L", "OT_SKTR_L")
        skjz_layer_name = layer.name().replace("OT_BUIN_L", "OT_SKJZ_L")
        
        sktr_layers = QgsProject.instance().mapLayersByName(sktr_layer_name)
        skjz_layers = QgsProject.instance().mapLayersByName(skjz_layer_name)
        
        if not sktr_layers or not skjz_layers:
            return []
        
        sktr = sktr_layers[0]
        skjz = skjz_layers[0]
        
        # Tworzenie indeksów przestrzennych
        index_buin = QgsSpatialIndex(layer.getFeatures())
        index_sktr = QgsSpatialIndex(sktr.getFeatures())
        index_skjz = QgsSpatialIndex(skjz.getFeatures())
        
        # Bufor granicy
        granica = adjaMinus2cmBufor(layer)
        
        # Filtrowanie warstwy BUIN_L według kodu
        extract_params = {
            'INPUT': layer,
            'EXPRESSION': '"kodKarto10k" = \'0010_219_1\'',
            'OUTPUT': 'memory:'
        }
        extract_result = processing.run("qgis:extractbyexpression", extract_params)
        filtered_layer = extract_result['OUTPUT']
        
        # Filtrowanie obiektów według 'rodzaj' oraz kontrola długości
        for obj in filtered_layer.getFeatures():
            
            # Sprawdzanie, czy rodzaj jest poprawny
            if obj['rodzaj'] != 'tunel':
                print(f"-> Niewłaściwy rodzaj: {obj['rodzaj']}")
                obiektyZbledami.append(obj)
                continue
            
            # Kontrola długości obiektu BUIN_L
            geom = obj.geometry()
            obj_length = geom.length()
            
            if obj_length < 25:
                # Sprawdzanie, czy obiekt dotyka granicy
                if not any(obj.geometry().intersects(boundary.geometry()) for boundary in granica.getFeatures()):
                    if obj.id() not in dodane_bledy_ids:
                        obiektyZbledami.append(obj)
                        dodane_bledy_ids.add(obj.id())
                    continue  # Odrzucenie obiektu, jeśli nie styka się z granicą
                    
            # Tworzenie bufora dla geometrii obiektu BUIN_L
            buffer_distance = 5  # Odległość bufora w metrach
            buffered_geometry = geom.buffer(buffer_distance, 5)  # Bufor 5 m z zaokrągleniem 5 segmentów
            
            # Sprawdzenie obiektów SKTR w buforze
            nearby_sktr_ids = index_sktr.intersects(buffered_geometry.boundingBox())
            nearby_sktr = [sktr.getFeature(fid) for fid in nearby_sktr_ids]
            
            # Weryfikacja atrybutu 'położenie' w obiektach SKTR
            sktr_valid_positions = []
            sktr_invalid_positions = []  # Lista obiektów SKTR, które mają błędny lub brakujący atrybut 'polozenie'
            for sktr_obj in nearby_sktr:
                try:
                    if sktr_obj['polozenie'] == 'na powierzchni gruntu':
                        sktr_valid_positions.append(sktr_obj)
                    else:
                        sktr_invalid_positions.append(sktr_obj)  # Obiekt SKTR ma niewłaściwe położenie
                except KeyError:
                    sktr_invalid_positions.append(sktr_obj)  # Obiekt SKTR nie ma atrybutu 'polozenie'
                    
            # Sprawdzenie obiektów SKJZ w buforze
            nearby_skjz_ids = index_skjz.intersects(buffered_geometry.boundingBox())
            nearby_skjz = [skjz.getFeature(fid) for fid in nearby_skjz_ids]
            
            # Logika decyzji
            if len(sktr_valid_positions) > 0:
                continue
            
            if len(nearby_sktr) > 0 and len(nearby_skjz) == 0:
                continue
            
            # Jeśli w buforze znajdują się tylko obiekty SKTR z błędnym lub brakującym atrybutem 'polozenie'
            if len(sktr_invalid_positions) == len(nearby_sktr):
                continue
            
            # Jeśli żaden obiekt SKTR nie spełnia warunku
            if obj.id() not in dodane_bledy_ids:
                obiektyZbledami.append(obj)
                dodane_bledy_ids.add(obj.id())
        return obiektyZbledami
    except Exception as e:
        print (f"funkcja kontrolaKodKarto10k219_1 nie zadziała poprawnie z powodu błędu {e}. Zostanie zwrócona pusta tablica")
        return []


def kontrolaKodKarto10k219_2(layer):
    try:
        obiektyZbledami = []
        dodane_bledy_ids = set()  # Analiza unikalnych Id obiektów błędnych
        
        if not layer.isValid():
            return []
        
        # Wyszukiwanie warstw OT_SKTR_L i OT_SKJZ_L
        sktr_layer_name = layer.name().replace("OT_BUIN_L", "OT_SKTR_L")
        skjz_layer_name = layer.name().replace("OT_BUIN_L", "OT_SKJZ_L")
        
        sktr_layers = QgsProject.instance().mapLayersByName(sktr_layer_name)
        skjz_layers = QgsProject.instance().mapLayersByName(skjz_layer_name)
        
        if not sktr_layers or not skjz_layers:
            return []
        
        sktr = sktr_layers[0]
        skjz = skjz_layers[0]
        
        # Tworzenie indeksów przestrzennych
        index_buin = QgsSpatialIndex(layer.getFeatures())
        index_sktr = QgsSpatialIndex(sktr.getFeatures())
        index_skjz = QgsSpatialIndex(skjz.getFeatures())
        
        # Filtrowanie warstwy BUIN_L według kodu
        extract_params = {
            'INPUT': layer,
            'EXPRESSION': '"kodKarto10k" = \'0010_219_2\'',
            'OUTPUT': 'memory:'
        }
        extract_result = processing.run("qgis:extractbyexpression", extract_params)
        filtered_layer = extract_result['OUTPUT']
        
        # Filtrowanie obiektów według 'rodzaj' oraz kontrola długości
        for obj in filtered_layer.getFeatures():
            
            # Sprawdzanie, czy rodzaj jest poprawny
            if obj['rodzaj'] != 'tunel':
                obiektyZbledami.append(obj)
                continue
            
            # Kontrola długości obiektu BUIN_L
            geom = obj.geometry()
            obj_length = geom.length()
            
            if obj_length >= 25:
                if obj.id() not in dodane_bledy_ids:
                    obiektyZbledami.append(obj)
                    dodane_bledy_ids.add(obj.id())
                continue  # Odrzucenie obiektu z dalszej analizy, jeśli długość >= 25
                
            # Tworzenie bufora dla geometrii obiektu BUIN_L
            buffer_distance = 5  # Odległość bufora w metrach
            buffered_geometry = geom.buffer(buffer_distance, 5)  # Bufor 5 m z zaokrągleniem 5 segmentów
            
            # Sprawdzenie obiektów SKTR w buforze
            nearby_sktr_ids = index_sktr.intersects(buffered_geometry.boundingBox())
            nearby_sktr = [sktr.getFeature(fid) for fid in nearby_sktr_ids]
            
            # Weryfikacja atrybutu 'położenie' w obiektach SKTR
            sktr_valid_positions = []
            sktr_invalid_positions = []  # Lista obiektów SKTR, które mają błędny lub brakujący atrybut 'polozenie'
            for sktr_obj in nearby_sktr:
                try:
                    if sktr_obj['polozenie'] == 'na powierzchni gruntu':
                        sktr_valid_positions.append(sktr_obj)
                    else:
                        sktr_invalid_positions.append(sktr_obj)  # Obiekt SKTR ma niewłaściwe położenie
                except KeyError:
                    sktr_invalid_positions.append(sktr_obj)  # Obiekt SKTR nie ma atrybutu 'polozenie'
                    
            # Sprawdzenie obiektów SKJZ w buforze
            nearby_skjz_ids = index_skjz.intersects(buffered_geometry.boundingBox())
            nearby_skjz = [skjz.getFeature(fid) for fid in nearby_skjz_ids]
            
            # Logika decyzji
            if len(sktr_valid_positions) > 0:
                continue
                
            if len(nearby_sktr) > 0 and len(nearby_skjz) == 0:
                continue
                
            # Jeśli w buforze znajdują się tylko obiekty SKTR z błędnym lub brakującym atrybutem 'polozenie'
            if len(sktr_invalid_positions) == len(nearby_sktr):
                continue
                
            # Jeśli żaden obiekt SKTR nie spełnia warunku
            if obj.id() not in dodane_bledy_ids:
                obiektyZbledami.append(obj)
                dodane_bledy_ids.add(obj.id())
                
        return obiektyZbledami
    
    except Exception as e:
        print (f"funkcja kontrolaKodKarto10k219_2 nie zadziała poprawnie z powodu błędu {e}. Zostanie zwrócona pusta tablica")
        return []


def kontrolaKodKarto10k220_1(layer):
    try:
        obiektyZbledami = []
        dodane_bledy_ids = set()
        
        if not layer.isValid():
            return []
        
        # Wyszukiwanie warstw OT_SKTR_L i OT_SKJZ_L
        sktr_layer_name = layer.name().replace("OT_BUIN_L", "OT_SKTR_L")
        skjz_layer_name = layer.name().replace("OT_BUIN_L", "OT_SKJZ_L")
        
        sktr_layers = QgsProject.instance().mapLayersByName(sktr_layer_name)
        skjz_layers = QgsProject.instance().mapLayersByName(skjz_layer_name)
        
        if not sktr_layers or not skjz_layers:
            return []
        
        sktr = sktr_layers[0]
        skjz = skjz_layers[0]
        
        # Tworzenie indeksów przestrzennych
        index_buin = QgsSpatialIndex(layer.getFeatures())
        index_sktr = QgsSpatialIndex(sktr.getFeatures())
        index_skjz = QgsSpatialIndex(skjz.getFeatures())
        
        # Bufor granicy
        granica = adjaMinus2cmBufor(layer)
        
        # Filtrowanie warstwy BUIN_L według kodu
        extract_params = {
            'INPUT': layer,
            'EXPRESSION': '"kodKarto10k" = \'0010_220_1\'',
            'OUTPUT': 'memory:'
        }
        extract_result = processing.run("qgis:extractbyexpression", extract_params)
        filtered_layer = extract_result['OUTPUT']
        filtered_features = list(filtered_layer.getFeatures())
        
        if len(filtered_features) == 0:
            return []
        
        # Filtrowanie obiektów według 'rodzaj' oraz kontrola długości i styku z granicą
        for obj in filtered_features:
            
            if obj['rodzaj'] not in ['estakada', 'wiadukt', 'most']:
                obiektyZbledami.append(obj)
                continue
                
            # Kontrola długości obiektu BUIN_L
            geom = obj.geometry()
            obj_length = geom.length()
            
            # Warunki długości i styku z granicą
            if obj_length < 10:
                # Sprawdzanie, czy obiekt dotyka granicy
                if not any(geom.intersects(boundary.geometry()) for boundary in granica.getFeatures()):
                    if obj.id() not in dodane_bledy_ids:
                        obiektyZbledami.append(obj)
                        dodane_bledy_ids.add(obj.id())
                    continue
                    
            # Tworzenie bufora dla geometrii obiektu BUIN_L
            buffer_distance = 5  # Odległość bufora w metrach
            buffered_geometry = geom.buffer(buffer_distance, 5)
            
            # Sprawdzenie obiektów SKTR w buforze
            nearby_sktr_ids = index_sktr.intersects(buffered_geometry.boundingBox())
            nearby_sktr = [sktr.getFeature(fid) for fid in nearby_sktr_ids]
            
            # Weryfikacja atrybutu 'położenie' w obiektach SKTR
            sktr_valid_positions = []
            sktr_invalid_positions = []
            for sktr_obj in nearby_sktr:
                try:
                    if sktr_obj['polozenie'] == 'na powierzchni gruntu':
                        sktr_valid_positions.append(sktr_obj)
                    else:
                        sktr_invalid_positions.append(sktr_obj)
                except KeyError:
                    sktr_invalid_positions.append(sktr_obj)
                    
            # Sprawdzenie obiektów SKJZ w buforze
            nearby_skjz_ids = index_skjz.intersects(buffered_geometry.boundingBox())
            nearby_skjz = [skjz.getFeature(fid) for fid in nearby_skjz_ids]
            
            # Logika decyzji
            if len(sktr_valid_positions) > 0:
                continue
                
            if len(nearby_sktr) > 0 and len(nearby_skjz) == 0:
                continue
                
            if len(sktr_invalid_positions) == len(nearby_sktr):
                continue
                
            if obj.id() not in dodane_bledy_ids:
                obiektyZbledami.append(obj)
                dodane_bledy_ids.add(obj.id())
                
        return obiektyZbledami
    except Exception as e:
        print (f"funkcja kontrolaKodKarto10k220_1 nie zadziała poprawnie z powodu błędu {e}. Zostanie zwrócona pusta tablica")
        return []


def kontrolaKodKarto10k220_2(layer):
    try:
        obiektyZbledami = []
        dodane_bledy_ids = set()
        
        if not layer.isValid():
            return []
        
        sktr_layer_name = layer.name().replace("OT_BUIN_L", "OT_SKTR_L")
        skjz_layer_name = layer.name().replace("OT_BUIN_L", "OT_SKJZ_L")
        
        sktr_layers = QgsProject.instance().mapLayersByName(sktr_layer_name)
        skjz_layers = QgsProject.instance().mapLayersByName(skjz_layer_name)
        
        if not sktr_layers or not skjz_layers:
            return []
        
        sktr = sktr_layers[0]
        skjz = skjz_layers[0]
        
        index_buin = QgsSpatialIndex(layer.getFeatures())
        index_sktr = QgsSpatialIndex(sktr.getFeatures())
        index_skjz = QgsSpatialIndex(skjz.getFeatures())
        
        granica = adjaMinus2cmBufor(layer)
        
        extract_params = {
            'INPUT': layer,
            'EXPRESSION': '"kodKarto10k" = \'0010_220_2\'',
            'OUTPUT': 'memory:'
        }
        extract_result = processing.run("qgis:extractbyexpression", extract_params)
        filtered_layer = extract_result['OUTPUT']
        filtered_features = list(filtered_layer.getFeatures())
        
        if len(filtered_features) == 0:
            return []
        
        for obj in filtered_features:
            if obj['rodzaj'] not in ['estakada', 'wiadukt', 'most']:
                obiektyZbledami.append(obj)
                continue
            
            geom = obj.geometry()
            obj_length = geom.length()
            
            buffer_distance = 5 
            buffered_geometry = geom.buffer(buffer_distance, 5)
            
            nearby_sktr_ids = index_sktr.intersects(buffered_geometry.boundingBox())
            nearby_sktr = [sktr.getFeature(fid) for fid in nearby_sktr_ids]
            
            nearby_skjz_ids = index_skjz.intersects(buffered_geometry.boundingBox())
            nearby_skjz = [skjz.getFeature(fid) for fid in nearby_skjz_ids]
            
            # Jeśli obiekt nie styka się z żadnym SKTR
            if len(nearby_sktr) == 0:
                if obj.id() not in dodane_bledy_ids:
                    obiektyZbledami.append(obj)
                    dodane_bledy_ids.add(obj.id())
                continue
            
            # Jeśli BUIN_L ma tylko SKTR w sąsiedztwie
            if len(nearby_sktr) > 0 and len(nearby_skjz) == 0:
                if 3 <= obj_length < 10:
                    continue
                
                if obj_length < 3:
                    if not any(obj.geometry().intersects(boundary.geometry()) for boundary in granica.getFeatures()):
                        if obj.id() not in dodane_bledy_ids:
                            obiektyZbledami.append(obj)
                            dodane_bledy_ids.add(obj.id())
                elif obj_length >= 10:
                    if obj.id() not in dodane_bledy_ids:
                        obiektyZbledami.append(obj)
                        dodane_bledy_ids.add(obj.id())
                continue
            
            sktr_valid_positions = []
            sktr_invalid_positions = []
            for sktr_obj in nearby_sktr:
                try:
                    if sktr_obj['polozenie'] == 'na powierzchni gruntu':
                        sktr_valid_positions.append(sktr_obj)
                    else:
                        sktr_invalid_positions.append(sktr_obj)
                except KeyError:
                    sktr_invalid_positions.append(sktr_obj)
                    
            if len(sktr_valid_positions) > 0:
                continue
            
            if len(sktr_invalid_positions) == len(nearby_sktr):
                continue
            
            if obj.id() not in dodane_bledy_ids:
                obiektyZbledami.append(obj)
                dodane_bledy_ids.add(obj.id())
                
        return obiektyZbledami
    except Exception as e:
        print (f"funkcja kontrolaKodKarto10k220_2 nie zadziała poprawnie z powodu błędu {e}. Zostanie zwrócona pusta tablica")
        return []


def kontrolaKodKarto10k131_1(layer):
    try:
        if not layer.isValid():
            return []
        
        obiektyZbledami = []
        dodane_bledy_ids = set()
        skjz_layer_name = layer.name().replace("OT_BUIN_L", "OT_SKJZ_L")
        sktr_layer_name = layer.name().replace("OT_BUIN_L", "OT_SKTR_L")
        skjz_layers = QgsProject.instance().mapLayersByName(skjz_layer_name)
        sktr_layers = QgsProject.instance().mapLayersByName(sktr_layer_name)
        
        if not skjz_layers or not sktr_layers:
            return []
        skjz = skjz_layers[0]
        sktr = sktr_layers[0]
        skjz_features = {f.id(): f for f in skjz.getFeatures()}
        sktr_features = {f.id(): f for f in sktr.getFeatures()}
        index_skjz = QgsSpatialIndex()
        for f in skjz_features.values():
            index_skjz.insertFeature(f)
        index_sktr = QgsSpatialIndex()
        for f in sktr_features.values():
            index_sktr.insertFeature(f)
        granica_features = list(adjaMinus2cmBufor(layer).getFeatures())
        if not granica_features:
            return []
        granica_geoms = [g.geometry() for g in granica_features]
        extract_params = {
            'INPUT': layer,
            'EXPRESSION': '"kodKarto10k" = \'0010_131_1\'',
            'OUTPUT': 'memory:'
        }
        extract_result = processing.run("qgis:extractbyexpression", extract_params)
        filtered_features = list(extract_result['OUTPUT'].getFeatures())
        if not filtered_features:
            return []
        for obj in filtered_features:
            obj_id = obj.id()
            if obj_id in dodane_bledy_ids:
                continue
            if obj['rodzaj'] != 'tunel':
                obiektyZbledami.append(obj)
                dodane_bledy_ids.add(obj_id)
                continue
            geom = obj.geometry()
            if geom is None or geom.isEmpty():
                continue
            if geom.length() < 25:
                if not any(geom.intersects(gr_geom) for gr_geom in granica_geoms):
                    obiektyZbledami.append(obj)
                    dodane_bledy_ids.add(obj_id)
                    continue
            buffered_geom = geom.buffer(5, 5)
            if buffered_geom is None or buffered_geom.isEmpty():
                continue
            bbox = buffered_geom.boundingBox()
            nearby_skjz_ids = index_skjz.intersects(bbox)
            nearby_sktr_ids = index_sktr.intersects(bbox)
            nearby_skjz = [
                skjz_features[fid]
                for fid in nearby_skjz_ids
                if skjz_features[fid].geometry().intersects(buffered_geom)
            ]
            nearby_sktr = [
                sktr_features[fid]
                for fid in nearby_sktr_ids
                if sktr_features[fid].geometry().intersects(buffered_geom)
            ]
            skjz_valid = []
            skjz_invalid = []
            for f in nearby_skjz:
                try:
                    polozenie = f['polozenie']
                    if polozenie == 'na powierzchni gruntu':
                        skjz_valid.append(f)
                    else:
                        skjz_invalid.append(f)
                except KeyError:
                    skjz_invalid.append(f)
            if skjz_valid:
                continue
            if nearby_skjz and not nearby_sktr:
                continue
            if len(skjz_invalid) == len(nearby_skjz):
                continue
            obiektyZbledami.append(obj)
            dodane_bledy_ids.add(obj_id)
        return obiektyZbledami
    except Exception as e:
        print(f"funkcja kontrolaKodKarto10k131_1 nie zadziała poprawnie z powodu błędu {e}. Zostanie zwrócona pusta tablica")
        return []


def kontrolaKodKarto10k131_2(layer):
    try:
        obiektyZbledami = []
        dodane_bledy_ids = set()
        if not layer.isValid():
            return []
        sktr_layer_name = layer.name().replace("OT_BUIN_L", "OT_SKTR_L")
        skjz_layer_name = layer.name().replace("OT_BUIN_L", "OT_SKJZ_L")
        sktr_layers = QgsProject.instance().mapLayersByName(sktr_layer_name)
        skjz_layers = QgsProject.instance().mapLayersByName(skjz_layer_name)
        if not sktr_layers or not skjz_layers:
            return []
        sktr = sktr_layers[0]
        skjz = skjz_layers[0]
        index_buin = QgsSpatialIndex(layer.getFeatures())
        index_sktr = QgsSpatialIndex(sktr.getFeatures())
        index_skjz = QgsSpatialIndex(skjz.getFeatures())
        extract_params = {
            'INPUT': layer,
            'EXPRESSION': '"kodKarto10k" = \'0010_131_2\'',
            'OUTPUT': 'memory:'
        }
        extract_result = processing.run("qgis:extractbyexpression", extract_params)
        filtered_layer = extract_result['OUTPUT']
        for obj in filtered_layer.getFeatures():
            if obj['rodzaj'] != 'tunel':
                obiektyZbledami.append(obj)
                continue
            geom = obj.geometry()
            obj_length = geom.length()
            
            if obj_length >= 25:
                if obj.id() not in dodane_bledy_ids:
                    obiektyZbledami.append(obj)
                    dodane_bledy_ids.add(obj.id())
                continue
            buffer_distance = 5
            buffered_geometry = geom.buffer(buffer_distance, 5)
            nearby_skjz_ids = index_skjz.intersects(buffered_geometry.boundingBox())
            nearby_skjz = [skjz.getFeature(fid) for fid in nearby_skjz_ids]
            skjz_valid_positions = []
            skjz_invalid_positions = []
            for skjz_obj in nearby_skjz:
                try:
                    if skjz_obj['polozenie'] == 'na powierzchni gruntu':
                        skjz_valid_positions.append(skjz_obj)
                    else:
                        skjz_invalid_positions.append(skjz_obj)
                except KeyError:
                    skjz_invalid_positions.append(skjz_obj)
            nearby_sktr_ids = index_sktr.intersects(buffered_geometry.boundingBox())
            nearby_sktr = [sktr.getFeature(fid) for fid in nearby_sktr_ids]
            if len(skjz_valid_positions) > 0:
                continue
            if len(nearby_skjz) > 0 and len(nearby_sktr) == 0:
                continue
            if len(skjz_invalid_positions) == len(nearby_skjz):
                continue
            if obj.id() not in dodane_bledy_ids:
                obiektyZbledami.append(obj)
                dodane_bledy_ids.add(obj.id())
        return obiektyZbledami
    except Exception as e:
        print (f"funkcja kontrolaKodKarto10k131_2 nie zadziała poprawnie z powodu błędu {e}. Zostanie zwrócona pusta tablica")
        return []


def kontrolaKodKarto10k133_1(layer):
    try:
        if not layer.isValid():
            return []
        obiektyZbledami = []
        dodane_bledy_ids = set()
        skjz_layer_name = layer.name().replace("OT_BUIN_L", "OT_SKJZ_L")
        sktr_layer_name = layer.name().replace("OT_BUIN_L", "OT_SKTR_L")
        skjz_layers = QgsProject.instance().mapLayersByName(skjz_layer_name)
        sktr_layers = QgsProject.instance().mapLayersByName(sktr_layer_name)
        if not skjz_layers or not sktr_layers:
            return []
        skjz = skjz_layers[0]
        sktr = sktr_layers[0]
        skjz_features = {f.id(): f for f in skjz.getFeatures()}
        sktr_features = {f.id(): f for f in sktr.getFeatures()}
        index_skjz = QgsSpatialIndex()
        for f in skjz_features.values():
            index_skjz.insertFeature(f)
        index_sktr = QgsSpatialIndex()
        for f in sktr_features.values():
            index_sktr.insertFeature(f)
        granica_features = list(adjaMinus2cmBufor(layer).getFeatures())
        if not granica_features:
            return []
        granica_geoms = [g.geometry() for g in granica_features]
        extract_params = {
            'INPUT': layer,
            'EXPRESSION': '"kodKarto10k" = \'0010_133_1\'',
            'OUTPUT': 'memory:'
        }
        extract_result = processing.run("qgis:extractbyexpression", extract_params)
        filtered_features = list(extract_result['OUTPUT'].getFeatures())
        if not filtered_features:
            return []
        for obj in filtered_features:
            obj_id = obj.id()
            if obj_id in dodane_bledy_ids:
                continue
            rodzaj = obj['rodzaj']
            if rodzaj not in ['estakada', 'wiadukt', 'most']:
                obiektyZbledami.append(obj)
                dodane_bledy_ids.add(obj_id)
                continue
            geom = obj.geometry()
            if geom is None or geom.isEmpty():
                continue
            if geom.length() < 9.99:
                if not any(geom.intersects(g) for g in granica_geoms):
                    obiektyZbledami.append(obj)
                    dodane_bledy_ids.add(obj_id)
                    continue
            buffered_geom = geom.buffer(5, 5)
            if buffered_geom is None or buffered_geom.isEmpty():
                continue
            bbox = buffered_geom.boundingBox()
            nearby_skjz_ids = index_skjz.intersects(bbox)
            nearby_sktr_ids = index_sktr.intersects(bbox)
            nearby_skjz = [
                skjz_features[fid]
                for fid in nearby_skjz_ids
                if skjz_features[fid].geometry().intersects(buffered_geom)
            ]
            nearby_sktr = [
                sktr_features[fid]
                for fid in nearby_sktr_ids
                if sktr_features[fid].geometry().intersects(buffered_geom)
            ]
            skjz_valid = []
            skjz_invalid = []
            for f in nearby_skjz:
                try:
                    polozenie = f['polozenie']
                    if polozenie == 'na powierzchni gruntu':
                        skjz_valid.append(f)
                    else:
                        skjz_invalid.append(f)
                except KeyError:
                    skjz_invalid.append(f)
            if skjz_valid:
                continue
            if nearby_skjz and not nearby_sktr:
                continue
            if len(skjz_invalid) == len(nearby_skjz):
                continue
            obiektyZbledami.append(obj)
            dodane_bledy_ids.add(obj_id)
        return obiektyZbledami
    except Exception as e:
        print(f"funkcja kontrolaKodKarto10k133_1 nie zadziała poprawnie z powodu błędu {e}. Zostanie zwrócona pusta tablica")
        return []


def kontrolaKodKarto10k133_2(layer):
    try:
        obiektyZbledami = []
        dodane_bledy_ids = set()
        
        if not layer.isValid():
            return []
        
        skjz_layer_name = layer.name().replace("OT_BUIN_L", "OT_SKJZ_L")
        sktr_layer_name = layer.name().replace("OT_BUIN_L", "OT_SKTR_L")
        
        skjz_layers = QgsProject.instance().mapLayersByName(skjz_layer_name)
        sktr_layers = QgsProject.instance().mapLayersByName(sktr_layer_name)
        
        if not skjz_layers or not sktr_layers:
            return []
        
        skjz = skjz_layers[0]
        sktr = sktr_layers[0]
        
        index_buin = QgsSpatialIndex(layer.getFeatures())
        index_skjz = QgsSpatialIndex(skjz.getFeatures())
        index_sktr = QgsSpatialIndex(sktr.getFeatures())
        
        granica = adjaMinus2cmBufor(layer)
        distance_threshold = 10
        
        extract_params = {
            'INPUT': layer,
            'EXPRESSION': '"kodKarto10k" = \'0010_133_2\'',
            'OUTPUT': 'memory:'
        }
        extract_result = processing.run("qgis:extractbyexpression", extract_params)
        filtered_layer = extract_result['OUTPUT']
        
        for obj in filtered_layer.getFeatures():
            if obj.id() in dodane_bledy_ids:
                continue  # Jeśli obiekt już dodano, pomijamy dalsze sprawdzenia
            
            if obj['rodzaj'] not in ['estakada', 'wiadukt', 'most']:
                obiektyZbledami.append(obj)
                dodane_bledy_ids.add(obj.id())
                continue
            
            obj_length = obj.geometry().length()
            obj_centroid = obj.geometry().centroid()
            
            nearby_skjz_ids = []
            nearby_sktr_ids = []
            
            for skjz_obj in skjz.getFeatures():
                if obj_centroid.distance(skjz_obj.geometry().centroid()) <= distance_threshold:
                    nearby_skjz_ids.append(skjz_obj.id())
                    
            for sktr_obj in sktr.getFeatures():
                if obj_centroid.distance(sktr_obj.geometry().centroid()) <= distance_threshold:
                    nearby_sktr_ids.append(sktr_obj.id())
                    
            if len(nearby_skjz_ids) > 0 and len(nearby_sktr_ids) == 0:
                if 3 <= obj_length < 10:
                    continue
                    
                if obj_length < 3:
                    if not any(obj.geometry().intersects(boundary.geometry()) for boundary in granica.getFeatures()):
                        obiektyZbledami.append(obj)
                        dodane_bledy_ids.add(obj.id())
                elif obj_length >= 10:
                    obiektyZbledami.append(obj)
                    dodane_bledy_ids.add(obj.id())
                
                if 3 <= obj_length < 10:
                    for skjz_obj in skjz.getFeatures():
                        if obj.geometry().distance(skjz_obj.geometry()) < distance_threshold:
                            if skjz_obj['polozenie'] is None or skjz_obj['polozenie'] == 'na powierzchni gruntu':
                                obiektyZbledami.append(obj)
                                dodane_bledy_ids.add(obj.id())
                                break
                        
            elif len(nearby_sktr_ids) > 0 and len(nearby_skjz_ids) == 0:
                obiektyZbledami.append(obj)
                dodane_bledy_ids.add(obj.id())
                
            else:
                for sktr_obj in sktr.getFeatures():
                    if obj.geometry().distance(sktr_obj.geometry()) < distance_threshold:
                        polozenie = sktr_obj['polozenie']
                        if polozenie is None or polozenie.strip().lower() != 'na powierzchni gruntu':
                            obiektyZbledami.append(obj)
                            dodane_bledy_ids.add(obj.id())
                            break
        
        return obiektyZbledami
    
    except Exception as e:
        print (f"funkcja kontrolaKodKarto10k133_2 nie zadziała poprawnie z powodu błędu {e}. Zostanie zwrócona pusta tablica")
        return []


def kontrolaKodKarto10k134_1(layer):
    try:
        obiektyZbledami = []
        granica = adjaMinus2cmBufor(layer)
        for obj in layer.getFeatures():
            try:
                if obj["kodKarto10k"] == '0010_134_1':
                    if obj['rodzaj'] != 'kładka':
                        obiektyZbledami.append(obj)
                        continue
                    geom = obj.geometry()
                    touches_boundary = any(geom.intersects(boundary.geometry()) for boundary in granica.getFeatures())
                    if not touches_boundary:
                        if not (geom.length() >= 10):
                            obiektyZbledami.append(obj)
            except Exception as e:
                 print ("błąd w obliczaniu kodu karto 0010_134_1:", e)
        return obiektyZbledami
    
    except Exception as x:
        print (f'funkcja kontrolaKodKarto10k134_1 nie zadziałała poprawnie z powodu błędu {x}. Zostanie zwrócona pusta tablica')
        return []


def kontrolaKodKarto10k134_2(layer):
    try:
        obiektyZbledami = []
        granica = adjaMinus2cmBufor(layer)
        for obj in layer.getFeatures():
            try:
                if obj["kodKarto10k"] == '0010_134_2':
                    if obj['rodzaj'] != 'kładka':
                        obiektyZbledami.append(obj)
                        continue
                    geom = obj.geometry()
                    touches_boundary = any(obj.geometry().intersects(boundary.geometry()) for boundary in granica.getFeatures())
                    if not touches_boundary:
                        if geom.length() < 3 or geom.length() > 10:
                            obiektyZbledami.append(obj)
            except Exception as e:
                 print ("błąd w obliczaniu kodu karto 0010_134_2:", e)
        return obiektyZbledami
        
    except Exception as x:
        print (f'funkcja kontrolaKodKarto10k134_2 nie zadziałała poprawnie z powodu błędu {x}. Zostanie zwrócona pusta tablica')
        return []


def kontrolaKodKarto10k140(layer):
    try:
        obiektyZbledami = []
        dozwolone_klasy = ['OT_PTKM_A', 'OT_PTPL_A', 'OT_PTZB_A']
        klasa = layer.name()[-9:]
        if klasa not in dozwolone_klasy:
            return []
        wszystkie_warstwy = QgsProject.instance().mapLayers().values()
        kuko_layer = None
        for lyr in wszystkie_warstwy:
            if lyr.name().endswith("OT_KUKO_A"):
                kuko_layer = lyr
                break
        if klasa == "OT_PTKM_A" and kuko_layer:
            index_kuko = QgsSpatialIndex()
            kuko_dict = {}
            for f in kuko_layer.getFeatures():
                geom = f.geometry()
                if geom and not geom.isEmpty():
                    index_kuko.insertFeature(f)
                    kuko_dict[f.id()] = f
        for f in layer.getFeatures():
            try:
                kod = str(f["kodKarto10k"]).strip()
                if klasa == "OT_PTKM_A" and kuko_layer:
                    geom = f.geometry()
                    if not geom or geom.isEmpty():
                        continue
                    candidate_ids = index_kuko.intersects(geom.boundingBox())
                    for cid in candidate_ids:
                        kuko_feat = kuko_dict.get(cid)
                        if kuko_feat is None:
                            continue
                        geom_kuko = kuko_feat.geometry()
                        rodzaj = str(kuko_feat["rodzaj"]).strip().lower()
                        if rodzaj in ["lotnisko lub lądowisko"]:
                            if geom.within(geom_kuko):
                                if kod != "0010_140":
                                    obiektyZbledami.append(f)
                                break
                elif klasa == "OT_PTPL_A":
                    naw = str(f["materialNawierzchni"]).strip().lower()
                    if naw not in ["grunt naturalny", "inny"]:
                        if kod != "0010_140":
                            obiektyZbledami.append(f)
                elif klasa == "OT_PTZB_A":
                    ros = str(f["roslinnosc"]).strip().lower()
                    if ros == "brak – plac twardy":
                        if kod != "0010_140":
                            obiektyZbledami.append(f)
            except Exception:
                pass
        return obiektyZbledami
    except Exception as e:
        print(f"Błąd w kontroli kodKarto10k140: {e}")
        return []


def kontrolaKodKarto10k638_1(layer):
    try:
        obiektyZbledami = []
        granica = adjaMinus2cmBufor(layer)
        for obj in layer.getFeatures():
            try:
                if obj["kodKarto10k"] == '0010_638_1':
                    if obj['rodzaj'] != 'akwedukt':
                        obiektyZbledami.append(obj)
                        continue
                    geom = obj.geometry()
                    touches_boundary = any(obj.geometry().intersects(boundary.geometry()) for boundary in granica.getFeatures())
                    if not touches_boundary:
                        if not (geom.length() >= 10):
                            obiektyZbledami.append(obj)
            except Exception as e:
                 print ("błąd w obliczaniu kodu karto 0010_638_1:", e)
        return obiektyZbledami
        
    except Exception as x:
        print (f'funkcja kontrolaKodKarto10k638_1 nie zadziałała poprawnie z powodu błędu {x}. Zostanie zwrócona pusta tablica')
        return []


def kontrolaKodKarto10k638_2(layer):
    try:
        obiektyZbledami = []
        granica = adjaMinus2cmBufor(layer)
        for obj in layer.getFeatures():
           try:
               if obj["kodKarto10k"] == '0010_638_2':
                   if obj['rodzaj'] != 'akwedukt':
                       obiektyZbledami.append(obj)
                       continue
                   geom = obj.geometry()
                   touches_boundary = any(obj.geometry().intersects(boundary.geometry()) for boundary in granica.getFeatures())
                   
                   if not touches_boundary:
                       if not (geom.length() < 10):
                           obiektyZbledami.append(obj)
           except Exception as e:
                print ("błąd w obliczaniu kodu karto 0010_638_2:", e)
        return obiektyZbledami
        
    except Exception as x:
        print (f'funkcja kontrolaKodKarto10k638_2 nie zadziałała poprawnie z powodu błędu {x}. Zostanie zwrócona pusta tablica')
        return []


global lokalneIdWRamachKlas
lokalneIdWRamachKlas = {}

def unikalnoscLokalnyIdWPliku(layer, plikGML):
    obiektyZbledami = []
    
    ns = {'gml':'http://www.opengis.net/gml/3.2', 'ot':'urn:gugik:specyfikacje:gmlas:bazaDanychObiektowTopograficznych10k:2.0'}
    lokalnyIds_elem = plikGML.getroot().findall(".//ot:lokalnyId", ns)
    lokalnyIds = []
    
    for lokalnyId in lokalnyIds_elem:
        lokalnyIds.append(lokalnyId.text)
    
    unikalne = set()
    zdublowane = set()
    zdublowaneWRamachKlas = {}
    
    for element in lokalnyIds:
        if element in unikalne:
            zdublowane.add(element)
        else:
            unikalne.add(element)
    
    for element in unikalne:
        if element in lokalneIdWRamachKlas:
            zdublowaneWRamachKlas[element] = layer.name()
        else:
            lokalneIdWRamachKlas[element] = layer.name()
    
    zdublowane_lista = list(zdublowane)
    zdublowaneWRamachKlas_lista = list(zdublowaneWRamachKlas.keys())
    
    for obj in layer.getFeatures():
        if obj['lokalnyId'] in zdublowane_lista:
            gml_id = obj['gml_id'] + '| w ramach tej samej klasy'
            obj.setAttribute(layer.fields().indexFromName("gml_id"), gml_id)
            layer.updateFeature(obj)
            obiektyZbledami.append(obj)
            layer.commitChanges()
    
    for obj in layer.getFeatures():
        if obj['lokalnyId'] in zdublowaneWRamachKlas_lista:
            gml_id = obj['gml_id'] + '| w ramach klasy: ' + str(lokalneIdWRamachKlas[obj['lokalnyId']])
            obj.setAttribute(layer.fields().indexFromName("gml_id"), gml_id)
            layer.updateFeature(obj)
            obiektyZbledami.append(obj)
            layer.commitChanges()
    
    return obiektyZbledami


def kontrolaRelacjiDzialkaEwidencyjnaDoPunktGraniczny(layer):
    obiektyZbledami = []
    
    try:
        PunktGranicyDzialkiEwidencyjnej_layer = QgsProject().instance().mapLayersByName(layer.name().replace("DzialkaEwidencyjna","PunktGraniczny"))[0]
    except:
        PunktGranicyDzialkiEwidencyjnej_layer = None
    
    fields =  layer.fields()
    
    for obj in layer.getFeatures():
         jestBlad = False
         
         if 'punktGranicyDzialki_href' in [field.name() for field in fields] and isinstance(obj['punktGranicyDzialki_href'], list):
            if len(obj['punktGranicyDzialki_href']) < 3:
                jestBlad = True
         else:
            jestBlad = True
        
         if jestBlad:
            gml_id = obj['gml_id'] + '| brak min. 3 referencji na punkty graniczne'
            obj.setAttribute(layer.fields().indexFromName("gml_id"), gml_id)
            layer.updateFeature(obj)
            obiektyZbledami.append(obj)
            layer.commitChanges()
    
    if 'punktGranicyDzialki_href' in [field.name() for field in fields]:
        extractbyexpression = processing.run("qgis:extractbyexpression", {
            'INPUT': layer,
            'EXPRESSION': "'punktGranicyDzialki_href' IS NOT NULL",
            'FAIL_OUTPUT': 'memory:',
            'OUTPUT': 'memory:'
        })
    else:
        return obiektyZbledami
    
    if extractbyexpression['OUTPUT'].featureCount() > 0 and layer.featureCount() > 0:
        punktyGranicyDzialki_hrefy = set()
        
        gmlid_PunktyGraniczne = set()
        if PunktGranicyDzialkiEwidencyjnej_layer != None:
            for obj_PG in PunktGranicyDzialkiEwidencyjnej_layer.getFeatures():
                gmlid_PunktyGraniczne.add(obj_PG['gml_id'])
        
        for obj in extractbyexpression['OUTPUT'].getFeatures():
            gml_id = ''
            if isinstance(obj['punktGranicyDzialki_href'], list):
                for gmlid in obj['punktGranicyDzialki_href']:
                    if gmlid == '':
                        gml_id += ' pusta referencja na punkt graniczny;'
                    else:
                        punktyGranicyDzialki_hrefy.add(gmlid)
                        if not gmlid in gmlid_PunktyGraniczne:
                            gml_id += 'referencja "' + gmlid + '" na punkt graniczny, którego nie ma w pliku gml;'
            else:
                if obj['punktGranicyDzialki_href'] != NULL:
                    punktyGranicyDzialki_hrefy.add(obj['punktGranicyDzialki_href'])
            
            if gml_id != '':
                gml_id = obj['gml_id'] + '| ' + gml_id
                obj.setAttribute(layer.fields().indexFromName("gml_id"), gml_id)
                layer.updateFeature(obj)
                obiektyZbledami.append(obj)
                layer.commitChanges()
    
    return obiektyZbledami


    def kontrolaRelacjiGESRzedna(layer):
        obiektyZbledami = []
        
        warstwyRelacji = ['GES_UrzadzenieZwiazaneZPrzewodami',
                          'GES_PrzewodWodociagowy',
                          'GES_Przewod',
                          'GES_UrzadzeniaTowarzyszczaceLiniowe',
                          'GES_InneUrzadzeniaTowarzyszace',
                          'GES_PrzewodKanalizacyjny',
                          'GES_PrzewodElektroenergetyczny',
                          'GES_PrzewodGazowy',
                          'GES_PrzewodCieplowniczy',
                          'GES_PrzewodTelekomunikacyjny',
                          'GES_PrzewodSpecjalny',
                          'GES_PrzewodNiezidentyfikowany',
                          'GES_UrzadzeniaSiecWodociagowa',
                          'GES_UrzadzeniaSiecKanalizacyjna',
                          'GES_UrzadzeniaSiecElektroenergetyczna',
                          'GES_UrzadzeniaSiecCieplownicza',
                          'GES_UrzadzeniaSiecTelekomunikacyjna',
                          'GES_UrzadzeniaTechniczneSieciSpecjalnej',
                          'GES_UrzadzenieNiezidentyfikowane',
                          'GES_UrzadzeniaSiecGazowa'
                          ]
        
        wartosci = []   # Inicjalizacja pustej listy na wartości
        
        for warstwa in warstwyRelacji:
            try:
                Rel_Obj_layer = QgsProject().instance().mapLayersByName(layer.name().replace("GES_Rzedna", warstwa))[0]
            except:
                continue
            
            fields = Rel_Obj_layer.fields()
            
            for obj in Rel_Obj_layer.getFeatures():
                if 'rzednaObiektu_href' in [field.name() for field in fields]:
                    if isinstance(obj['rzednaObiektu_href'], list):
                        for element in obj['rzednaObiektu_href']:
                            if isinstance(element, str):
                                wartosci.extend([val.replace("#", "") for val in element.split(',')])
                    else:
                        wartosci.append(str(obj['rzednaObiektu_href']).replace("#", ""))
                        
        for f in layer.getFeatures():
            gml_id = f['gml_id']
            if gml_id not in wartosci:
                obiektyZbledami.append(f)
        
        return obiektyZbledami


def zapisWspolrzednychKonturow(layer, plikGML):
    obiektyZbledami = []
    pattern = re.compile(r"[0-9]{6}\.[0-9]{3,}")
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'gr': 'urn:gugik:specyfikacje:gmlas:mapaGlebowoRolnicza:1.0'}
    konturyGlebowe = plikGML.findall('.//gr:GR_KonturGlebowy', namespaces=ns)
    for konturGlebowy in konturyGlebowe:
            lokalnyId = konturGlebowy.find('.//gr:lokalnyId', namespaces=ns).text
            expression = f"\"lokalnyId\" = '{lokalnyId}'"
            request = QgsFeatureRequest().setFilterExpression(expression)
            geometria = konturGlebowy.findall('.//gr:geometria', namespaces=ns)
            for g in geometria:
                geom = g.findall('.//gml:Polygon', namespaces=ns)
                for e in geom:
                    ex = e.findall('.//gml:exterior', namespaces=ns)
                    for f in ex:
                        liner = f.findall('.//gml:LinearRing', namespaces=ns)
                        for l in liner:
                            posList = l.find('.//gml:posList', namespaces=ns).text
                            if pattern.search(posList):
                                    for feature in layer.getFeatures(request):
                                        obiektyZbledami.append(feature)
    
    return obiektyZbledami


def zapisWspolrzednychOdkrywek(layer, plikGML):
    obiektyZbledami = []
    pattern = re.compile(r"[0-9]{6}\.[0-9]{3,}")
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'gr': 'urn:gugik:specyfikacje:gmlas:mapaGlebowoRolnicza:1.0'}
    odkrywkiGlebowe = plikGML.findall('.//gr:GR_OdkrywkaGlebowa', namespaces=ns)
    for odkrywkaGlebowa in odkrywkiGlebowe:
            lokalnyId = odkrywkaGlebowa.find('.//gr:lokalnyId', namespaces=ns).text
            expression = f"\"lokalnyId\" = '{lokalnyId}'"
            request = QgsFeatureRequest().setFilterExpression(expression)
            geometria = odkrywkaGlebowa.findall('.//gr:geometria', namespaces=ns)
            for g in geometria:
                geom = g.findall('.//gml:Point', namespaces=ns)
                for e in geom:
                    pos = e.find('.//gml:pos', namespaces=ns).text
                    if pattern.search(pos):
                        for feature in layer.getFeatures(request):
                            obiektyZbledami.append(feature)
    
    return obiektyZbledami


def kontrolaGeometriiGML_luki(layer, plikGML, klasa):
    obiektyZbledami = set()
    global gml_id_set
    gml_id_set = set()
    nieobslugiwanyTypGeometrii = QgsVectorLayer("Point?crs=epsg:2180&field=gml_id:string(254)", "Geometrie o nieobsługiwanym typie", "memory")
    
    ns = {'gml':'http://www.opengis.net/gml/3.2',
          'ot':'bazaDanychObiektowTopograficznych500:1.0',
          'ges':'geodezyjnaEwidencjaSieciUzbrojeniaTerenu:1.0',
          'egb':'ewidencjaGruntowIBudynkow:1.0'
          }
    
    if 'OT_' in klasa:
        klasy = plikGML.getroot().findall(".//ot:" + klasa, ns)
    elif 'EGB_' in klasa:
        klasy = plikGML.getroot().findall(".//egb:" + klasa, ns)
    else:
        klasy = plikGML.getroot().findall(".//ges:" + klasa, ns)
    
    for klasa in klasy:
        gml_id = klasa.attrib.get("{http://www.opengis.net/gml/3.2}id")
        
        for curve in klasa.findall(".//gml:Curve", ns):
            unusual_segments = {}
            for segment in curve.findall(".//*", ns):
                # ArcByCenterPoint, ArcString, Arc, ArcStringByBulge, ArcByBulge
                # CircleByCenterPoint, Circle
                if 'Arc' in segment.tag.split('}')[-1] or 'Circle' in segment.tag.split('}')[-1]:
                    gml_id_set.add(gml_id)
                    break
    
    nieobslugiwanyTypGeometrii.startEditing()
    for gmlid in gml_id_set:
        nowyRekord = QgsFeature(nieobslugiwanyTypGeometrii.fields())
        nowyRekord.setAttribute(0, gmlid)
        nowyRekord.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(0, 0)))
        nieobslugiwanyTypGeometrii.addFeature(nowyRekord)
        nieobslugiwanyTypGeometrii.commitChanges()
        obiektyZbledami.add(nowyRekord)
    
    del nieobslugiwanyTypGeometrii
    
    return obiektyZbledami