# -*- coding: utf-8 -*-
"""
/***************************************************************************
 walidatorPlikowGML
                                 A QGIS plugin
 Walidator plików GML baz BDOT10k, PRNG, GESUT, EGiB, BDOT500
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-12-23
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Marcin Lebiecki - Główny Urząd Geodezji i Kartografii
        email                : marcin.lebiecki@gugik.gov.pl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.core import *
from qgis.PyQt.QtCore import *
from qgis import processing
from qgis.PyQt.QtWidgets import *
import pathlib
import configparser
import sys
import re


def findDuplicates(layer):
    duplicates = []
    unique = []
    isFirstUnique = True
    # Tworzenie indeksu przestrzennego
    spatial_index = QgsSpatialIndex()
    mapa_id_do_feature = {}
    for feature in layer.getFeatures():
       spatial_index.addFeature(feature)
       mapa_id_do_feature[feature.id()] = feature
    for feature in layer.getFeatures():
        potential_duplicates = spatial_index.intersects(feature.geometry().boundingBox())
        isDuplicate = False
        for idx in potential_duplicates:
           if feature.id() != idx:
       # Pobierz obiekt z listy unikatów na podstawie identyfikatora
               feature_potencjalne = mapa_id_do_feature.get(idx)
               if feature_potencjalne and feature.geometry().isGeosEqual(feature_potencjalne.geometry()):
                   isDuplicate = True
           if isDuplicate:
               duplicates.append(feature)
           else:
               unique.append(feature)
    return duplicates


def validateGeometry(layer):
    obiektyZbledami = []
    wynik = processing.run("qgis:checkvalidity", {
        'INPUT_LAYER': layer,
        'METHOD': 2,
        'INVALID_OUTPUT': 'memory:',
        'ERROR_OUTPUT': 'memory:'
    })
    obiektyZbledami = wynik['INVALID_OUTPUT'].getFeatures()
    
    return obiektyZbledami


def minimalnaPowierzchnia(layer):
    minPowWarstwy = {"OT_PTWP_A":80, "OT_PTZB_A":1000, "OT_PTLZ_A":500, "OT_PTRK_A":1000,"OT_PTUT_A":1000,"OT_PTGN_A":1000, "OT_PTSO_A":1000, "OT_PTWZ_A":1000, "OT_PTNZ_A":1000, "OT_BUWT_A":100, "OT_BUZT_A":175, "OT_KUSK_A":3000, "OT_KUHO_A":3000, "OT_KUHU_A":3000, "OT_KUOS_A":3000, "OT_KUOZ_A":3000, "OT_KUZA_A":3000}
    obiektyZbledami = []
    klasa = layer.name()[-9:]
    ADJA_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace(klasa,"OT_ADJA_A"))[0]
    invalid_layer = processing.run("qgis:checkvalidity", {'INPUT_LAYER': ADJA_A_layer, 'METHOD': 0, 'IGNORE_RING_SELF_INTERSECTION': True, 'VALID_OUTPUT': 'memory:', 'INVALID_OUTPUT': 'memory:', 'ERROR_OUTPUT': 'memory:'})
    # zawiera warstwę z niepoprawnymi geometriami
    if invalid_layer['INVALID_OUTPUT']:
              ADJA_A_layer = processing.run("native:fixgeometries", {'INPUT': ADJA_A_layer,'OUTPUT': 'memory:'})['OUTPUT']
    outputs = processing.run('native:dissolve', {'INPUT': ADJA_A_layer,'SEPARATE_DISJOINT': False,'OUTPUT': 'memory:'})['OUTPUT']
    granica = processing.run("native:polygonstolines", {'INPUT': outputs,'OUTPUT': 'memory:'})['OUTPUT'] # zamiana poligonu na linie
    for feature in layer.getFeatures():
        geom = feature.geometry()
        if geom.area() < minPowWarstwy[klasa]:
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(feature)
    return obiektyZbledami


def minimalnaPTRKwzgledemPTLZ(layer):
    obiektyZbledami = []
    ADJA_A_layer = None
    PTRK_A_layer = None
    PTLZ_A_layer = None
    if layer.name()[-6:] == 'PTRK_A':
        ADJA_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_PTRK_A","OT_ADJA_A"))[0]
        PTLZ_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_PTRK_A","OT_PTLZ_A"))[0]
        PTRK_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    identyfikatory_bledow = set()
    invalid_layer = processing.run("qgis:checkvalidity", {'INPUT_LAYER': ADJA_A_layer, 'METHOD': 0, 'IGNORE_RING_SELF_INTERSECTION': True, 'VALID_OUTPUT': 'memory:', 'INVALID_OUTPUT': 'memory:', 'ERROR_OUTPUT': 'memory:'})
    # zawiera warstwę z niepoprawnymi geometriami
    if invalid_layer['INVALID_OUTPUT']:
              params = {'INPUT': ADJA_A_layer,'OUTPUT': 'memory:'}
              # Wykonanie naprawy geometrii
              naprawiona= processing.run("native:fixgeometries", params)['OUTPUT']
              ADJA_A_layer = naprawiona # usunięcie granic wewnątrz warstwy ADJA
    alg_params = {'INPUT': ADJA_A_layer,'SEPARATE_DISJOINT': False,'OUTPUT': 'memory:'}
    outputs = processing.run('native:dissolve', alg_params)['OUTPUT']
    params = {'INPUT': outputs,'OUTPUT': 'memory:'}# To zapisuje wynik w pamięci, bez tworzenia fizycznej warstwy
    granica = processing.run("native:polygonstolines", params)['OUTPUT'] # zamiana poligonu na linie
    for PTRK_A_feature in PTRK_A_layer.getFeatures():
        for PTLZ_A_feature in PTLZ_A_layer.getFeatures():
            geom1 = PTRK_A_feature.geometry()
            geom2 = PTLZ_A_feature.geometry()
            if geom1.area() < 2000 and PTRK_A_feature.attribute('rodzaj') == 'krzewy':
                styka = False
                for g in granica.getFeatures():
                    if geom1.intersects(geom2) and not geom1.intersects(g.geometry()) and PTRK_A_feature.id() not in identyfikatory_bledow:
                        styka = True
                        obiektyZbledami.append(PTRK_A_feature)
                        identyfikatory_bledow.add(PTRK_A_feature.id())
    
    return obiektyZbledami


def minimalnaPTTRronda(layer):
    obiektyZbledami = []
    ADJA_A_layer = None
    PTTR_A_layer = None
    
    if layer.name().__contains__('OT_SKRW_P'):
        ADJA_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_SKRW_P","OT_ADJA_A"))[0]
        PTTR_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_SKRW_P","OT_PTTR_A"))[0]
        
    identyfikatory_bledow = set()
    invalid_layer = processing.run("qgis:checkvalidity", {'INPUT_LAYER': ADJA_A_layer, 'METHOD': 0, 'IGNORE_RING_SELF_INTERSECTION': True, 'VALID_OUTPUT': 'memory:', 'INVALID_OUTPUT': 'memory:', 'ERROR_OUTPUT': 'memory:'})
    # zawiera warstwę z niepoprawnymi geometriami
    if invalid_layer['INVALID_OUTPUT']:
              params = {'INPUT': ADJA_A_layer,'OUTPUT': 'memory:'} # Wykonanie naprawy geometrii
              naprawiona = processing.run("native:fixgeometries", params)['OUTPUT']
              ADJA_A_layer = naprawiona
    alg_params = {'INPUT': ADJA_A_layer,'SEPARATE_DISJOINT': False,'OUTPUT': 'memory:'} # usunięcie granic wewnątrz warstwy ADJA
    outputs = processing.run('native:dissolve', alg_params)['OUTPUT']
    params = {'INPUT': outputs,'OUTPUT': 'memory:'} # To zapisuje wynik w pamięci, bez tworzenia fizycznej warstwy
    granica = processing.run("native:polygonstolines", params)['OUTPUT'] # zamiana poligonu na linie
    index_SKRW_P = QgsSpatialIndex()
    index_granica = QgsSpatialIndex()
    selected_ids = []
    for feature in granica.getFeatures():
        index_granica.insertFeature(feature)
    for SKRW_P_feature in layer.getFeatures():
        if SKRW_P_feature['rodzaj'] != 'rondo':
            index_SKRW_P.insertFeature(SKRW_P_feature)
    for PTTR_A_feature in PTTR_A_layer.getFeatures():
        geom1 = PTTR_A_feature.geometry()
        if geom1.area() < 1000:
            intersects_SKRW_P = any(geom1.intersects(layer.getFeature(fid).geometry()) for fid in index_SKRW_P.intersects(geom1.boundingBox()))
            touches_boundary = any(geom1.intersects(granica.getFeature(fid).geometry()) for fid in index_granica.intersects(geom1.boundingBox()))
            if not intersects_SKRW_P and not touches_boundary and PTTR_A_feature.id() not in identyfikatory_bledow:
                obiektyZbledami.append(PTTR_A_feature)
                identyfikatory_bledow.add(PTTR_A_feature.id())
    
    return obiektyZbledami


def minimalnaPTPL(layer):
    obiektyZbledami = []
    ADJA_A_layer = None
    if layer.name()[-6:] == 'PTPL_A':
        ADJA_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_PTPL_A","OT_ADJA_A"))[0]
    invalid_layer = processing.run("qgis:checkvalidity", {'INPUT_LAYER': ADJA_A_layer, 'METHOD': 0, 'IGNORE_RING_SELF_INTERSECTION': True, 'VALID_OUTPUT': 'memory:', 'INVALID_OUTPUT': 'memory:', 'ERROR_OUTPUT': 'memory:'})
    # zawiera warstwę z niepoprawnymi geometriami
    if invalid_layer['INVALID_OUTPUT']:
              params = {'INPUT': ADJA_A_layer,'OUTPUT': 'memory:'}
              # Wykonanie naprawy geometrii
              naprawiona= processing.run("native:fixgeometries", params)['OUTPUT']
              ADJA_A_layer = naprawiona
    alg_params = {'INPUT': ADJA_A_layer,'SEPARATE_DISJOINT': False,'OUTPUT': 'memory:'} # usunięcie granic wewnątrz warstwy ADJA
    outputs = processing.run('native:dissolve', alg_params)['OUTPUT']
    params = {'INPUT': outputs,'OUTPUT': 'memory:'} # To zapisuje wynik w pamięci, bez tworzenia fizycznej warstwy
    granica = processing.run("native:polygonstolines", params)['OUTPUT'] # zamiana poligonu na linie
    for PTPL_A_feature in layer.getFeatures():
        geom = PTPL_A_feature.geometry()
        if geom.area() < 1000 and not 'placNazwa1' in PTPL_A_feature.fields().names():
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(PTPL_A_feature)
    
    return obiektyZbledami


def minPowierzchniaPTPLzKUPG(layer):
    obiektyZbledami = []
    ADJA_A_layer = None
    PTPL_A_layer = None
    KUPG_A_layer = None
    if layer.name()[-6:] == 'PTPL_A':
        ADJA_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_PTPL_A","OT_ADJA_A"))[0]
        KUPG_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_PTPL_A","OT_KUPG_A"))[0]
        PTPL_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    invalid_layer = processing.run("qgis:checkvalidity", {'INPUT_LAYER': ADJA_A_layer, 'METHOD': 0, 'IGNORE_RING_SELF_INTERSECTION': True, 'VALID_OUTPUT': 'memory:', 'INVALID_OUTPUT': 'memory:', 'ERROR_OUTPUT': 'memory:'})
    # zawiera warstwę z niepoprawnymi geometriami
    if invalid_layer['INVALID_OUTPUT']:
              params = {'INPUT': ADJA_A_layer, 'OUTPUT': 'memory:'}
          # Wykonanie naprawy geometrii
              naprawiona= processing.run("native:fixgeometries", params)['OUTPUT']
              ADJA_A_layer = naprawiona
    alg_params = {'INPUT': ADJA_A_layer,'SEPARATE_DISJOINT': False,'OUTPUT': 'memory:'} # usunięcie granic wewnątrz warstwy ADJA
    outputs = processing.run('native:dissolve', alg_params)['OUTPUT']
    params = {'INPUT': outputs, 'OUTPUT': 'memory:'} # To zapisuje wynik w pamięci, bez tworzenia fizycznej warstwy
    granica = processing.run("native:polygonstolines", params)['OUTPUT'] # zamiana poligonu na linie
    for PTPL_A_feature in PTPL_A_layer.getFeatures():
        for KUPG_A_feature in KUPG_A_layer.getFeatures():
            geom1 = PTPL_A_feature.geometry()
            geom2 = KUPG_A_feature.geometry()
            if geom2.area() < 3000:
                styka = False
                for g in granica.getFeatures():
                    if geom1.intersects(geom2) and not geom1.intersects(g.geometry()):
                        styka = True
                        obiektyZbledami.append(PTPL_A_feature)
    
    return obiektyZbledami


def minimalnaBUIT(layer):
    obiektyZbledami = []
    ADJA_A_layer = None
    BUIT_A_layer = None
    if layer.name()[-6:] == 'BUIT_A':
        ADJA_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_BUIT_A","OT_ADJA_A"))[0]
        BUIT_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    invalid_layer = processing.run("qgis:checkvalidity", {'INPUT_LAYER': ADJA_A_layer, 'METHOD': 0, 'IGNORE_RING_SELF_INTERSECTION': True, 'VALID_OUTPUT': 'memory:', 'INVALID_OUTPUT': 'memory:', 'ERROR_OUTPUT': 'memory:'})
    # zawiera warstwę z niepoprawnymi geometriami
    if invalid_layer['INVALID_OUTPUT']:
              params = {'INPUT': ADJA_A_layer,'OUTPUT': 'memory:'} # Wykonanie naprawy geometrii
              naprawiona= processing.run("native:fixgeometries", params)['OUTPUT']
              ADJA_A_layer = naprawiona
    alg_params = {'INPUT': ADJA_A_layer,'SEPARATE_DISJOINT': False,'OUTPUT': 'memory:'} # usunięcie granic wewnątrz warstwy ADJA
    outputs = processing.run('native:dissolve', alg_params)['OUTPUT']
    params = {'INPUT': outputs,'OUTPUT': 'memory:'} # To zapisuje wynik w pamięci, bez tworzenia fizycznej warstwy
    granica = processing.run("native:polygonstolines", params)['OUTPUT'] # zamiana poligonu na linie
    for BUIT_A_feature in BUIT_A_layer.getFeatures():
        geom = BUIT_A_feature.geometry()
        if geom.area() < 1000 and BUIT_A_feature['rodzaj'] in ['zespół dystrybutorów paliwa', 'zespół transformatorów']:
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(BUIT_A_feature)
    
    return obiektyZbledami


def minimalnaKUPG(layer):
    obiektyZbledami = []
    ADJA_A_layer = None
    KUPG_A_layer = None
    if layer.name()[-6:] == 'KUPG_A':
        ADJA_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_KUPG_A","OT_ADJA_A"))[0]
        KUPG_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    invalid_layer = processing.run("qgis:checkvalidity", {'INPUT_LAYER': ADJA_A_layer, 'METHOD': 0, 'IGNORE_RING_SELF_INTERSECTION': True, 'VALID_OUTPUT': 'memory:', 'INVALID_OUTPUT': 'memory:', 'ERROR_OUTPUT': 'memory:'})
    # zawiera warstwę z niepoprawnymi geometriami
    if invalid_layer['INVALID_OUTPUT']:
              params = {'INPUT': ADJA_A_layer,'OUTPUT': 'memory:'}
          # Wykonanie naprawy geometrii
              naprawiona= processing.run("native:fixgeometries", params)['OUTPUT']
              ADJA_A_layer = naprawiona
    alg_params = {'INPUT': ADJA_A_layer,'SEPARATE_DISJOINT': False,'OUTPUT': 'memory:'} # usunięcie granic wewnątrz warstwy ADJA
    outputs = processing.run('native:dissolve', alg_params)['OUTPUT']
    params = {'INPUT': outputs,'OUTPUT': 'memory:'} # To zapisuje wynik w pamięci, bez tworzenia fizycznej warstwy
    granica = processing.run("native:polygonstolines", params)['OUTPUT'] # zamiana poligonu na linie
    for KUPG_A_feature in KUPG_A_layer.getFeatures():
        geom = KUPG_A_feature.geometry()
        if geom.area() < 3000 and KUPG_A_feature['rodzaj'] not in ['oczyszczalnia ścieków', 'podstacja elektroenergetyczna']:
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(KUPG_A_feature)
    
    return obiektyZbledami


def minimalnaKUKO(layer):
    obiektyZbledami = []
    ADJA_A_layer = None
    KUKO_A_layer = None
    if layer.name()[-6:] == 'KUKO_A':
        ADJA_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_KUKO_A","OT_ADJA_A"))[0]
        KUKO_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    invalid_layer = processing.run("qgis:checkvalidity", {'INPUT_LAYER': ADJA_A_layer, 'METHOD': 0, 'IGNORE_RING_SELF_INTERSECTION': True, 'VALID_OUTPUT': 'memory:', 'INVALID_OUTPUT': 'memory:', 'ERROR_OUTPUT': 'memory:'})
    # zawiera warstwę z niepoprawnymi geometriami
    if invalid_layer['INVALID_OUTPUT']:
              params = {'INPUT': ADJA_A_layer,'OUTPUT': 'memory:'} # Wykonanie naprawy geometrii
              naprawiona= processing.run("native:fixgeometries", params)['OUTPUT']
              ADJA_A_layer = naprawiona
    alg_params = {'INPUT': ADJA_A_layer,'SEPARATE_DISJOINT': False,'OUTPUT': 'memory:'} # usunięcie granic wewnątrz warstwy ADJA
    outputs = processing.run('native:dissolve', alg_params)['OUTPUT']
    params = {'INPUT': outputs,'OUTPUT': 'memory:'} # To zapisuje wynik w pamięci, bez tworzenia fizycznej warstwy
    granica = processing.run("native:polygonstolines", params)['OUTPUT'] # zamiana poligonu na linie
    for KUKO_A_feature in KUKO_A_layer.getFeatures():
        geom = KUKO_A_feature.geometry()
        if geom.area() < 3000 and KUKO_A_feature['rodzaj'] != 'stacja paliw':
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(KUKO_A_feature)
    
    return obiektyZbledami


def minimalnaKUSC(layer):
    obiektyZbledami = []
    ADJA_A_layer = None
    KUSC_A_layer = None
    if layer.name()[-6:] == 'KUSC_A':
        ADJA_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_KUSC_A","OT_ADJA_A"))[0]
        KUSC_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    invalid_layer = processing.run("qgis:checkvalidity", {'INPUT_LAYER': ADJA_A_layer, 'METHOD': 0, 'IGNORE_RING_SELF_INTERSECTION': True, 'VALID_OUTPUT': 'memory:', 'INVALID_OUTPUT': 'memory:', 'ERROR_OUTPUT': 'memory:'})
    # zawiera warstwę z niepoprawnymi geometriami
    if invalid_layer['INVALID_OUTPUT']:
              params = {'INPUT': ADJA_A_layer, 'OUTPUT': 'memory:'} # Wykonanie naprawy geometrii
              naprawiona= processing.run("native:fixgeometries", params)['OUTPUT']
              ADJA_A_layer = naprawiona
    alg_params = {'INPUT': ADJA_A_layer, 'SEPARATE_DISJOINT': False, 'OUTPUT': 'memory:'} # usunięcie granic wewnątrz warstwy ADJA
    outputs = processing.run('native:dissolve', alg_params)['OUTPUT']
    params = {'INPUT': outputs,'OUTPUT': 'memory:'} # To zapisuje wynik w pamięci, bez tworzenia fizycznej warstwy
    granica = processing.run("native:polygonstolines", params)['OUTPUT'] # zamiana poligonu na linie
    for KUSC_A_feature in KUSC_A_layer.getFeatures():
        geom = KUSC_A_feature.geometry()
        if geom.area() < 5000 and KUSC_A_feature['rodzaj'] == 'zespół sakralny lub klasztorny':
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(KUSC_A_feature)
    
    return obiektyZbledami


def minimalnaOIKM(layer):
    obiektyZbledami = []
    ADJA_A_layer = None
    OIKM_A_layer = None
    if layer.name()[-6:] == 'OIKM_A':
        ADJA_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_OIKM_A","OT_ADJA_A"))[0]
        OIKM_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    invalid_layer = processing.run("qgis:checkvalidity", {'INPUT_LAYER': ADJA_A_layer, 'METHOD': 0, 'IGNORE_RING_SELF_INTERSECTION': True, 'VALID_OUTPUT': 'memory:', 'INVALID_OUTPUT': 'memory:', 'ERROR_OUTPUT': 'memory:'})
    # zawiera warstwę z niepoprawnymi geometriami
    if invalid_layer['INVALID_OUTPUT']:
              params = {'INPUT': ADJA_A_layer,'OUTPUT': 'memory:'} # Wykonanie naprawy geometrii
              naprawiona= processing.run("native:fixgeometries", params)['OUTPUT']
              ADJA_A_layer = naprawiona
    alg_params = {'INPUT': ADJA_A_layer,'SEPARATE_DISJOINT': False,'OUTPUT': 'memory:'}# usunięcie granic wewnątrz warstwy ADJA
    outputs = processing.run('native:dissolve', alg_params)['OUTPUT']
    params = {'INPUT': outputs,'OUTPUT': 'memory:'} # To zapisuje wynik w pamięci, bez tworzenia fizycznej warstwy
    granica = processing.run("native:polygonstolines", params)['OUTPUT'] # zamiana poligonu na linie
    for OIKM_A_feature in OIKM_A_layer.getFeatures():
        geom = OIKM_A_feature.geometry()
        if geom.area() < 500 and OIKM_A_feature['rodzaj'] == 'schody':
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(OIKM_A_feature)
    
    return obiektyZbledami


def minimalnaOIORschron(layer):
    obiektyZbledami = []
    ADJA_A_layer = None
    OIOR_A_layer = None
    if layer.name()[-6:] == 'OIOR_A':
        ADJA_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_OIOR_A","OT_ADJA_A"))[0]
        OIOR_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    invalid_layer = processing.run("qgis:checkvalidity", {'INPUT_LAYER': ADJA_A_layer, 'METHOD': 0, 'IGNORE_RING_SELF_INTERSECTION': True, 'VALID_OUTPUT': 'memory:', 'INVALID_OUTPUT': 'memory:', 'ERROR_OUTPUT': 'memory:'})
    # zawiera warstwę z niepoprawnymi geometriami
    if invalid_layer['INVALID_OUTPUT']:
              params = {'INPUT': ADJA_A_layer,'OUTPUT': 'memory:'} # Wykonanie naprawy geometrii
              naprawiona= processing.run("native:fixgeometries", params)['OUTPUT']
              ADJA_A_layer = naprawiona
    alg_params = {'INPUT': ADJA_A_layer, 'SEPARATE_DISJOINT': False, 'OUTPUT': 'memory:'} # usunięcie granic wewnątrz warstwy ADJA
    outputs = processing.run('native:dissolve', alg_params)['OUTPUT']
    params = {'INPUT': outputs,'OUTPUT': 'memory:'} # To zapisuje wynik w pamięci, bez tworzenia fizycznej warstwy
    granica = processing.run("native:polygonstolines", params)['OUTPUT'] # zamiana poligonu na linie
    for OIOR_A_feature in OIOR_A_layer.getFeatures():
        geom = OIOR_A_feature.geometry()
        if geom.area() < 100 and OIOR_A_feature['rodzaj'] == 'bunkier lub schron':
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(OIOR_A_feature)
    
    return obiektyZbledami


def minimalnaOIORszklarnia(layer):
    obiektyZbledami = []
    ADJA_A_layer = None
    OIOR_A_layer = None
    if layer.name()[-6:] == 'OIOR_A':
        ADJA_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_OIOR_A","OT_ADJA_A"))[0]
        OIOR_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    invalid_layer = processing.run("qgis:checkvalidity", {'INPUT_LAYER': ADJA_A_layer, 'METHOD': 0, 'IGNORE_RING_SELF_INTERSECTION': True, 'VALID_OUTPUT': 'memory:', 'INVALID_OUTPUT': 'memory:', 'ERROR_OUTPUT': 'memory:'})
    # zawiera warstwę z niepoprawnymi geometriami
    if invalid_layer['INVALID_OUTPUT']:
              params = {'INPUT': ADJA_A_layer,'OUTPUT': 'memory:'} # Wykonanie naprawy geometrii
              naprawiona= processing.run("native:fixgeometries", params)['OUTPUT']
              ADJA_A_layer = naprawiona
    alg_params = {'INPUT': ADJA_A_layer, 'SEPARATE_DISJOINT': False,'OUTPUT': 'memory:'} # usunięcie granic wewnątrz warstwy ADJA
    outputs = processing.run('native:dissolve', alg_params)['OUTPUT']
    params = {'INPUT': outputs,'OUTPUT': 'memory:'} # To zapisuje wynik w pamięci, bez tworzenia fizycznej warstwy
    granica = processing.run("native:polygonstolines", params)['OUTPUT'] # zamiana poligonu na linie
    for OIOR_A_feature in OIOR_A_layer.getFeatures():
        geom = OIOR_A_feature.geometry()
        if geom.area() < 100 and OIOR_A_feature['rodzaj'] == 'szklarnia niebędąca budynkiem':
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(OIOR_A_feature)
    
    return obiektyZbledami


def minimalnaOIORwiataAltana(layer):
    obiektyZbledami = []
    ADJA_A_layer = None
    OIOR_A_layer = None
    KUKO_A_layer = None
    if layer.name()[-6:] == 'OIOR_A':
        ADJA_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_OIOR_A","OT_ADJA_A"))[0]
        KUKO_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_OIOR_A","OT_KUKO_A"))[0]
        OIOR_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    invalid_layer = processing.run("qgis:checkvalidity", {'INPUT_LAYER': ADJA_A_layer, 'METHOD': 0, 'IGNORE_RING_SELF_INTERSECTION': True, 'VALID_OUTPUT': 'memory:', 'INVALID_OUTPUT': 'memory:', 'ERROR_OUTPUT': 'memory:'})
    identyfikatory_bledow = set()
    # zawiera warstwę z niepoprawnymi geometriami
    if invalid_layer['INVALID_OUTPUT']:
              params = {'INPUT': ADJA_A_layer,'OUTPUT': 'memory:'} # Wykonanie naprawy geometrii
              naprawiona= processing.run("native:fixgeometries", params)['OUTPUT']
              ADJA_A_layer = naprawiona
    alg_params = {'INPUT': ADJA_A_layer,'SEPARATE_DISJOINT': False,'OUTPUT': 'memory:'} # usunięcie granic wewnątrz warstwy ADJA
    outputs = processing.run('native:dissolve', alg_params)['OUTPUT']
    params = {'INPUT': outputs,'OUTPUT': 'memory:'} # To zapisuje wynik w pamięci, bez tworzenia fizycznej warstwy
    granica = processing.run("native:polygonstolines", params)['OUTPUT'] # zamiana poligonu na linie
    for OIOR_A_feature in OIOR_A_layer.getFeatures():
        for KUKO_A_feature in KUKO_A_layer.getFeatures():
            geom1 = OIOR_A_feature.geometry()
            geom2 = KUKO_A_feature.geometry()
            if geom1.area() < 200 and OIOR_A_feature['rodzaj'] == 'wiata lub altana' or (geom1.intersects(geom2) and KUKO_A_feature['rodzaj'] == 'stacja paliw'): 
                styka = False
                for g in granica.getFeatures():
                    if not geom1.intersects(g.geometry()) and OIOR_A_feature.id() not in identyfikatory_bledow:
                        styka = True
                        obiektyZbledami.append(OIOR_A_feature)
                        identyfikatory_bledow.add(OIOR_A_feature.id())
    
    return obiektyZbledami


def granicePowiatow():
    config = configparser.ConfigParser()
    mainPath = pathlib.Path(QgsApplication.qgisSettingsDirPath())/pathlib.Path(r"python/plugins/Walidator_plikow_gml/")
    config.read(str(mainPath)+'/Walidator_plikow_gml.ini')
    granicePowiatowPath = config['sciezkaPowiaty']['shpPowiaty']
    granicePowiatow_A = QgsVectorLayer(granicePowiatowPath, 'GranicePowiatow', 'ogr')
    
    # rozbicie multipoligon na poligony
    pojedynczeGranice = processing.run("native:multiparttosingleparts", {
        'INPUT': granicePowiatow_A,
        'OUTPUT': 'memory:'
    })
    
    # zamiana typu geometrii z poligonu na linię
    granicePowiatow_L = processing.run("native:polygonstolines", {
        'INPUT': pojedynczeGranice['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    return granicePowiatow_L


def czyPrzecinaGranicePowiatuDlugoscPonizej50m(layer):
    try:
        obiektyZbledami = []
        granicePowiatow_L = granicePowiatow()
        # Dodaj wynikową warstwę liniową do projektu
        alg_params = {
            'INPUT': granicePowiatow_L['OUTPUT'],
            'DISTANCE': 7.5, # Odległość bufora
            'SEGMENTS': 8, # Ilość segmentów na kwadrant, większa wartość = bardziej okrągły bufor
            'END_CAP_STYLE': 0,
            'JOIN_STYLE': 0,
            'MITER_LIMIT': 2,
            'DISSOLVE': False, # Ustawienie na True spowoduje scalenie wszystkich buforów w jeden obiekt
            'OUTPUT': 'memory:'
        }
        # Tworzenie bufora
        buforGranicy = processing.run('qgis:buffer', alg_params)['OUTPUT']
        index = QgsSpatialIndex()
        for granica in buforGranicy.getFeatures():
            index.insertFeature(granica)
        # Iteracja przez wszystkie obiekty w warstwie
        for obj in layer.getFeatures():
            if obj.geometry() is None:
                continue
            if obj.geometry().length() < 50:
                czyPrzecina = False
                intersecting_ids = index.intersects(obj.geometry().boundingBox())
                for id in intersecting_ids:
                    granica = buforGranicy.getFeature(id)
                    distance = obj.geometry().distance(granica.geometry())
                    if 0 < distance < 50: #obj.geometry().intersects(granica.geometry()) and not
                        czyPrzecina = True
                        break
                if czyPrzecina:
                    obiektyZbledami.append(obj)
    except:
        pass
        # QMessageBox.critical(QMessageBox(),'Brak warstwy referencyjnej','Sprawdź ścieżkę do pliku z granicami powiatów w Walidator_plikow_gml.ini', QMessageBox.Ok)
    return obiektyZbledami


def czyObiektyWewnatrzPowiatu(layer, teryt):
    try:
        obiektyZbledami = []
        config = configparser.ConfigParser()
        mainPath = pathlib.Path(QgsApplication.qgisSettingsDirPath())/pathlib.Path("python/plugins/Walidator_plikow_gml/")
        config.read(str(mainPath)+'/Walidator_plikow_gml.ini')
        granicePowiatowPath = config['sciezkaPowiaty']['shpPowiaty']
        granicePowiatow_A = QgsVectorLayer(granicePowiatowPath, 'GranicePowiatow', 'ogr')
        request = QgsFeatureRequest(QgsExpression("jpt_kod_je = \'" + teryt + "\'"))
        requestFeatures = granicePowiatow_A.getFeatures(request)
        for requestFeature in requestFeatures:
            granicaPowiatu = requestFeature
            break
        if granicaPowiatu is not None:
            geom = granicaPowiatu.geometry()
            granica = geom.convertToType(QgsWkbTypes.LineGeometry) # konwersja poligona na linię, w celu wydobycia granicy
        
        for obj in layer.getFeatures():
            objGeom = obj.geometry()
            vertices = list(objGeom.vertices())
            numVertices = len(vertices) # Liczba wierzchołków
            p1 = QgsPointXY(vertices[0])
            p2 = QgsPointXY(vertices[-1])
            # Konwersja na QgsGeometry
            geomP1 = QgsGeometry.fromPointXY(p1)
            geomP2 = QgsGeometry.fromPointXY(p2)
            # Konwersja QgsPointXY na QgsGeometry przed użyciem distance()
            d1 = granica.distance(geomP1)
            d2 = granica.distance(geomP2)
            if d1 > 0.01 and d2 > 0.01:
                if not geom.contains(obj.geometry()):
                    obiektyZbledami.append(obj)
    except:
        pass
        # QMessageBox.critical(QMessageBox(),'Brak warstwy referencyjnej','Sprawdź ścieżkę do pliku z granicami powiatów w Walidator_plikow_gml.ini', QMessageBox.Ok)
    return obiektyZbledami


def czyOdleglosciMiedzyPoziomicami2m_wersja1(layer):
    obiektyZbledami = []
    spatial_index = QgsSpatialIndex(layer.getFeatures())
    
    for obj1 in layer.getFeatures():
        for obj2 in layer.getFeatures():
            if obj1.id() != obj2.id() and not obj1 in obiektyZbledami and obj1.geometry().distance(obj2.geometry()) < 2:
                obiektyZbledami.append(obj1)
                break
    return obiektyZbledami


def czyOdleglosciMiedzyPoziomicami2m(layer):
    obiekty_z_bledami = []
    root = QgsProject.instance().layerTreeRoot()
    layers = QgsProject.instance().mapLayers().values()
    pasujace_warstwy = [layer for layer in layers if "RTLW_L" in layer.name()]
    if len(pasujace_warstwy) > 1:
       for layer in pasujace_warstwy[:-1]:
           QgsProject.instance().removeMapLayer(layer.id())
       layer = pasujace_warstwy[-1]
       for group in root.findGroups():
           if not group.findLayers():  # Sprawdzenie, czy grupa jest pusta
               root.removeChildNode(group)
               break
    spatial_index = QgsSpatialIndex(layer.getFeatures(), flags=QgsSpatialIndex.FlagStoreFeatureGeometries)
    id_to_feature = {feature.id(): feature for feature in layer.getFeatures()} # Tworzenie słownika mapującego ID obiektu na obiekt
    for obj1 in layer.getFeatures():
       if obj1.attribute("rodzaj") == "poziomica":
           bbox = obj1.geometry().boundingBox()
           bbox.grow(0.01)
           nearestNeighbors = spatial_index.intersects(bbox)#nearestNeighbor(obj1.geometry(), 2, 0)
           for nn in nearestNeighbors:
               if obj1.id() != nn:
                   obj2 = id_to_feature[nn]
                   if obj2.attribute("rodzaj") == "poziomica" and not obj1 in obiekty_z_bledami and obj1.geometry().distance(obj2.geometry()) < 2 and \
                       obj1.geometry().distance(obj2.geometry()) > 0:
                       obiekty_z_bledami.append(obj1)
                       break
    
    return obiekty_z_bledami


def nadmiernaSegmentacja(layer):
    id_to_feature = {feature.id(): feature for feature in layer.getFeatures()} # Tworzenie słownika mapującego ID obiektu na obiekt
    obiekty_z_bledami = []
    spatial_index = QgsSpatialIndex(layer.getFeatures(), flags=QgsSpatialIndex.FlagStoreFeatureGeometries)
    for obj1 in layer.getFeatures():
        nearestNeighbors = spatial_index.nearestNeighbor(obj1.geometry(), 2, 0)
        for nn in nearestNeighbors:
            if obj1.id() == nn:
                continue
            obj2 = id_to_feature[nn]
            atrybuty1 = obj1.attributes()[2:]
            atrybuty2 = obj2.attributes()[2:]
            if not obj1 in obiekty_z_bledami and obj1.geometry().distance(obj2.geometry()) < 0.01 and atrybuty1 == atrybuty2 and not obj1.geometry().equals(obj2.geometry()):
                obiekty_z_bledami.append(obj1)
                break
    
    return obiekty_z_bledami


def nadmiernaSegmentacja_rtwl(layer):
    id_to_feature = {feature.id(): feature for feature in layer.getFeatures()} # Tworzenie słownika mapującego ID obiektu na obiekt
    obiekty_z_bledami = []
    hash_to_ids = {}
    spatial_index = QgsSpatialIndex(layer.getFeatures(), flags=QgsSpatialIndex.FlagStoreFeatureGeometries)
    for feature in id_to_feature.values():
        spatial_index.addFeature(feature)
    for feature_id, feature in id_to_feature.items():
        # Utwórz hash na podstawie atrybutów (pomijając pierwsze dwa)
        attrs_hash = hash(tuple(feature.attributes()[2:]))
        if attrs_hash in hash_to_ids:
            hash_to_ids[attrs_hash].append(feature_id)
        else:
            hash_to_ids[attrs_hash] = [feature_id]
    for attrs_hash, ids in hash_to_ids.items():
       if len(ids) > 1: # Jeśli więcej niż jeden obiekt ma ten sam hash
           for id in ids:
               obj1 = id_to_feature[id]
               bbox = obj1.geometry().boundingBox()
               bbox.grow(0.01)
               candidates_ids = spatial_index.intersects(bbox)
               candidates_ids.remove(id)
               for candidate_id in candidates_ids:
                   if candidate_id in ids: # Porównujemy tylko w ramach tej samej grupy hashowej
                        obj2 = id_to_feature[candidate_id]
                        if not obj1 in obiekty_z_bledami and obj1.geometry().distance(obj2.geometry()) < 0.01 and not obj1.geometry().equals(obj2.geometry()):
                            obiekty_z_bledami.append(obj1)
                            break
    
    return obiekty_z_bledami


def przewerteksowanie(layer):
    obiekty_z_bledami = []
    for obj1 in layer.getFeatures():
        geom = obj1.geometry()
        liczbaWerteksów = len(geom.asPolyline())
        if liczbaWerteksów > 2:
            for i in range(0, liczbaWerteksów):
                if i > 0 and i < liczbaWerteksów:
                    odcinek_linii = QgsLineString()
                    odcinek_linii.addVertex(geom.vertexAt(i-1))
                    odcinek_linii.addVertex(geom.vertexAt(i+1))
                    geom1 = QgsGeometry(odcinek_linii)
                    d = geom1.distance(QgsGeometry(geom.vertexAt(i)))
                    if d < 0.05:
                        obiekty_z_bledami.append(obj1)
                        return obiekty_z_bledami
    
    return obiekty_z_bledami


def przecieciaLiniiNapieciaPodziemna(layer):
    obiekty_z_bledami = []
    OT_SULN_L_layer = None
    OT_BUWT_P_layer = None
    if layer.name()[-6:] == 'SULN_L':
        OT_BUWT_P_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_SULN_L","OT_BUWT_P"))[0]
        OT_SULN_L_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    index = QgsSpatialIndex()
    identyfikatory_bledow = set() # Zbiór do śledzenia identyfikatorów błędnych obiektów w celu uniknięcia powieleń
    for feat in OT_BUWT_P_layer.getFeatures():
        index.insertFeature(feat) # Budowanie indeksu przestrzennego do szybszego przetworzenia
    for OT_SULN_L_feature in OT_SULN_L_layer.getFeatures():
        geom = OT_SULN_L_feature.geometry()
        all_points = [vertex for vertex in geom.vertices()]
        # Usuń pierwszy i ostatni punkt (wierzchołek)
        if len(all_points) <= 3:  # Pomiń linie z trzema lub dwoma wierzchołkami
            continue
        analysis_points = [QgsPointXY(vertex.x(), vertex.y()) for vertex in all_points[1:-1]]
        new_geom = QgsGeometry.fromPolylineXY(analysis_points)
        kodkarto = OT_SULN_L_feature['kodKarto10k']
        rodzaj = OT_SULN_L_feature['rodzaj']
        if kodkarto == '0010_444' and rodzaj in ['linia elektroenergetyczna najwyższego napięcia', 'linia elektroenergetyczna wysokiego napięcia', 'linia elektroenergetyczna średniego napięcia']:
            ids = index.intersects(new_geom.boundingBox()) # intersekcja z obiektem
            intersects = False
            for id in ids:
                other_feat = OT_BUWT_P_layer.getFeature(id)
                if other_feat['rodzaj'] == 'słup energetyczny' and new_geom.intersects(other_feat.geometry()) and OT_SULN_L_feature.id() not in identyfikatory_bledow:
                    intersects = True
                    obiekty_z_bledami.append(OT_SULN_L_feature)
                    identyfikatory_bledow.add(OT_SULN_L_feature.id())
    
    return obiekty_z_bledami


def przecieciaLiniiNapieciaNadziemna(layer):
    obiekty_z_bledami = []
    OT_SULN_L_layer = None
    OT_BUWT_P_layer = None
    if layer.name()[-6:] == 'SULN_L':
        OT_BUWT_P_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_SULN_L","OT_BUWT_P"))[0]
        OT_SULN_L_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    index = QgsSpatialIndex()
    identyfikatory_bledow = set() # Zbiór do śledzenia identyfikatorów błędnych obiektów w celu uniknięcia powieleń
    for feat in OT_BUWT_P_layer.getFeatures():
        index.insertFeature(feat) # Budowanie indeksu przestrzennego do szybszego przetworzenia
    for OT_SULN_L_feature in OT_SULN_L_layer.getFeatures():
        geom = OT_SULN_L_feature.geometry()
        all_points = [vertex for vertex in geom.vertices()]
        # Usuń pierwszy i ostatni punkt (wierzchołek)
        if len(all_points) <= 3:  # Pomiń linie z trzema lub dwoma wierzchołkami
            continue
        analysis_points = [QgsPointXY(vertex.x(), vertex.y()) for vertex in all_points[1:-1]]
        new_geom = QgsGeometry.fromPolylineXY(analysis_points)
        kodkarto = OT_SULN_L_feature['kodKarto10k']
        rodzaj = OT_SULN_L_feature['rodzaj']
        if kodkarto == '0010_446' and rodzaj not in ['linia elektroenergetyczna najwyższego napięcia', 'linia elektroenergetyczna wysokiego napięcia', 'linia elektroenergetyczna średniego napięcia']:
            ids = index.intersects(new_geom.boundingBox()) # intersekcja z obiektem
            intersects = False
            for id in ids:
                other_feat = OT_BUWT_P_layer.getFeature(id)
                if not new_geom.intersects(other_feat.geometry()) and other_feat['rodzaj'] == 'słup energetyczny' and OT_SULN_L_feature.id() not in identyfikatory_bledow:
                    intersects = True
                    obiekty_z_bledami.append(OT_SULN_L_feature)
                    identyfikatory_bledow.add(OT_SULN_L_feature.id())
    
    return obiekty_z_bledami


def kontrola_OT_ADMS_P_z_OT_ADMS_A(layer):
    obiekty_z_bledami = []
    OT_ADMS_A_layer = None
    OT_ADMS_P_layer = None
    if layer.name()[-6:] == 'ADMS_P':
        OT_ADMS_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_ADMS_P","OT_ADMS_A"))[0]
        OT_ADMS_P_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    if OT_ADMS_A_layer and OT_ADMS_P_layer:
        identyfikatory_bledow = set() # Zbiór do śledzenia identyfikatorów błędnych obiektów
        nazwy_adms_p = set([feature['nazwa'] for feature in OT_ADMS_P_layer.getFeatures()])
        nazwy_adms_a = set([feature['nazwa'] for feature in OT_ADMS_A_layer.getFeatures()])
        # Sprawdzenie przecięcia i nazw dla obiektów z OT_ADMS_A
        for OT_ADMS_A_feature in OT_ADMS_A_layer.getFeatures():
            is_intersected = False
            nazwa_adms_a = OT_ADMS_A_feature['nazwa']
            # Sprawdzenie przecięcia dla każdego obiektu z OT_ADMS_P
            for OT_ADMS_P_feature in OT_ADMS_P_layer.getFeatures():
                nazwa_adms_p = OT_ADMS_P_feature['nazwa']
                if OT_ADMS_P_feature.geometry().intersects(OT_ADMS_A_feature.geometry()) or OT_ADMS_A_feature.geometry().contains(OT_ADMS_P_feature.geometry()):
                    is_intersected = True
                    break
            if not is_intersected or nazwa_adms_a not in nazwy_adms_p: #... oraz czy nazwy z OT_ADMS_A występują w OT_ADMS_P
                if OT_ADMS_A_feature.id() not in identyfikatory_bledow:
                    obiekty_z_bledami.append(OT_ADMS_A_feature)
                    identyfikatory_bledow.add(OT_ADMS_A_feature.id())
            # Sprawdzenie, czy nazwy z OT_ADMS_P występują w OT_ADMS_A
            if OT_ADMS_P_feature['nazwa'] not in nazwy_adms_a and OT_ADMS_P_feature.id() not in identyfikatory_bledow:
                obiekty_z_bledami.append(OT_ADMS_P_feature)
                identyfikatory_bledow.add(OT_ADMS_P_feature.id())
    
    return obiekty_z_bledami


def kontrolaTERCpunkt(layer):
    obiektyZbledami = []
    adms = None
    adja = None
    if layer.name()[-6:] == 'ADMS_P':
        adja = QgsProject().instance().mapLayersByName(layer.name().replace("OT_ADMS_P","OT_ADJA_A"))[0]
        adms = QgsProject().instance().mapLayersByName(layer.name())[0]
    # Zestaw do śledzenia już dodanych identyfikatorów TERYT
    przetworzone_teryt = set()
    
    # Sprawdzenie, czy są warstwy
    if adms and adja:
        expression = """ "rodzaj" IN ('miasto', 'miasto w gminie miejsko-wiejskiej', 'gmina') """
        # Wykonaj selekcję
        adja.selectByExpression(expression, QgsVectorLayer.SetSelection)
        selected = adja.selectedFeatures()
        # Przygotuj listę identyfikatorów TERYT z warstwy ADJA jako tekst
        identyfikatory_teryt = {str(feature["identyfikatorTerytJednostki"]).zfill(7): feature for feature in selected}
        # Przygotuj słownik dla ADMS_P: klucz to IdentyfikatorTERC, wartość to lista nazw
        identyfikatory_terc_adms = {}
        for feature in adms.getFeatures():
           teryt_adms = str(feature["IdentyfikatorTERC"]).zfill(7)
           if teryt_adms in identyfikatory_terc_adms:
               identyfikatory_terc_adms[teryt_adms].append(feature)
           else:
               identyfikatory_terc_adms[teryt_adms] = [feature]
        # Dla każdego identyfikatora TERYT/TERC
        for teryt, adja_feature in identyfikatory_teryt.items():
            if not teryt in identyfikatory_terc_adms and len(teryt) == 7:
                obiektyZbledami.append(adja_feature)
        for teryt_adms, adms_features in identyfikatory_terc_adms.items():
           if teryt_adms not in identyfikatory_teryt:
               for adms_feature in adms_features:
                   obiektyZbledami.append(adms_feature)
        adja.removeSelection()
    
    return obiektyZbledami


def kontrolaTERCpowierzchnia(layer):
    obiektyZbledami = []
    adms = None
    adja = None
    if layer.name()[-6:] == 'ADMS_A':
        adja = QgsProject().instance().mapLayersByName(layer.name().replace("ADMS","ADJA"))[0]
        adms = QgsProject().instance().mapLayersByName(layer.name())[0]
        
    # Zestaw do śledzenia już dodanych identyfikatorów TERYT
    przetworzone_teryt = set()
    
    # Sprawdzenie, czy jsą warstwy
    if adms and adja:
        # Iteruj przez warstwy
        expression = """ "rodzaj" IN ('miasto', 'miasto w gminie miejsko-wiejskiej', 'gmina') """
        # Wykonaj selekcję na ADJA_A
        adja.selectByExpression(expression, QgsVectorLayer.SetSelection)
        selected = adja.selectedFeatures()
        # Przygotuj listę identyfikatorów TERYT z warstwy ADJA jako tekst
        identyfikatory_teryt = {str(feature["identyfikatorTerytJednostki"]).zfill(7): feature  for feature in selected}
        # Przygotuj słownik dla ADMS_A: klucz to IdentyfikatorTERC, wartość to lista nazw
        identyfikatory_terc_adms = {}
        for feature in adms.getFeatures():
            teryt_adms = str(feature["IdentyfikatorTERC"]).zfill(7)
            if teryt_adms in identyfikatory_terc_adms:
                identyfikatory_terc_adms[teryt_adms].append(feature)
            else:
                identyfikatory_terc_adms[teryt_adms] = [feature]
        # Sprawdź pokrycie
        for teryt, adja_feature in identyfikatory_teryt.items():
            if not teryt in identyfikatory_terc_adms and len(teryt) == 7:
                obiektyZbledami.append(adja_feature)
         # Dodatkowe sprawdzenie: kod TERYT w ADMS_A, ale nie w ADJA
        for teryt_adms, adms_features in identyfikatory_terc_adms.items():
           if teryt_adms not in identyfikatory_teryt:
               for adms_feature in adms_features:
                    obiektyZbledami.append(adms_feature)
        adja.removeSelection()
    
    return obiektyZbledami


def fullCoverage(layer):
    obiektyZbledami = []
    adja = None
    holesLyr = QgsVectorLayer("Polygon?crs=epsg:" + str(2180), "Wszystkie obiekty z pokrycia", "memory")
    pokrycie = []
    for layer_id, lyr in QgsProject.instance().mapLayers().items():
        if lyr.name().__contains__("OT_PT"):
            pokrycie.append(lyr)
        elif lyr.name().__contains__("OT_ADJA_A"):
            adja = lyr
    
    # Tworzenie indeksu przestrzennego dla każdej warstwy wektorowej
    obiekty_wszystkie = []
    for l in pokrycie:
        for feature in l.getFeatures():
            obiekty_wszystkie.append(feature)
            holesLyr.dataProvider().addFeatures([feature])
    
    # Iteracja przez każdą parę warstw do sprawdzenia pokryć
    if adja and len(pokrycie) == 12 and not QgsProject.instance().mapLayersByName("Nakładania w pokryciu terenu") and not QgsProject.instance().mapLayersByName("Dziury w pokryciu terenu"):
        nakladanie = QgsVectorLayer("Polygon?crs=epsg:2180", "Nakładania w pokryciu terenu", "memory")
        pr = nakladanie.dataProvider()
        union = processing.run("qgis:union", {
            'INPUT': holesLyr,
            'OUTPUT': 'memory:'
        })
        
        geom_union = []
        for f in union['OUTPUT'].getFeatures():
            g = f.geometry()
            geom_wkt = g.asWkt()
            if not geom_wkt in geom_union:
                geom_union.append(geom_wkt)
            else:
                obiektyZbledami.append(f)
                nakladanie.dataProvider().addFeatures([f])
        QgsProject.instance().addMapLayer(nakladanie)
        
        invalid_layer = processing.run("qgis:checkvalidity", {
            'INPUT_LAYER': adja,
            'METHOD': 0,
            'IGNORE_RING_SELF_INTERSECTION': True,
            'VALID_OUTPUT': 'memory:',
            'INVALID_OUTPUT': 'memory:',
            'ERROR_OUTPUT': 'memory:'
            })
        
        if invalid_layer['INVALID_OUTPUT'] and not QgsProject.instance().mapLayersByName("naprawiona OT_ADJA_A"):
            naprawiona = processing.run("native:fixgeometries", {
                'INPUT': adja,
                'OUTPUT': 'memory:'
            })
            naprawiona['OUTPUT'].setName("naprawiona OT_ADJA_A")
            adja = naprawiona['OUTPUT']
        if not QgsProject.instance().mapLayersByName("Dziury w pokryciu terenu"):
            roznica = processing.run("native:difference", {
                'INPUT': adja,
                'OVERLAY': holesLyr,
                'OUTPUT': 'memory:'
            })
            
            pojedynczeDziury = processing.run("native:multiparttosingleparts", {
                'INPUT': roznica['OUTPUT'],
                'OUTPUT': 'memory:'
            })
            
            pojedynczeDziury['OUTPUT'].startEditing()
            for obj in pojedynczeDziury['OUTPUT'].getFeatures():
                if obj.geometry().area() < 1:
                    pojedynczeDziury['OUTPUT'].deleteFeature(obj.id())
                else:
                    obiektyZbledami.append(obj)
            pojedynczeDziury['OUTPUT'].commitChanges(False)
            pojedynczeDziury['OUTPUT'].setName("Dziury w pokryciu terenu")
            QgsProject.instance().addMapLayer(pojedynczeDziury['OUTPUT'])
    
    return obiektyZbledami


def boundaryPTWP(layer):
    try: 
        obiektyZbledami = []
        ptwp = None
        spatial_index = QgsSpatialIndex(layer.getFeatures())
        if layer.name()[-6:] == 'RTLW_L':
            ptwp = QgsProject().instance().mapLayersByName(layer.name().replace("RTLW_L","PTWP_A"))[0]
        if ptwp:
            # Tworzenie spatial index dla warstwy PTWP
            ptwp_features = list(ptwp.getFeatures())
            spatial_index = QgsSpatialIndex()
            
            for feature in ptwp_features:
                spatial_index.addFeature(feature)
                
            # Iteracja przez każdy obiekt w warstwie RTLW
            for rtlw_feature in layer.getFeatures():
                rtlw_geom = rtlw_feature.geometry()
                rodzaj_rtlw = rtlw_feature['rodzaj']
                
                # Znajdowanie potencjalnych kandydatów z PTWP przy użyciu spatial index
                intersecting_ids = spatial_index.intersects(rtlw_geom.boundingBox())
                for ptwp_id in intersecting_ids:
                    ptwp_feature = ptwp.getFeature(ptwp_id)
                    ptwp_geom = ptwp_feature.geometry()
                    
                    # Sprawdzanie przecięcia wnętrza (ignoruje stykanie się)
                    if (rtlw_geom.crosses(ptwp_geom) or (rtlw_geom.intersects(ptwp_geom)) and not rtlw_geom.touches(ptwp_geom)) and rodzaj_rtlw in ('skarpa','wąwóz'):
                        obiektyZbledami.append(rtlw_feature)
    except:
        pass
    
    return obiektyZbledami


def KontrolaAtrybutuKlasouzytek(layer, plikGML):
    obiektyZbledami = []
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'egb': 'ewidencjaGruntowIBudynkow:1.0'}
    
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces = ns):
        dzialka = featureMember.find('.//egb:EGB_DzialkaEwidencyjna', namespaces = ns)
        if dzialka is not None:
           # Dla każdego Klasouzytek w obrębie Działki Ewidencyjnej
           for klasouzytek in dzialka.findall('.//egb:EGB_Klasouzytek', namespaces = ns):
               lokalnyId = dzialka.find('.//egb:lokalnyId', namespaces=ns)
               lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
               OFU = klasouzytek.find('.//egb:OFU', namespaces=ns)
               ofu_value = OFU.text if OFU is not None else None
               if ofu_value in ['Ls', 'W']:
                   OZU = klasouzytek.find('.//egb:OZU', namespaces=ns)
                   ozu_value = OZU.text if OZU is not None else None
                   if ozu_value == 'Ls':
                       OZK = klasouzytek.find('.//egb:OZK', namespaces=ns)
                       ozk_value = OZK.text if OZK is not None else None
                       if ozk_value in ['IIIa', 'IIIb', 'IVa', 'IVb']:
                           expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
                           request = QgsFeatureRequest().setFilterExpression(expression)
                           for feature in layer.getFeatures(request):
                               obiektyZbledami.append(feature)
    
    return obiektyZbledami


def KontrolaAtrybutuKlasouzytek2(layer, plikGML):
    obiektyZbledami = []
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'egb': 'ewidencjaGruntowIBudynkow:1.0'}
    
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        dzialka = featureMember.find('.//egb:EGB_DzialkaEwidencyjna', namespaces=ns)
        if dzialka is not None:
           # Dla każdego Klasouzytek w obrębie Działki Ewidencyjnej
           for klasouzytek in dzialka.findall('.//egb:EGB_Klasouzytek', namespaces=ns):
               lokalnyId = dzialka.find('.//egb:lokalnyId', namespaces=ns)
               lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
               OFU = klasouzytek.find('.//egb:OFU', namespaces=ns)
               ofu_value = OFU.text if OFU is not None else None
               if ofu_value in ['R','S', 'Br','Wsr','W','Lzr']:
                   OZU = klasouzytek.find('.//egb:OZU', namespaces=ns)
                   ozu_value = OZU.text if OZU is not None else None
                   if ozu_value == 'R':
                       OZK = klasouzytek.find('.//egb:OZK', namespaces=ns)
                       ozk_value = OZK.text if OZK is not None else None
                       if not ozk_value in ['I','II','IIIa', 'IIIb', 'IVa', 'IVb','V','VI','VIz']:
                           expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
                           request = QgsFeatureRequest().setFilterExpression(expression)
                           for feature in layer.getFeatures(request):
                               obiektyZbledami.append(feature)
    
    return obiektyZbledami


def KontrolaGeometriaSchody(layer, plikGML):
    obiektyZbledami = []
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'egb': 'ewidencjaGruntowIBudynkow:1.0'}
    
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        budynek = featureMember.find('.//egb:EGB_ObiektTrwaleZwiazanyZBudynkiem', namespaces=ns)
        print (type(budynek))
        if budynek is not None:
            polKier =  budynek.findall('.//egb:poliliniaKierunkowa', namespaces=ns)
            lokalnyId = budynek.find('.//egb:lokalnyId', namespaces=ns)
            lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
            expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
            request = QgsFeatureRequest().setFilterExpression(expression)
            if not polKier: # całkowity brak atrybutu 
                for feature in layer.getFeatures(request):
                    obiektyZbledami.append(feature)
            else:
                for pk in polKier:  # błędy i braki wewnątrz atrybutu
                    posList = pk.find('.//gml:posList', namespaces=ns)
                    posList_wsp = posList.text 
                    if posList_wsp is None:
                        for feature in layer.getFeatures(request):
                            obiektyZbledami.append(feature)
    
    return obiektyZbledami


def gminyCzyNakladajaSie(layer):
    obiektyZbledami = []
    gm = processing.run("qgis:extractbyexpression", {
        'INPUT':layer,
        'EXPRESSION':'"rodzaj" = \'gmina\'',
        'OUTPUT':'memory:'})
    gminy = gm['OUTPUT']
    gminy.setName("gminy")
    
    invalid_layer = processing.run("qgis:checkvalidity", {
        'INPUT_LAYER': gminy, 
        'METHOD': 0, 
        'IGNORE_RING_SELF_INTERSECTION': True,
        'VALID_OUTPUT': 'memory:',
        'INVALID_OUTPUT': 'memory:',
        'ERROR_OUTPUT': 'memory:'})
        
        # zawiera warstwę z niepoprawnymi geometriami
    if invalid_layer['INVALID_OUTPUT']:
              params = {
              'INPUT': gminy,
              'OUTPUT': 'memory:'
              }
          # Wykonanie naprawy geometrii
              naprawiona= processing.run("native:fixgeometries", params)['OUTPUT']
              naprawiona.setName("naprawiona ADJA_A")
              gminy = naprawiona
    
    nach = processing.run("qgis:extractbylocation", {
        'INPUT': gminy,
        'PREDICATE': [5],
        'INTERSECT': gminy,
        'OUTPUT': 'memory:'})
    wynik = nach['OUTPUT']
    wynik.setName("wynik") 
    #QgsProject.instance().addMapLayer(wynik)
    for obj in wynik.getFeatures():
        obiektyZbledami.append(obj)
    
    return obiektyZbledami


def miastoWiesCzyNakladajaSie(layer):
    obiektyZbledami = []
    mw = processing.run("qgis:extractbyexpression",{
        'INPUT': layer,
        'EXPRESSION':'"rodzaj"=\'miasto\' or "rodzaj"=\'wieś\'',
        'OUTPUT':'memory:'})
    miastoWies = mw['OUTPUT']
    miastoWies.setName("miasto_wies")
    
    invalid_layer = processing.run("qgis:checkvalidity",{
        'INPUT_LAYER': miastoWies,
        'METHOD': 0,
        'IGNORE_RING_SELF_INTERSECTION': True,
        'VALID_OUTPUT': 'memory:',
        'INVALID_OUTPUT': 'memory:',
        'ERROR_OUTPUT': 'memory:'})
    
        # zawiera warstwę z niepoprawnymi geometriami
    if invalid_layer['INVALID_OUTPUT']:
              params = {
              'INPUT': miastoWies,
              'OUTPUT': 'memory:'
              }
          # Wykonanie naprawy geometrii
              naprawiona= processing.run("native:fixgeometries", params)['OUTPUT']
              naprawiona.setName("naprawiona ADMS_A")
              miastoWies = naprawiona
    
    nach = processing.run("qgis:extractbylocation", {
        'INPUT': miastoWies,
        'PREDICATE': [5],
        'INTERSECT': miastoWies,
        'OUTPUT': 'memory:'})
    
    wynik = nach['OUTPUT']
    wynik.setName("wynik")
    for obj in wynik.getFeatures():
        obiektyZbledami.append(obj)
    
    return obiektyZbledami


def sprawdzLokalnyId(layer):
    obiektyZbledami = []
    if layer.name()[-6:] in ['RTLW_L', 'RTPW_P']:
        # funkcja nie wykona się dla warstw z rzeźbą terenu
        return obiektyZbledami
    uuid_pattern = re.compile(r'^[A-Za-z0-9]{8}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{12}$|^$')
    # Zbiór do sprawdzania unikalności
    unique_ids = set()
    for f in layer.getFeatures():
        lokalny = f.attribute('lokalnyId')
        matches_pattern = bool(uuid_pattern.match(lokalny))
        if not isinstance(lokalny, str):
            lokalny = str(lokalny) # konwersja pustej wartosci na string
        is_unique = lokalny not in unique_ids
        if is_unique and not matches_pattern:
            unique_ids.add(lokalny)
            obiektyZbledami.append(f)
    
    return obiektyZbledami


def sprawdzPrzestrzenNazw(layer):
    obiektyZbledami = []
    if layer.name()[-6:] in ['RTLW_L', 'RTPW_P']:
        # funkcja nie wykona się dla warstw z rzeźbą terenu
        return obiektyZbledami
    dozwolone_kody = {
    '02': '337',  # dolnośląskie
    '04': '994',  # kujawsko-pomrskie
    '06': '3700', # lubelskie
    '26': '370',  # świętokrzyskie
    '08': '333',  # lubuskie
    '10': '340',  # łódzkie
    '12': '283',  # małopolskie
    '14': '330',  # mazowieckie
    '16': '1833', # opolskie
    '18': '332',  # podlaskie
    '20': '335',  # podkarpackie
    '22': '336',  # pomorskie
    '24': '238',  # śląskie
    '28': '341',  # warmińsko-mazurskie
    '30': '308',  # wielkopolskie
    '32': '339'   # zachodniopomorskie
    }
    pattern = re.compile(r'^PL\.PZGiK\.(\d{3,4})\.BDOT10k$')
    # Zbiór do sprawdzania unikalności
    unique_ids = set()
    for f in layer.getFeatures():
        przestrzen = f.attribute('przestrzenNazw')
        match = pattern.match(przestrzen)
        if not isinstance(przestrzen, str):
            przestrzen = str(przestrzen) # konwersja pustej wartosci na string
        if not match: # sprawdza, czy są niezgodne z schematem
            obiektyZbledami.append(f)
        else: 
            woj = layer.name()[13:15] # sprawdza niezgodnosci cyfr w wojewodztwach
            if woj in ['.1', '.0']:
                woj = layer.name()[14:16]
            cyfry = match.group(1) if match.group(1) else None
            expected_cyfry = dozwolone_kody.get(woj, None)
            if isinstance(expected_cyfry, list):
                valid = cyfry in expected_cyfry
            else:
                valid = cyfry == expected_cyfry
                
            if not valid:
                    obiektyZbledami.append(f)
    
    return obiektyZbledami


def sprawdzWersja(layer):
    obiektyZbledami = []
    if layer.name()[-6:] in ['RTLW_L', 'RTPW_P']:
        # funkcja nie wykona się dla warstw z rzeźbą terenu
        return obiektyZbledami
    uuid_pattern = re.compile(r'^[0-9]{4}-[01][0-9]-[0-3][0-9]T[0-2][0-9]:[0-5][0-9]:[0-5][0-9]$|^$')
    # Zbiór do sprawdzania unikalności
    unique_ids = set()
    for f in layer.getFeatures():
        wersja = f.attribute('wersja')
        matches_pattern = bool(uuid_pattern.match(wersja))
        if not isinstance(wersja, str):
            wersja = str(wersja) # konwersja pustej wartosci na string
        is_unique = wersja not in unique_ids
        if is_unique and not matches_pattern:
            unique_ids.add(wersja)
            obiektyZbledami.append(f)
    
    return obiektyZbledami


def sprawdzPoczatekWersjiObiektu(layer):
    obiektyZbledami = []
    if layer.name()[-6:] in ['RTLW_L', 'RTPW_P']:
        # funkcja nie wykona się dla warstw z rzeźbą terenu
        return obiektyZbledami
    uuid_pattern = re.compile(r'^[0-9]{4}-[01][0-9]-[0-3][0-9]T[0-2][0-9]:[0-5][0-9]:[0-5][0-9]$')
    # Zbiór do sprawdzania unikalności
    unique_ids = set()
    for f in layer.getFeatures():
        poczatek = f.attribute('poczatekWersjiObiektu')
        wersja = f.attribute('wersja')
        if not isinstance(wersja, str):
            wersja = str(wersja)
        if not isinstance(poczatek, str):
            poczatek = str(poczatek) # konwersja pustej wartosci na string
        if wersja != poczatek and f.id() not in unique_ids:
             unique_ids.add(f.id())
             obiektyZbledami.append(f)
        if not uuid_pattern.match(wersja) and f.id() not in unique_ids:
             unique_ids.add(f.id())
             obiektyZbledami.append(f)
        if not uuid_pattern.match(poczatek) and f.id() not in unique_ids:
             unique_ids.add(f.id())
             obiektyZbledami.append(f)
    
    return obiektyZbledami


def przestrzenNazw(layer,teryt):
    obiektyZbledami = []
    slownik = {
    '02': '337',  # dolnośląskie
    '04': '994',  # kujawsko-pomrskie
    '06': '3700', # lubelskie
    '08': '333',  # lubuskie
    '10': '340',  # łódzkie
    '12': '283',  # małopolskie
    '14': '330',  # mazowieckie
    '16': '1833', # opolskie
    '18': '332',  # podlaskie
    '20': '335',  # podkarpackie
    '22': '336',  # pomorskie
    '24': '238',  # śląskie
    '26': '370',  # świętokrzyskie
    '28': '341',  # warmińsko-mazurskie
    '30': '308',  # wielkopolskie
    '32': '339'   # zachodniopomorskie
    }
    pattern = re.compile(r'^PL\.PZGiK\.(\d{3,4})\.BDOT10k$')
    # Zbiór do sprawdzania unikalności
    unique_ids = set()
    for f in layer.getFeatures():
        przestrzen = f.attribute('przestrzenNazw')
        if not isinstance(przestrzen, str):
            #print (przestrzen, type(przestrzen))
            przestrzen = str(przestrzen) # konwersja pustej wartosci na string
            obiektyZbledami.append(f)
        else:
            match = pattern.match(przestrzen)
            if not match: # sprawdza, czy są niezgodne z schematem
                match = pattern.match(przestrzen)
                obiektyZbledami.append(f)
            else:
                woj = teryt[:2]
                cyfry = match.group(1) if match.group(1) else None
                expected_cyfry = slownik.get(woj, None)
                if isinstance(expected_cyfry, list):
                    valid = cyfry in expected_cyfry
                else:
                    valid = cyfry == expected_cyfry
                if not valid:
                    obiektyZbledami.append(f)
    
    return obiektyZbledami


def zapisWspolrzednych(layer, plikGML):
    obiektyZbledami = []
    pattern = re.compile(r"[0-9]{6}\.[0-9]{3,}")
    plikGML = plikGML.getroot()
    otklasa = f'.//ot:{layer.name()[-9:]}'
    ns = {'gml': 'http://www.opengis.net/gml/3.2', "ot":"urn:gugik:specyfikacje:gmlas:bazaDanychObiektowTopograficznych10k:2.0"}
    # Szukanie wszystkich wystąpień
    warstwy_otklasy = {}
    
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        # Weryfikacja, czy wystąpienia są zgodne z oczekiwaniami
        matches = featureMember.find(otklasa, namespaces=ns)
        if matches is not None: 
            geometria = matches.findall('.//ot:geometria', namespaces=ns)
            lokalnyId = matches.find('.//ot:lokalnyId', namespaces=ns)
            lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
            expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
            request = QgsFeatureRequest().setFilterExpression(expression)
            for g in geometria:  # błędy i braki wewnątrz atrybutu
                geom = g.find('.//gml:posList', namespaces=ns)
                geomPkt = g.find('.//gml:pos', namespaces=ns)
                if geom is not None: # linie i powierzchnie
                    geom_wsp = geom.text if geom is not None else "Nieznane ID"
                    if pattern.search(geom_wsp):
                        for feature in layer.getFeatures(request):
                            obiektyZbledami.append(feature)
                elif geomPkt is not None: # punkty
                    geom_wsp = geomPkt.text if geomPkt is not None else "Nieznane ID"
                    if pattern.search(geom_wsp):
                        for feature in layer.getFeatures(request):
                            obiektyZbledami.append(feature)
    
    return obiektyZbledami


def minDlugoscOIPR(layer):
    obiektyZbledami = []
    ADJA_A_layer = None
    OIPR_L_layer = None
    if layer.name()[-6:] == 'OIPR_L':
        ADJA_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_OIPR_L","OT_ADJA_A"))[0]
        OIPR_L_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    invalid_layer = processing.run("qgis:checkvalidity", {'INPUT_LAYER': ADJA_A_layer, 'METHOD': 0, 'IGNORE_RING_SELF_INTERSECTION': True, 'VALID_OUTPUT': 'memory:', 'INVALID_OUTPUT': 'memory:', 'ERROR_OUTPUT': 'memory:'})
    # zawiera warstwę z niepoprawnymi geometriami
    if invalid_layer['INVALID_OUTPUT']:
              params = {'INPUT': ADJA_A_layer,'OUTPUT': 'memory:'} # Wykonanie naprawy geometrii
              naprawiona= processing.run("native:fixgeometries", params)['OUTPUT']
              ADJA_A_layer = naprawiona
    alg_params = {'INPUT': ADJA_A_layer, 'SEPARATE_DISJOINT': False,'OUTPUT': 'memory:'} # usunięcie granic wewnątrz warstwy ADJA
    outputs = processing.run('native:dissolve', alg_params)['OUTPUT']
    params = {'INPUT': outputs,'OUTPUT': 'memory:'} # To zapisuje wynik w pamięci, bez tworzenia fizycznej warstwy
    granica = processing.run("native:polygonstolines", params)['OUTPUT'] # zamiana poligonu na linie
    for OIPR_L_feature in OIPR_L_layer.getFeatures():
        geom = OIPR_L_feature.geometry()
        if geom.length() < 40 and OIPR_L_feature['rodzaj'] in ['rząd drzew','pas krzewów lub żywopłot']:
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(OIPR_L_feature)
    
    return obiektyZbledami


def minDlugoscBUUO(layer):
    obiektyZbledami = []
    ADJA_A_layer = None
    BUUO_L_layer = None
    if layer.name()[-6:] == 'BUUO_L':
        ADJA_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_BUUO_L","OT_ADJA_A"))[0]
        BUUO_L_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    invalid_layer = processing.run("qgis:checkvalidity", {'INPUT_LAYER': ADJA_A_layer, 'METHOD': 0, 'IGNORE_RING_SELF_INTERSECTION': True, 'VALID_OUTPUT': 'memory:', 'INVALID_OUTPUT': 'memory:', 'ERROR_OUTPUT': 'memory:'})
    # zawiera warstwę z niepoprawnymi geometriami
    if invalid_layer['INVALID_OUTPUT']:
              params = {'INPUT': ADJA_A_layer,'OUTPUT': 'memory:'} # Wykonanie naprawy geometrii
              naprawiona= processing.run("native:fixgeometries", params)['OUTPUT']
              ADJA_A_layer = naprawiona
    alg_params = {'INPUT': ADJA_A_layer, 'SEPARATE_DISJOINT': False,'OUTPUT': 'memory:'} # usunięcie granic wewnątrz warstwy ADJA
    outputs = processing.run('native:dissolve', alg_params)['OUTPUT']
    params = {'INPUT': outputs,'OUTPUT': 'memory:'} # To zapisuje wynik w pamięci, bez tworzenia fizycznej warstwy
    granica = processing.run("native:polygonstolines", params)['OUTPUT'] # zamiana poligonu na linie
    for BUUO_L_feature in BUUO_L_layer.getFeatures():
        geom = BUUO_L_feature.geometry()
        if geom.length() < 10 and BUUO_L_feature['rodzaj'] in ['falochron','ostroga']:
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(BUUO_L_feature)
    
    return obiektyZbledami


def minDlugoscSUPRnaKUPG(layer):
    obiektyZbledami = []
    ADJA_A_layer = None
    KUPG_A_layer = None
    SUPR_L_layer = None
    if layer.name()[-6:] == 'SUPR_L':
        ADJA_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_SUPR_L","OT_ADJA_A"))[0]
        KUPG_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_SUPR_L","OT_KUPG_A"))[0]
        SUPR_L_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    invalid_layer = processing.run("qgis:checkvalidity", {'INPUT_LAYER': ADJA_A_layer, 'METHOD': 0, 'IGNORE_RING_SELF_INTERSECTION': True, 'VALID_OUTPUT': 'memory:', 'INVALID_OUTPUT': 'memory:', 'ERROR_OUTPUT': 'memory:'})
    # zawiera warstwę z niepoprawnymi geometriami
    if invalid_layer['INVALID_OUTPUT']:
              params = {'INPUT': ADJA_A_layer,'OUTPUT': 'memory:'} # Wykonanie naprawy geometrii
              naprawiona= processing.run("native:fixgeometries", params)['OUTPUT']
              ADJA_A_layer = naprawiona
    alg_params = {'INPUT': ADJA_A_layer, 'SEPARATE_DISJOINT': False,'OUTPUT': 'memory:'} # usunięcie granic wewnątrz warstwy ADJA
    outputs = processing.run('native:dissolve', alg_params)['OUTPUT']
    params = {'INPUT': outputs,'OUTPUT': 'memory:'} # To zapisuje wynik w pamięci, bez tworzenia fizycznej warstwy
    granica = processing.run("native:polygonstolines", params)['OUTPUT'] # zamiana poligonu na linie
    for SUPR_L_feature in SUPR_L_layer.getFeatures():
        for KUPG_A_feature in KUPG_A_layer.getFeatures():
            geom1 = SUPR_L_feature.geometry()
            geom2 = KUPG_A_feature.geometry()
            if geom1.length() < 100:
                styka = False
                for g in granica.getFeatures():
                    if geom1.intersects(geom2) and not geom1.intersects(g.geometry()):
                        styka = True
                        obiektyZbledami.append(SUPR_L_feature)
    
    return obiektyZbledami


def pyExpression(layer, sqltxt):
    obiektyZbledami = []
    
    def lexpression(layer, sqltxt):
        expression = QgsExpression(sqltxt)
        
        if expression.hasParserError():
            return f"Parser error: {expression.parserErrorString()}"
        
        if not expression.isValid():
            print("błąd w szablonie kontroli")
        
        # Tworzenie kontekstu wyrażenia
        context = QgsExpressionContext()
        context.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layer))
        
        # Iteracja przez wszystkie obiekty w kontekcie expression
        for feature in layer.getFeatures():
            context.setFeature(feature)
            expression.evaluate(context)
            
            if expression.hasEvalError():
                field_name = expression.evalErrorString().split("'")[1]
                layer.addExpressionField(field_name, QgsField(field_name, QVariant.String))
                
                # iteracyjnie dodaje brakujące pola do warstwy
                lexpression(layer, sqltxt)
                break
    
    lexpression(layer, sqltxt)
    
    request = QgsFeatureRequest(QgsExpression(sqltxt))
    requestFeatures = layer.getFeatures(request)
    for f in requestFeatures:
        obiektyZbledami.append(f)
    
    return obiektyZbledami