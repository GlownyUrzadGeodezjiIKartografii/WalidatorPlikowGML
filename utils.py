# -*- coding: utf-8 -*-
"""
/***************************************************************************
 walidatorPlikowGML
                                 A QGIS plugin
 Walidator plików GML baz BDOT10k, PRNG, GESUT, EGiB, BDOT500
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-12-23
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Marcin Lebiecki - Główny Urząd Geodezji i Kartografii
        email                : marcin.lebiecki@gugik.gov.pl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.core import *
from qgis.PyQt.QtCore import *
from qgis import processing
from qgis.PyQt.QtWidgets import *
import pathlib
import configparser
import sys
import re
from datetime import datetime
import lxml
from lxml import etree
import pandas as pd
import zipfile
import os
from qgis.core import QgsMessageLog, QgsProject, QgsSpatialIndex
from collections import defaultdict



loaded_csv_data = None
loaded_gml_prng_miejscowosci = None
loaded_gml_prng_obiektyfizjograficzne = None
tereny_chronione_zip = None
loaded_shp = {'OT_TCPN_A':[],'OT_TCPK_A':[],'OT_TCRZ_A':[],'OT_TCON_A':[]}


def findDuplicates(layer):
    obiektyZbledami = []
    
    extractbyexpression = processing.run("qgis:extractbyexpression", {
        'INPUT': layer,
        'EXPRESSION': '"rodzaj" != \'punkt wysokościowy w terenie\'',
        'FAIL_OUTPUT': 'memory:',
        'OUTPUT': 'memory:'
    })
    
    if layer.geometryType() == QgsWkbTypes.LineGeometry:
        obj_dl1 = {}
        for obj in extractbyexpression['OUTPUT'].getFeatures():
            dl = obj.geometry().length()
            if dl not in obj_dl1.keys():
                obj_dl1[dl] = obj
            else:
                if obj_dl1[dl].geometry().equals(obj.geometry()):
                    obiektyZbledami.append(obj)
        
        obj_dl2 = {}
        for obj in extractbyexpression['FAIL_OUTPUT'].getFeatures():
            dl = obj.geometry().length()
            if dl not in obj_dl2.keys():
                obj_dl2[dl] = obj
            else:
                if obj_dl2[dl].geometry().equals(obj.geometry()):
                    obiektyZbledami.append(obj)
    else:
        def localFun(obiektyZbledami, lyr):
            deleteduplicategeometries = processing.run("native:deleteduplicategeometries", {
                'INPUT': lyr,
                'OUTPUT': 'memory:'
            })
            
            liczbaUsunietychObiektow = layer.featureCount() - deleteduplicategeometries['OUTPUT'].featureCount()
            if liczbaUsunietychObiektow > 0:
                for obj1 in lyr.getFeatures():
                    czyObiektIstnieje = False
                    for obj2 in deleteduplicategeometries['OUTPUT'].getFeatures():
                        if obj1['gml_id'] == obj2['gml_id']:
                            czyObiektIstnieje = True
                            break
                    if not czyObiektIstnieje:
                        obiektyZbledami.append(obj1)
        
        if extractbyexpression['FAIL_OUTPUT'].featureCount() > 0:
            localFun(obiektyZbledami, extractbyexpression['FAIL_OUTPUT'])
        
        localFun(obiektyZbledami, extractbyexpression['OUTPUT'])
    
    return obiektyZbledami


def validateGeometry(layer):
    obiektyZbledami = set()
    
    checkvalidity1 = processing.run("qgis:checkvalidity", {
        'INPUT_LAYER': layer,
        'METHOD': 1, # QGIS
        'INVALID_OUTPUT': 'memory:',
        'ERROR_OUTPUT': 'memory:'
    })
    
    for obj in checkvalidity1['INVALID_OUTPUT'].getFeatures():
        geom = obj.geometry()
        if geom.type() == QgsWkbTypes.LineGeometry:
            if geom.asPolyline()[0] == geom.asPolyline()[-1] or geom.asPolyline()[0] in geom.asPolyline()[1:-1] or geom.asPolyline()[-1] in geom.asPolyline()[1:-1]:
                continue
        
        obiektyZbledami.add(obj)
    
    checkvalidity2 = processing.run("qgis:checkvalidity", {
        'INPUT_LAYER': layer,
        'METHOD': 2, # GEOS
        'INVALID_OUTPUT': 'memory:',
        'ERROR_OUTPUT': 'memory:'
    })
    
    for obj in checkvalidity2['INVALID_OUTPUT'].getFeatures():
        geom = obj.geometry()
        if geom.type() == QgsWkbTypes.LineGeometry:
            if geom.asPolyline()[0] == geom.asPolyline()[-1] or geom.asPolyline()[0] in geom.asPolyline()[1:-1] or geom.asPolyline()[-1] in geom.asPolyline()[1:-1]:
                continue
        
        obiektyZbledami.add(obj)
    
    return obiektyZbledami


def adjaMinus2cmBufor(layer):
    granica = []
    config = configparser.ConfigParser()
    mainPath = pathlib.Path(QgsApplication.qgisSettingsDirPath()) / pathlib.Path(r"python/plugins/Walidator_plikow_gml/")
    config.read(str(mainPath) + '/Walidator_plikow_gml.ini')
    granicePowiatowPath = config['DEFAULT']['granicepowiatow']
    granicePowiatow = QgsVectorLayer(granicePowiatowPath, 'GranicePowiatow', 'ogr')
    
    # Obsługa MultiPart
    granicePowiatow = processing.run("native:multiparttosingleparts", {
        'INPUT': granicePowiatow,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    terytPowiatu = int(layer.name()[-15:-11])
    powiat_z_PRG = QgsVectorLayer("Polygon?crs=epsg:2180&field=gml_id:string(254)", "granica powiatu z PRG", "memory")
    
    for obj in granicePowiatow.getFeatures():
        if str(obj['JPT_KOD_JE']) == str(terytPowiatu):
            powiat_z_PRG.dataProvider().addFeatures([obj])
            break
    
    bufor = processing.run("native:buffer", {
        'INPUT': powiat_z_PRG, 
        'DISTANCE': -0.02,
        'SEGMENTS': 10,
        'DISSOLVE': True,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    # Zamiana poligonu na linie
    granica = processing.run("native:polygonstolines", {
        'INPUT': bufor,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    return granica


def minimalnaPowierzchnia(layer):
    minPowWarstwy = {"OT_PTWP_A":80,"OT_PTZB_A":1000,"OT_PTLZ_A":500, "OT_PTRK_A":1000,"OT_PTUT_A":1000,"OT_PTGN_A":1000,
                     "OT_PTSO_A":1000,"OT_PTWZ_A":1000,"OT_PTNZ_A":1000,"OT_BUWT_A":100,"OT_BUZT_A":175,"OT_KUSK_A":3000,
                     "OT_KUHO_A":3000,"OT_KUHU_A":3000,"OT_KUOS_A":3000,"OT_KUOZ_A":3000,"OT_KUZA_A":3000}
    obiektyZbledami = []
    klasa = layer.name()[-9:]
    granica = adjaMinus2cmBufor(layer)
    for feature in layer.getFeatures():
        geom = feature.geometry()
        if klasa == 'OT_BUZT_A' and feature['rodzaj'] != 'zbiornik':
            continue
        else:
            if geom.area() < minPowWarstwy[klasa]:
                for g in granica.getFeatures():
                    if not geom.intersects(g.geometry()):
                        obiektyZbledami.append(feature)
    
    return obiektyZbledami


def minimalnaPTRKwzgledemPTLZ(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'PTRK_A':
        PTLZ_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_PTRK_A","OT_PTLZ_A"))[0]
        PTRK_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    identyfikatory_bledow = set()
    granica = adjaMinus2cmBufor(layer)
    for PTRK_A_feature in PTRK_A_layer.getFeatures():
        for PTLZ_A_feature in PTLZ_A_layer.getFeatures():
            geom1 = PTRK_A_feature.geometry()
            geom2 = PTLZ_A_feature.geometry()
            if geom1.area() < 2000 and PTRK_A_feature.attribute('rodzaj') == 'krzewy':
                styka = False
                for g in granica.getFeatures():
                    if geom1.intersects(geom2) and not geom1.intersects(g.geometry()) and PTRK_A_feature.id() not in identyfikatory_bledow:
                        styka = True
                        obiektyZbledami.append(PTRK_A_feature)
                        identyfikatory_bledow.add(PTRK_A_feature.id())
    
    return obiektyZbledami


def minimalnaPTTRronda(layer):
    minimalnaPowierzchniaBezWod(layer)
    return obiektyZbledami


def minimalnaPowierzchniaBezWod(layer):
    global obiektyZbledami  # Przekazanie do funkcji powyżej
    obiektyZbledami = []
    minPowWarstwy = {"OT_PTGN_A": 1000, "OT_PTLZ_A": 500, "OT_PTRK_A": 1000, "OT_PTTR_A": 500}
    klasa = layer.name()[-9:]
    granica = adjaMinus2cmBufor(layer)
    index_granica = QgsSpatialIndex()
    index_pokrycie = []
    
    for layer_id, lyr in QgsProject.instance().mapLayers().items():
        if "OT_PT" in lyr.name():
            index = QgsSpatialIndex()
            for feature in lyr.getFeatures():
                index.insertFeature(feature)
            index_pokrycie.append((lyr, index))
            
    for feature in granica.getFeatures():
        index_granica.insertFeature(feature)
        
    # Dodatkowy indeks dla PTTR bez ronda
    if klasa == 'OT_PTTR_A':
        SKRW_P_layer = QgsProject().instance().mapLayersByName(layer.name().replace(klasa, "OT_SKRW_P"))[0]
        index_SKRW_P = QgsSpatialIndex()
        identyfikatory_bledow = set()
        for SKRW_P_feature in SKRW_P_layer.getFeatures():
            if SKRW_P_feature['rodzaj'] == 'rondo':
                index_SKRW_P.insertFeature(SKRW_P_feature)
                
    for feature in layer.getFeatures():
        geom = feature.geometry()
        
        # Sprawdzenie powierzchni
        if klasa in minPowWarstwy and geom.area() > minPowWarstwy[klasa]:
            continue
        
        graniczy_z = set()
        
        # Sprawdzenie sąsiedztwa
        for lyr, index in index_pokrycie:
            for fid in index.intersects(geom.boundingBox()):
                lyr_feature = lyr.getFeature(fid)
                if lyr_feature.id() != feature.id() and geom.intersects(lyr_feature.geometry()):
                    graniczy_z.add(lyr.name())
        
        # Pominięcie obiektów graniczących tylko z OT_PTWP_A
        if len(graniczy_z) == 1 and any(layer_name.endswith('OT_PTWP_A') for layer_name in graniczy_z):
            continue  
        
        if klasa == 'OT_PTTR_A':
            intersects_SKRW_P = any(geom.intersects(SKRW_P_layer.getFeature(fid).geometry()) for fid in index_SKRW_P.intersects(geom.boundingBox()))
            touches_boundary = any(geom.intersects(granica.getFeature(fid).geometry()) for fid in index_granica.intersects(geom.boundingBox()))
            
            # Obsługa wysp (PB)– sprawdzenie, czy obiekt jest w pełni otoczony wodą
            surrounded_by_water = all(any(lyr.name().endswith('OT_PTWP_A') for lyr, index in index_pokrycie if fid in index.intersects(geom.boundingBox())) for fid in index.intersects(geom.boundingBox()))
            
            if not intersects_SKRW_P and not touches_boundary and not surrounded_by_water and feature.id() not in identyfikatory_bledow:
                obiektyZbledami.append(feature)
                identyfikatory_bledow.add(feature.id())
        else:
            styka = any(geom.intersects(g.geometry()) for g in granica.getFeatures())
            if not styka:
                obiektyZbledami.append(feature)
    
    return obiektyZbledami


def minimalnaPTPL(layer):
    global obiektyZbledami
    obiektyZbledami = []
    
    minPowPTPL = 1000
    
    granica = adjaMinus2cmBufor(layer)
    if granica is None or not granica.isValid():
        return obiektyZbledami
    
    index_granica = QgsSpatialIndex(granica.getFeatures())
    
    for feature in layer.getFeatures():
        # Pomijamy place, które mają nazwę
        if "placNazwa1" in feature.fields().names() and feature["placNazwa1"]:
            continue
        
        geom = feature.geometry()
        
        # Sprawdzenie minimalnej powierzchni
        if geom.area() < minPowPTPL:
            touches_boundary = any(
                geom.intersects(granica.getFeature(fid).geometry())
                for fid in index_granica.intersects(geom.boundingBox())
            )
            
            if not touches_boundary:
                obiektyZbledami.append(feature)
    
    return obiektyZbledami


def minimalnaBUIT(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'BUIT_A':
        BUIT_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    granica = adjaMinus2cmBufor(layer)
    for BUIT_A_feature in BUIT_A_layer.getFeatures():
        geom = BUIT_A_feature.geometry()
        if geom.area() < 1000 and BUIT_A_feature['rodzaj'] in ['zespół dystrybutorów paliwa', 'zespół transformatorów']:
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(BUIT_A_feature)
    
    return obiektyZbledami


def minimalnaKUPG(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'KUPG_A':
        KUPG_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    granica = adjaMinus2cmBufor(layer)
    for KUPG_A_feature in KUPG_A_layer.getFeatures():
        geom = KUPG_A_feature.geometry()
        if geom.area() < 3000 and KUPG_A_feature['rodzaj'] not in ['oczyszczalnia ścieków', 'podstacja elektroenergetyczna', 'teren ujęcia wody']:
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(KUPG_A_feature)
    
    return obiektyZbledami


def minimalnaKUKO(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'KUKO_A':
        KUKO_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    granica = adjaMinus2cmBufor(layer)
    for KUKO_A_feature in KUKO_A_layer.getFeatures():
        geom = KUKO_A_feature.geometry()
        if geom.area() < 3000 and KUKO_A_feature['rodzaj'] != 'stacja paliw':
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(KUKO_A_feature)
    
    return obiektyZbledami


def minimalnaKUSC(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'KUSC_A':
        KUSC_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    granica = adjaMinus2cmBufor(layer)
    for KUSC_A_feature in KUSC_A_layer.getFeatures():
        geom = KUSC_A_feature.geometry()
        if geom.area() < 5000 and KUSC_A_feature['rodzaj'] == 'zespół sakralny lub klasztorny':
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(KUSC_A_feature)
    
    return obiektyZbledami


def minimalnaOIKM(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'OIKM_A':
        OIKM_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    granica = adjaMinus2cmBufor(layer)
    for OIKM_A_feature in OIKM_A_layer.getFeatures():
        geom = OIKM_A_feature.geometry()
        if geom.area() < 500 and OIKM_A_feature['rodzaj'] == 'schody':
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(OIKM_A_feature)
    
    return obiektyZbledami


def minimalnaOIORschron(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'OIOR_A':
        OIOR_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    granica = adjaMinus2cmBufor(layer)
    for OIOR_A_feature in OIOR_A_layer.getFeatures():
        geom = OIOR_A_feature.geometry()
        if geom.area() < 100 and OIOR_A_feature['rodzaj'] == 'bunkier lub schron':
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(OIOR_A_feature)
    
    return obiektyZbledami


def minimalnaOIORszklarnia(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'OIOR_A':
        OIOR_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    granica = adjaMinus2cmBufor(layer)
    for OIOR_A_feature in OIOR_A_layer.getFeatures():
        geom = OIOR_A_feature.geometry()
        if geom.area() < 100 and OIOR_A_feature['rodzaj'] == 'szklarnia niebędąca budynkiem':
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(OIOR_A_feature)
    
    return obiektyZbledami


def minimalnaOIORwiataAltana(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'OIOR_A':
        KUKO_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_OIOR_A","OT_KUKO_A"))[0]
        OIOR_A_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    identyfikatory_bledow = set()
    granica = adjaMinus2cmBufor(layer)
    for OIOR_A_feature in OIOR_A_layer.getFeatures():
        for KUKO_A_feature in KUKO_A_layer.getFeatures():
            geom1 = OIOR_A_feature.geometry()
            geom2 = KUKO_A_feature.geometry()
            if geom1.area() < 200 and OIOR_A_feature['rodzaj'] == 'wiata lub altana' or (geom1.intersects(geom2) and KUKO_A_feature['rodzaj'] == 'stacja paliw'): 
                styka = False
                for g in granica.getFeatures():
                    if not geom1.intersects(g.geometry()) and OIOR_A_feature.id() not in identyfikatory_bledow:
                        styka = True
                        obiektyZbledami.append(OIOR_A_feature)
                        identyfikatory_bledow.add(OIOR_A_feature.id())
    
    return obiektyZbledami


def granicePowiatow():
    config = configparser.ConfigParser()
    mainPath = pathlib.Path(QgsApplication.qgisSettingsDirPath())/pathlib.Path(r"python/plugins/Walidator_plikow_gml/")
    config.read(str(mainPath)+'/Walidator_plikow_gml.ini')
    granicePowiatowPath = config['DEFAULT']['granicepowiatow']
    granicePowiatow_A = QgsVectorLayer(granicePowiatowPath, 'GranicePowiatow', 'ogr')
    
    # rozbicie multipoligon na poligony
    pojedynczeGranice = processing.run("native:multiparttosingleparts", {
        'INPUT': granicePowiatow_A,
        'OUTPUT': 'memory:'
    })
    
    # zamiana typu geometrii z poligonu na linię
    granicePowiatow_L = processing.run("native:polygonstolines", {
        'INPUT': pojedynczeGranice['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    return granicePowiatow_L


def czyPrzecinaGranicePowiatuDlugoscPonizej50m(layer): # kompatabilnosć w szablonie kontroli
    czyPrzecinaGranicePowiatuDlugoscPonizej25m(layer)


def czyPrzecinaGranicePowiatuDlugoscPonizej25m(layer):
    try:
        obiektyZbledami = []
        granicePowiatow_L = granicePowiatow()
        alg_params = {
            'INPUT': granicePowiatow_L['OUTPUT'],
            'DISTANCE': 7.5, # Odległość bufora
            'SEGMENTS': 8, # Ilość segmentów na kwadrant, większa wartość = bardziej okrągły bufor
            'END_CAP_STYLE': 0,
            'JOIN_STYLE': 0,
            'MITER_LIMIT': 2,
            'DISSOLVE': False, # Ustawienie na True spowoduje scalenie wszystkich buforów w jeden obiekt
            'OUTPUT': 'memory:'
        }
        buforGranicy = processing.run('qgis:buffer', alg_params)['OUTPUT']
        index = QgsSpatialIndex()
        for granica in buforGranicy.getFeatures():
            index.insertFeature(granica)
        for obj in layer.getFeatures():
            if obj.geometry() is None:
                continue
            if obj.geometry().length() < 25 and obj.attribute("kodKarto10k") != NULL:
                czyPrzecina = False
                intersecting_ids = index.intersects(obj.geometry().boundingBox())
                for id in intersecting_ids:
                    granica = buforGranicy.getFeature(id)
                    distance = obj.geometry().distance(granica.geometry())
                    if 0 < distance < 25:
                        czyPrzecina = True
                        break
                if czyPrzecina:
                    obiektyZbledami.append(obj)
    except:
        pass
    return obiektyZbledami


def czyObiektyWewnatrzPowiatu(layer, teryt):
    obiektyZbledami = []
    config = configparser.ConfigParser()
    mainPath = pathlib.Path(QgsApplication.qgisSettingsDirPath()) / pathlib.Path("python/plugins/Walidator_plikow_gml/")
    config.read(str(mainPath) + '/Walidator_plikow_gml.ini')
    granicePowiatowPath = config['DEFAULT']['granicepowiatow']
    
    granicePowiatow_A = QgsVectorLayer(granicePowiatowPath, 'GranicePowiatow', 'ogr')
    granicePowiatow = processing.run("native:multiparttosingleparts", {
        'INPUT': granicePowiatow_A,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    request = QgsFeatureRequest(QgsExpression(f"JPT_KOD_JE = '{teryt}'"))
    granica_powiatu_z_PRG = QgsVectorLayer("Polygon?crs=epsg:2180&field=gml_id:string(254)", "granica powiatu z PRG", "memory")
    granica_powiatu_z_PRG.dataProvider().addFeatures(granicePowiatow.getFeatures(request))
    
    bufor = processing.run("native:buffer", {
        'INPUT': granica_powiatu_z_PRG,
        'DISTANCE': 0.02,
        'SEGMENTS': 10,
        'DISSOLVE': True,
        'OUTPUT': 'memory:'
    })
    
    buforLinie = processing.run("native:polygonstolines", {
        'INPUT': bufor['OUTPUT'], 
        'OUTPUT': 'memory:'
    })["OUTPUT"]
    
    liniePrzecinajace = processing.run('native:extractbylocation', {
        'INPUT': layer,
        'INTERSECT': buforLinie,
        'PREDICATE': [0],
        'OUTPUT': 'memory:'
    })
    
    rozlaczne = processing.run('native:extractbylocation', {
        'INPUT': layer,
        'INTERSECT': bufor['OUTPUT'],
        'PREDICATE': [2],
        'OUTPUT': 'memory:'
    })
    
    if liniePrzecinajace['OUTPUT'].featureCount() > 0 or rozlaczne['OUTPUT'].featureCount() > 0:
        czyDodacGranice = all(lyr.name() != "granica powiatu z PRG" for lyr in QgsProject.instance().mapLayers().values())
        if czyDodacGranice:
            QgsProject.instance().addMapLayer(granica_powiatu_z_PRG)
        
        obiektyZbledami.extend(liniePrzecinajace['OUTPUT'].getFeatures())
        obiektyZbledami.extend(rozlaczne['OUTPUT'].getFeatures())
    
    return obiektyZbledami


def czyOdleglosciMiedzyPoziomicami2m(layer):
    obiekty_z_bledami = []
    
    poziomice = processing.run("qgis:extractbyexpression", {
        'INPUT': layer,
        'EXPRESSION': '"rodzaj" = \'poziomica\' and "kodKarto10k" != \'\'',
        'FAIL_OUTPUT': 'memory:',
        'OUTPUT': 'memory:'
    })
    
    # bufor
    bufor = processing.run("native:buffer", {
        'INPUT': poziomice['OUTPUT'],
        'DISTANCE': 0.999,
        'END_CAP_STYLE': 0,
        'JOIN_STYLE': 0,
        'MITER_LIMIT': 2,
        'SEGMENTS': 5,
        'DISSOLVE': False,
        'OUTPUT': 'memory:'
    })
    
    union = processing.run("qgis:union", {
        'INPUT': bufor['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    nakladanie = QgsVectorLayer("Polygon?crs=epsg:2180&field=gml_id:string(254)", "nakładania buforów poziomic", "memory")
    geom_union = []
    for f in union['OUTPUT'].getFeatures():
        g = f.geometry()
        geom_wkt = g.asWkt()
        obiektBledny = False
        if not geom_wkt in geom_union:
            geom_union.append(geom_wkt)
        else:
            wysokosci = []
            x = bufor['OUTPUT'].getFeatures(g.boundingBox())
            for obiekt_bliski in x:
                if g.intersects(obiekt_bliski.geometry()) == True:
                    if obiekt_bliski['wysokosc'] in wysokosci:
                        obiektBledny = True
                    else:
                        wysokosci.append(obiekt_bliski['wysokosc'])
            if obiektBledny:
                continue
            nakladanie.dataProvider().addFeatures([f])
    
    QgsProject.instance().addMapLayer(nakladanie)
    
    extractbylocation1 = processing.run("qgis:extractbylocation", {
        'INPUT': bufor['OUTPUT'],
        'PREDICATE': 0,
        'INTERSECT': nakladanie,
        'OUTPUT': 'memory:'
    })
    
    extractbylocation2 = processing.run("qgis:extractbylocation", {
        'INPUT': poziomice['OUTPUT'],
        'PREDICATE': 6,
        'INTERSECT':extractbylocation1['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    if extractbylocation2['OUTPUT'].featureCount() > 0:
        for obj in extractbylocation2['OUTPUT'].getFeatures():
            obiekty_z_bledami.append(obj)
    
    return obiekty_z_bledami


def nadmiernaSegmentacja(layer):
    id_to_feature = {feature.id(): feature for feature in layer.getFeatures()} # Tworzenie słownika mapującego ID obiektu na obiekt
    obiekty_z_bledami = []
    spatial_index = QgsSpatialIndex(layer.getFeatures(), flags=QgsSpatialIndex.FlagStoreFeatureGeometries)
    for obj1 in layer.getFeatures():
        nearestNeighbors = spatial_index.nearestNeighbor(obj1.geometry(), 2, 0)
        for nn in nearestNeighbors:
            if obj1.id() == nn:
                continue
            obj2 = id_to_feature[nn]
            atrybuty1 = obj1.attributes()[2:]
            atrybuty2 = obj2.attributes()[2:]
            if not obj1 in obiekty_z_bledami and obj1.geometry().distance(obj2.geometry()) < 0.01 and atrybuty1 == atrybuty2 and not obj1.geometry().equals(obj2.geometry()):
                # sprawdzenie liczby wspólnych wierzchołków. Musi być > 1
                vertices1 = [vertex for vertex in obj1.geometry().vertices()]
                vertices2 = [vertex for vertex in obj2.geometry().vertices()]
                common_vertices = [v for v in vertices1 if v in vertices2]
                if len(common_vertices) > 1:
                    if len(common_vertices) == 2:
                        if vertices1[0] == vertices1[-1] or vertices2[0] == vertices2[-1]:
                            pass
                        else:
                            obiekty_z_bledami.append(obj1)
                            break
                    else:
                        obiekty_z_bledami.append(obj1)
                        break
    
    return obiekty_z_bledami


def nadmiernaSegmentacja_rtwl(layer):
    poziomice = processing.run("qgis:extractbyexpression", {
        'INPUT': layer,
        'EXPRESSION': '"rodzaj" = \'poziomica\' and "kodKarto10k" != \'\'',
        'FAIL_OUTPUT': 'memory:',
        'OUTPUT': 'memory:'
    })
    
    id_to_feature = {feature.id(): feature for feature in poziomice['OUTPUT'].getFeatures()} # Tworzenie słownika mapującego ID obiektu na obiekt
    obiekty_z_bledami = []
    hash_to_ids = {}
    spatial_index = QgsSpatialIndex(poziomice['OUTPUT'].getFeatures(), flags=QgsSpatialIndex.FlagStoreFeatureGeometries)
    
    for feature in id_to_feature.values():
        spatial_index.addFeature(feature)
    for feature_id, feature in id_to_feature.items():
        # Utwórz hash na podstawie atrybutów (pomijając pierwsze dwa)
        attrs_hash = hash(tuple(feature.attributes()[2:]))
        if attrs_hash in hash_to_ids:
            hash_to_ids[attrs_hash].append(feature_id)
        else:
            hash_to_ids[attrs_hash] = [feature_id]
    for attrs_hash, ids in hash_to_ids.items():
       if len(ids) > 1: # Jeśli więcej niż jeden obiekt ma ten sam hash
           for id in ids:
               obj1 = id_to_feature[id]
               bbox = obj1.geometry().boundingBox()
               bbox.grow(0.01)
               candidates_ids = spatial_index.intersects(bbox)
               candidates_ids.remove(id)
               for candidate_id in candidates_ids:
                   if candidate_id in ids: # Porównujemy tylko w ramach tej samej grupy hashowej
                        obj2 = id_to_feature[candidate_id]
                        if not obj1 in obiekty_z_bledami and obj1.geometry().distance(obj2.geometry()) < 0.01 and not obj1.geometry().equals(obj2.geometry()):
                            obiekty_z_bledami.append(obj1)
                            break
    
    return obiekty_z_bledami


def przewerteksowanie(layer):
    obiekty_z_bledami = []
    
    poziomice = processing.run("qgis:extractbyexpression", {
        'INPUT': layer,
        'EXPRESSION': '"rodzaj" = \'poziomica\'',
        'FAIL_OUTPUT': 'memory:',
        'OUTPUT': 'memory:'
    })
    
    simplifygeometries = processing.run("native:simplifygeometries", {
        'INPUT': poziomice['OUTPUT'],
        'METHOD': 0, # DP
        'TOLERANCE': 0.05, # 5 cm strzałki
        'OUTPUT': 'memory:'
        })
    
    roznica = processing.run("qgis:difference", {
        'INPUT': poziomice['OUTPUT'],
        'OVERLAY': simplifygeometries['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    pojedynczeObiekty = processing.run("native:multiparttosingleparts", {
        'INPUT': roznica['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    if pojedynczeObiekty['OUTPUT'].featureCount() > 0:
        for obj in pojedynczeObiekty['OUTPUT'].getFeatures():
            obiekty_z_bledami.append(obj)
    
    return obiekty_z_bledami


def przecieciaLiniiNapieciaPodziemna(layer):
    obiekty_z_bledami = []
    OT_SULN_L_layer = None
    OT_BUWT_P_layer = None
    if layer.name()[-6:] == 'SULN_L':
        OT_BUWT_P_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_SULN_L","OT_BUWT_P"))[0]
        OT_SULN_L_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    index = QgsSpatialIndex()
    identyfikatory_bledow = set() # Zbiór do śledzenia identyfikatorów błędnych obiektów w celu uniknięcia powieleń
    for feat in OT_BUWT_P_layer.getFeatures():
        index.insertFeature(feat) # Budowanie indeksu przestrzennego do szybszego przetworzenia
    for OT_SULN_L_feature in OT_SULN_L_layer.getFeatures():
        geom = OT_SULN_L_feature.geometry()
        all_points = [vertex for vertex in geom.vertices()]
        # Usuń pierwszy i ostatni punkt (wierzchołek)
        if len(all_points) <= 3:  # Pomiń linie z trzema lub dwoma wierzchołkami
            continue
        analysis_points = [QgsPointXY(vertex.x(), vertex.y()) for vertex in all_points[1:-1]]
        new_geom = QgsGeometry.fromPolylineXY(analysis_points)
        kodkarto = OT_SULN_L_feature['kodKarto10k']
        rodzaj = OT_SULN_L_feature['rodzaj']
        if kodkarto == '0010_444' and rodzaj in ['linia elektroenergetyczna najwyższego napięcia', 'linia elektroenergetyczna wysokiego napięcia']:
            ids = index.intersects(new_geom.boundingBox()) # intersekcja z obiektem
            intersects = False
            for id in ids:
                other_feat = OT_BUWT_P_layer.getFeature(id)
                if other_feat['rodzaj'] == 'słup energetyczny' and new_geom.intersects(other_feat.geometry()) and OT_SULN_L_feature.id() not in identyfikatory_bledow:
                    intersects = True
                    obiekty_z_bledami.append(OT_SULN_L_feature)
                    identyfikatory_bledow.add(OT_SULN_L_feature.id())
        if rodzaj == 'linia elektroenergetyczna średniego napięcia' and kodkarto != '0010_444':
                 obiekty_z_bledami.append(OT_SULN_L_feature)
                 identyfikatory_bledow.add(OT_SULN_L_feature.id())
    
    return obiekty_z_bledami


def przecieciaLiniiNapieciaNadziemna(layer):
    obiekty_z_bledami = []
    OT_SULN_L_layer = None
    OT_BUWT_P_layer = None
    if layer.name()[-6:] == 'SULN_L':
        OT_BUWT_P_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_SULN_L","OT_BUWT_P"))[0]
        OT_SULN_L_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    index = QgsSpatialIndex()
    identyfikatory_bledow = set() # Zbiór do śledzenia identyfikatorów błędnych obiektów w celu uniknięcia powieleń
    for feat in OT_BUWT_P_layer.getFeatures():
        index.insertFeature(feat) # Budowanie indeksu przestrzennego do szybszego przetworzenia
    for OT_SULN_L_feature in OT_SULN_L_layer.getFeatures():
        geom = OT_SULN_L_feature.geometry()
        all_points = [vertex for vertex in geom.vertices()]
        # Usuń pierwszy i ostatni punkt (wierzchołek)
        if len(all_points) <= 3:  # Pomiń linie z trzema lub dwoma wierzchołkami
            continue
        analysis_points = [QgsPointXY(vertex.x(), vertex.y()) for vertex in all_points[1:-1]]
        new_geom = QgsGeometry.fromPolylineXY(analysis_points)
        kodkarto = OT_SULN_L_feature['kodKarto10k']
        rodzaj = OT_SULN_L_feature['rodzaj']
        if kodkarto == '0010_446' and rodzaj in ['linia elektroenergetyczna najwyższego napięcia', 'linia elektroenergetyczna wysokiego napięcia']:
            ids = index.intersects(new_geom.boundingBox()) # intersekcja z obiektem
            intersects = False
            for id in ids:
                other_feat = OT_BUWT_P_layer.getFeature(id)
                if new_geom.intersects(other_feat.geometry()) and other_feat['rodzaj'] == 'słup energetyczny':
                    intersects = True
                    break
            if not intersects and OT_SULN_L_feature.id() not in identyfikatory_bledow:
                obiekty_z_bledami.append(OT_SULN_L_feature)
                identyfikatory_bledow.add(OT_SULN_L_feature.id())
    
    return obiekty_z_bledami


def kontrola_OT_ADMS_P_z_OT_ADMS_A(layer):
    obiekty_z_bledami = []
    OT_ADMS_A_layer = None
    OT_ADMS_P_layer = None
    if layer.name()[-6:] == 'ADMS_P':
        try:
            OT_ADMS_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_ADMS_P","OT_ADMS_A"))[0]
            OT_ADMS_P_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
        except:
            return obiekty_z_bledami
    if OT_ADMS_A_layer and OT_ADMS_P_layer:
        identyfikatory_bledow = set() # Zbiór do śledzenia identyfikatorów błędnych obiektów
        nazwy_adms_p = set([feature['nazwa'] for feature in OT_ADMS_P_layer.getFeatures()])
        nazwy_adms_a = set([feature['nazwa'] for feature in OT_ADMS_A_layer.getFeatures()])
        # Sprawdzenie przecięcia i nazw dla obiektów z OT_ADMS_A
        for OT_ADMS_A_feature in OT_ADMS_A_layer.getFeatures():
            is_intersected = False
            nazwa_adms_a = OT_ADMS_A_feature['nazwa']
            # Sprawdzenie przecięcia dla każdego obiektu z OT_ADMS_P
            for OT_ADMS_P_feature in OT_ADMS_P_layer.getFeatures():
                nazwa_adms_p = OT_ADMS_P_feature['nazwa']
                if OT_ADMS_P_feature.geometry().intersects(OT_ADMS_A_feature.geometry()) or OT_ADMS_A_feature.geometry().contains(OT_ADMS_P_feature.geometry()):
                    is_intersected = True
                    break
            if not is_intersected or nazwa_adms_a not in nazwy_adms_p: #... oraz czy nazwy z OT_ADMS_A występują w OT_ADMS_P
                if OT_ADMS_A_feature.id() not in identyfikatory_bledow:
                    obiekty_z_bledami.append(OT_ADMS_A_feature)
                    identyfikatory_bledow.add(OT_ADMS_A_feature.id())
            # Sprawdzenie, czy nazwy z OT_ADMS_P występują w OT_ADMS_A
            if OT_ADMS_P_feature['nazwa'] not in nazwy_adms_a and OT_ADMS_P_feature.id() not in identyfikatory_bledow:
                obiekty_z_bledami.append(OT_ADMS_P_feature)
                identyfikatory_bledow.add(OT_ADMS_P_feature.id())
    
    return obiekty_z_bledami


def kontrolaTERCpunkt(layer):
    obiektyZbledami = []
    adms = None
    adja = None
    if layer.name()[-6:] == 'ADMS_P':
        try:
            adja = QgsProject().instance().mapLayersByName(layer.name().replace("OT_ADMS_P","OT_ADJA_A"))[0]
            adms = QgsProject().instance().mapLayersByName(layer.name())[0]
        except:
            return obiektyZbledami 
    # Zestaw do śledzenia już dodanych identyfikatorów TERYT
    przetworzone_teryt = set()
    
    # Sprawdzenie, czy są warstwy
    if adms and adja:
        expression = """ "rodzaj" = 'gmina' """ 
        # Wykonaj selekcję
        adja.selectByExpression(expression, QgsVectorLayer.SetSelection)
        selected = adja.selectedFeatures()
        # Przygotuj listę identyfikatorów TERYT z warstwy ADJA jako tekst
        identyfikatory_teryt = {str(feature["identyfikatorTerytJednostki"]).zfill(7): feature for feature in selected}
        # Przygotuj słownik dla ADMS_P: klucz to IdentyfikatorTERC, wartość to lista nazw
        identyfikatory_terc_adms = {}
        for feature in adms.getFeatures():
           teryt_adms = str(feature["IdentyfikatorTERC"]).zfill(7)
           if teryt_adms in identyfikatory_terc_adms:
               identyfikatory_terc_adms[teryt_adms].append(feature)
           else:
               identyfikatory_terc_adms[teryt_adms] = [feature]
        # Dla każdego identyfikatora TERYT/TERC
        for teryt_adms, adms_features in identyfikatory_terc_adms.items():
           if teryt_adms not in identyfikatory_teryt:
               for adms_feature in adms_features:
                   obiektyZbledami.append(adms_feature)
        adja.removeSelection()
    
    return obiektyZbledami


def kontrolaTERCpowierzchnia(layer):
    obiektyZbledami = []
    adms = None
    adja = None
    if layer.name()[-6:] == 'ADMS_A':
        try:
            adja = QgsProject().instance().mapLayersByName(layer.name().replace("ADMS","ADJA"))[0]
            adms = QgsProject().instance().mapLayersByName(layer.name())[0]
        except:
            return obiektyZbledami
    # Zestaw do śledzenia już dodanych identyfikatorów TERYT
    przetworzone_teryt = set()
    
    # Sprawdzenie, czy jsą warstwy
    if adms and adja:
        # Iteruj przez warstwy
        expression = """ "rodzaj" = 'gmina' """ 
        # Wykonaj selekcję na ADJA_A
        adja.selectByExpression(expression, QgsVectorLayer.SetSelection)
        selected = adja.selectedFeatures()
        # Przygotuj listę identyfikatorów TERYT z warstwy ADJA jako tekst
        identyfikatory_teryt = {str(feature["identyfikatorTerytJednostki"]).zfill(7): feature  for feature in selected}
        # Przygotuj słownik dla ADMS_A: klucz to IdentyfikatorTERC, wartość to lista nazw
        identyfikatory_terc_adms = {}
        for feature in adms.getFeatures():
            teryt_adms = str(feature["IdentyfikatorTERC"]).zfill(7)
            if teryt_adms in identyfikatory_terc_adms:
                identyfikatory_terc_adms[teryt_adms].append(feature)
            else:
                identyfikatory_terc_adms[teryt_adms] = [feature]
        #Sprawdzenie: kod TERYT w ADMS_A, ale nie w ADJA
        for teryt_adms, adms_features in identyfikatory_terc_adms.items():
           if teryt_adms not in identyfikatory_teryt:
               for adms_feature in adms_features:
                    obiektyZbledami.append(adms_feature)
        adja.removeSelection()
    
    return obiektyZbledami


def fullCoverage(layer):
    obiektyZbledami = []
    adja = None
    wszystkieObiektyZPokrycia = QgsVectorLayer("Polygon?crs=epsg:" + str(2180), "Wszystkie obiekty z pokrycia", "memory")
    pokrycie = []
    config = configparser.ConfigParser()
    mainPath = pathlib.Path(QgsApplication.qgisSettingsDirPath()) / pathlib.Path(r"python/plugins/Walidator_plikow_gml/")
    config.read(str(mainPath) + '/Walidator_plikow_gml.ini')
    granicePowiatowPath = config['DEFAULT']['granicepowiatow']
    granicePowiatow = QgsVectorLayer(granicePowiatowPath, 'GranicePowiatow', 'ogr')
    
    granicePowiatow = processing.run("native:multiparttosingleparts", {
        'INPUT': granicePowiatow,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    powiat_z_PRG = QgsVectorLayer("Polygon?crs=epsg:2180&field=gml_id:string(254)", "granica powiatu z PRG", "memory")
    terytPowiatu = int(layer.name()[-15:-11])
    
    for obj in granicePowiatow.getFeatures():
        if str(obj['JPT_KOD_JE']) == str(terytPowiatu):
            powiat_z_PRG.dataProvider().addFeatures([obj])
            break
        
    adja = powiat_z_PRG
    
    for layer_id, lyr in QgsProject.instance().mapLayers().items():
        if "OT_PT" in lyr.name():
            pokrycie.append(lyr)
            
    for l in pokrycie:
        for feature in l.getFeatures():
            wszystkieObiektyZPokrycia.dataProvider().addFeatures([feature])
            
    if adja and not QgsProject.instance().mapLayersByName("nakładania w pokryciu terenu") and not QgsProject.instance().mapLayersByName("dziury w pokryciu terenu"):
        nakladanie = QgsVectorLayer("Polygon?crs=epsg:2180&field=gml_id:string(254)", "nakładania w pokryciu terenu", "memory")
        dziury = QgsVectorLayer("Polygon?crs=epsg:2180&field=gml_id:string(254)", "dziury w pokryciu terenu", "memory")
        
        isvalid_wszystkieObiektyZPokrycia = processing.run("qgis:checkvalidity", {
            'INPUT_LAYER': wszystkieObiektyZPokrycia,
            'METHOD': 2,
            'IGNORE_RING_SELF_INTERSECTION': False,
            'VALID_OUTPUT': 'memory:',
            'INVALID_OUTPUT': 'memory:',
            'ERROR_OUTPUT': 'memory:'
        })
        
        if isvalid_wszystkieObiektyZPokrycia['INVALID_OUTPUT'].featureCount() > 0:
            isvalid_wszystkieObiektyZPokrycia['INVALID_OUTPUT'].setName("błędne geometrie obiektów pokrycia terenu")
            QgsProject.instance().addMapLayer(isvalid_wszystkieObiektyZPokrycia['INVALID_OUTPUT'])
            
        if isvalid_wszystkieObiektyZPokrycia['ERROR_OUTPUT'].featureCount() > 0:
            isvalid_wszystkieObiektyZPokrycia['ERROR_OUTPUT'].setName("lokalizacje błędów geometrii obiektów pokrycia terenu")
            QgsProject.instance().addMapLayer(isvalid_wszystkieObiektyZPokrycia['ERROR_OUTPUT'])
            
        try:
            union = processing.run("qgis:union", {
                'INPUT': isvalid_wszystkieObiektyZPokrycia['VALID_OUTPUT'],
                'OUTPUT': 'memory:'
            })
        except:
            return []
            
        geom_union = set()
        for f in union['OUTPUT'].getFeatures():
            g = f.geometry()
            geom_wkt = g.asWkt()
            if geom_wkt not in geom_union:
                geom_union.add(geom_wkt)
            else:
                if f.geometry().area() > 2:
                    nakladanie.dataProvider().addFeatures([f])
                    
        if nakladanie.featureCount() > 0:
            QgsProject.instance().addMapLayer(nakladanie)
            nakladanie.startEditing()
            for n in nakladanie.getFeatures():
                n.setAttribute(0, 'nie dotyczy')
                nakladanie.updateFeature(n)
                obiektyZbledami.append(n)
            nakladanie.commitChanges()
            QgsProject.instance().addMapLayer(nakladanie)
            
        if not QgsProject.instance().mapLayersByName("dziury w pokryciu terenu"):
            buforMinus1cm = processing.run("native:buffer", {
                'INPUT': adja,
                'DISTANCE': -0.02,
                'SEGMENTS': 10,
                'DISSOLVE': True,
                'OUTPUT': 'memory:'
            })['OUTPUT']
            
            roznica = processing.run("qgis:difference", {
                'INPUT': buforMinus1cm,
                'OVERLAY': isvalid_wszystkieObiektyZPokrycia['VALID_OUTPUT'],
                'OUTPUT': 'memory:'
            })['OUTPUT']
            
            pojedynczeDziury = processing.run("native:multiparttosingleparts", {
                'INPUT': roznica,
                'OUTPUT': 'memory:'
            })['OUTPUT']
            
            dziury.startEditing()
            for n in pojedynczeDziury.getFeatures():
                if n.geometry().area() > 2:
                    nowyRekord = QgsFeature(dziury.fields())
                    nowyRekord.setAttribute(0, 'nie dotyczy')
                    nowyRekord.setGeometry(n.geometry())
                    dziury.addFeature(nowyRekord)
                    obiektyZbledami.append(nowyRekord)
            dziury.commitChanges()
            
            if dziury.featureCount() > 0:
                QgsProject.instance().addMapLayer(dziury)
                
    return obiektyZbledami


def jednostkaEwidencyjnaFullCoverage(layer):
    obiektyZbledami = []
    wszystkieJednostkiEwidencyjne = QgsVectorLayer("Polygon?crs=epsg:" + str(4326), "Wszystkie jednostki ewidencyjne", "memory")
    warstwy = []
    for layer_id, lyr in QgsProject.instance().mapLayers().items():
        if lyr.name().__contains__("EGB_JednostkaEwidencyjna"):
            reprojectlayer = processing.run("native:reprojectlayer", {
                'INPUT': lyr,
                'TARGET_CRS':QgsCoordinateReferenceSystem('EPSG:4326'),
                'OUTPUT': 'memory:'
            })
            warstwy.append(reprojectlayer['OUTPUT'])
    
    for l in warstwy:
        for feature in l.getFeatures():
            wszystkieJednostkiEwidencyjne.dataProvider().addFeatures([feature])
    
    # Iteracja przez każdą parę warstw do sprawdzenia pokryć
    if not QgsProject.instance().mapLayersByName("nakładania w pokryciu jednostek ewidencyjnych") and not QgsProject.instance().mapLayersByName("dziury w pokryciu jednostek ewidencyjnych"):
        nakladanie = QgsVectorLayer("Polygon?crs=epsg:4326&field=gml_id:string(254)", "nakładania w pokryciu jednostek ewidencyjnych", "memory")
        dziury = QgsVectorLayer("Polygon?crs=epsg:4326&field=gml_id:string(254)", "dziury pomiędzy jednostkami ewidencyjnymi", "memory")
        
        isvalid_wszystkieObiektyZPokrycia = processing.run("qgis:checkvalidity", {
            'INPUT_LAYER': wszystkieJednostkiEwidencyjne,
            'METHOD': 2,
            'IGNORE_RING_SELF_INTERSECTION': False,
            'VALID_OUTPUT': 'memory:',
            'INVALID_OUTPUT': 'memory:',
            'ERROR_OUTPUT': 'memory:'
        })
        
        if isvalid_wszystkieObiektyZPokrycia['INVALID_OUTPUT'].featureCount() > 0:
            isvalid_wszystkieObiektyZPokrycia['INVALID_OUTPUT'].setName("błędne geometrie obiektów jednostek ewidencyjnych")
            QgsProject.instance().addMapLayer(isvalid_wszystkieObiektyZPokrycia['INVALID_OUTPUT'])
        
        if isvalid_wszystkieObiektyZPokrycia['ERROR_OUTPUT'].featureCount() > 0:
            isvalid_wszystkieObiektyZPokrycia['ERROR_OUTPUT'].setName("lokalizacje błędów geometrii obiektów jednostek ewidencyjnych")
            QgsProject.instance().addMapLayer(isvalid_wszystkieObiektyZPokrycia['ERROR_OUTPUT'])
        
        union = processing.run("qgis:union", {
            'INPUT': isvalid_wszystkieObiektyZPokrycia['VALID_OUTPUT'],
            'OUTPUT': 'memory:'
        })
        
        pojedynczeNakladania = processing.run("native:multiparttosingleparts", {
            'INPUT': union['OUTPUT'],
            'OUTPUT': 'memory:'
        })
        
        geom_union = []
        for f in pojedynczeNakladania['OUTPUT'].getFeatures():
            g = f.geometry()
            geom_wkt = g.asWkt()
            if not geom_wkt in geom_union:
                geom_union.append(geom_wkt)
            else:
                nakladanie.dataProvider().addFeatures([f])
        
        if nakladanie.featureCount() > 0:
            nakladanie.startEditing()
            for n in nakladanie.getFeatures():
                n.setAttribute(0,'nie dotyczy')
                nakladanie.updateFeature(n)
                obiektyZbledami.append(n)
            nakladanie.commitChanges()
            QgsProject.instance().addMapLayer(nakladanie)
        
        dissolve = processing.run("qgis:dissolve", {
            'INPUT': isvalid_wszystkieObiektyZPokrycia['VALID_OUTPUT'],
            'FIELD': [],
            'OUTPUT': 'memory:'
        })
        
        deleteholes = processing.run("native:deleteholes", {
            'INPUT': dissolve['OUTPUT'],
            'OUTPUT': 'memory:'
        })
        
        roznica = processing.run("qgis:difference", {
            'INPUT': deleteholes['OUTPUT'],
            'OVERLAY': dissolve['OUTPUT'],
            'OUTPUT': 'memory:'
        })
        
        multiparttosingleparts = processing.run("qgis:multiparttosingleparts", {
            'INPUT': roznica['OUTPUT'],
            'OUTPUT': 'memory:'
        })
        
        if not QgsProject.instance().mapLayersByName("dziury pomiędzy jednostkami ewidencyjnymi"):
            dziury.startEditing()
            for n in multiparttosingleparts['OUTPUT'].getFeatures():
                if n.geometry().area() > 0: # 0- bez tolerancji
                    nowyRekord = QgsFeature(dziury.fields())
                    nowyRekord.setAttribute(0,'nie dotyczy')
                    nowyRekord.setGeometry(n.geometry())
                    dziury.addFeature(nowyRekord)
                    obiektyZbledami.append(nowyRekord)
            dziury.commitChanges()
            
            if dziury.featureCount() > 0:
                QgsProject.instance().addMapLayer(dziury)
    
    return obiektyZbledami


def boundaryPTWP(layer):
    try: 
        obiektyZbledami = []
        ptwp = None
        if layer.name().__contains__('RTLW_L'):
            ptwp = QgsProject().instance().mapLayersByName(layer.name().replace("RTLW_L","PTWP_A"))[0]
        if ptwp:
            # bufor -0.02 m
            bufor = processing.run("native:buffer", {
                'INPUT': ptwp,
                'DISTANCE': -0.02,
                'SEGMENTS': 10,
                'DISSOLVE': True,
                'OUTPUT': 'memory:'
            })
            
            pojedynczePTWP = processing.run("native:multiparttosingleparts", {
                'INPUT': bufor['OUTPUT'],
                'OUTPUT': 'memory:'
            })
            
            extractbyexpression = processing.run("qgis:extractbyexpression", {
                'INPUT': layer,
                'EXPRESSION': '"rodzaj" in (\'skarpa\',\'wąwóz\')',
                'FAIL_OUTPUT': 'memory:',
                'OUTPUT': 'memory:'
            })
            
            extractbylocation = processing.run("native:extractbylocation", {
                'INPUT': extractbyexpression['OUTPUT'],
                'INTERSECT': pojedynczePTWP['OUTPUT'],
                'PREDICATE': [0],
                'OUTPUT': 'memory:'
            })
            
            if extractbylocation['OUTPUT'].featureCount() > 0:
                for obj in extractbylocation['OUTPUT'].getFeatures():
                    obiektyZbledami.append(obj)
    except:
        pass
    
    return obiektyZbledami


def boundaryPTWP_poziomica(layer):
    obiektyZbledami = []
    try:
        ptwp = None
        if layer.name().__contains__('RTLW_L'):
            ptwp = QgsProject().instance().mapLayersByName(layer.name().replace("RTLW_L","PTWP_A"))[0]
        if ptwp:
            # bufor -0.04 m
            bufor = processing.run("native:buffer", {
                'INPUT': ptwp,
                'DISTANCE': -0.04,
                'SEGMENTS': 10,
                'DISSOLVE': True,
                'OUTPUT': 'memory:'
            })
        
            pojedynczePTWP = processing.run("native:multiparttosingleparts", {
                'INPUT': bufor['OUTPUT'],
                'OUTPUT': 'memory:'
            })
        
            extractbyexpression = processing.run("qgis:extractbyexpression", {
                'INPUT': layer,
                'EXPRESSION': '"rodzaj" in (\'poziomica\') and "kodKarto10k" != \'\'',
                'FAIL_OUTPUT': 'memory:',
                'OUTPUT': 'memory:'
            })
        
            extractbylocation = processing.run("native:extractbylocation", {
                'INPUT': extractbyexpression['OUTPUT'],
                'INTERSECT': pojedynczePTWP['OUTPUT'],
                'PREDICATE': [0],
                'OUTPUT': 'memory:'
            })
        
            if extractbylocation['OUTPUT'].featureCount() > 0:
                for obj in extractbylocation['OUTPUT'].getFeatures():
                    obiektyZbledami.append(obj)
    except:
        pass
    return obiektyZbledami

def kontrolaZdublowaniaAtrybutuFunkcjaSzczegolowaBudynku(layer):
    obiektyZbledami = []
    idenBledow = set()
    for feature in layer.getFeatures():
        funkcje_szczegolowe = feature['funkcjaSzczegolowaBudynku'] 
        if isinstance(funkcje_szczegolowe, list):
           wystapienia = {}
           for funkcja in funkcje_szczegolowe:
                if funkcja in wystapienia:
                    wystapienia[funkcja] += 1
                else:
                    wystapienia[funkcja] = 1
            # Sprawdzenie, czy występują powtórzenia (wartość większa niż 1)
           powtorzenia = [key for key, count in wystapienia.items() if count > 1]
           if powtorzenia and feature.id() not in idenBledow:
                obiektyZbledami.append(feature)
                idenBledow.add(feature.id())
    return obiektyZbledami


def kontrolaZgodnosciFunkcjaSzczegolowaBudynkuZprzewazajacaFunkcjaBudynku(layer):
    obiektyZbledami = []
    idenBledow = set()
    
    for feature in layer.getFeatures():
        if "funkcjaSzczegolowaBudynku" not in feature.fields().names() or "przewazajacaFunkcjaBudynku" not in feature.fields().names():
            continue
        
        funkcje_szczegolowe = feature.attribute("funkcjaSzczegolowaBudynku")
        funkcja_przewazajaca = feature.attribute("przewazajacaFunkcjaBudynku")
        
        if not funkcje_szczegolowe or not funkcja_przewazajaca:
            continue
            
        if not isinstance(funkcje_szczegolowe, (list, set)):
            funkcje_szczegolowe = {funkcje_szczegolowe}
        else:
            funkcje_szczegolowe = set(funkcje_szczegolowe)
            
        if funkcja_przewazajaca not in funkcje_szczegolowe:
            if feature.id() not in idenBledow:
                obiektyZbledami.append(feature)
                idenBledow.add(feature.id())
                
    return obiektyZbledami


def KontrolaAtrybutuGeometriaBudynek(layer, plikGML):
    obiektyZbledami = []
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'egb': 'ewidencjaGruntowIBudynkow:1.0'}
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces = ns):
        budynek = featureMember.find('.//egb:EGB_ObiektTrwaleZwiazanyZBudynkiem', namespaces=ns)
        if budynek is not None:
            rodzajObiektu = budynek.find('.//egb:rodzajObiektuZwiazanegoZBudynkiem', namespaces=ns)
            rodzajObiektu_text = rodzajObiektu.text if rodzajObiektu is not None else "Nieznane ID"
            if rodzajObiektu_text in ['t', 'w', 'i','s','r','j','d']:
                lokalnyId = budynek.find('.//egb:lokalnyId', namespaces=ns)
                lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
                geometria = budynek.findall('.//egb:geometria', namespaces=ns)
                for g in geometria:
                    polygon = g.find('.//gml:Polygon', namespaces=ns)
                    surface = g.find('.//gml:Surface', namespaces=ns)
                    if polygon is None and surface in None:
                        expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
                        request = QgsFeatureRequest().setFilterExpression(expression)
                        for feature in layer.getFeatures(request):
                           obiektyZbledami.append(feature)
                           
    return obiektyZbledami


def KontrolaAtrybutuKlasouzytek(layer, plikGML):
    obiektyZbledami = []
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'egb': 'ewidencjaGruntowIBudynkow:1.0'}
    
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces = ns):
        dzialka = featureMember.find('.//egb:EGB_DzialkaEwidencyjna', namespaces = ns)
        if dzialka is not None:
           # Dla każdego Klasouzytek w obrębie Działki Ewidencyjnej
           for klasouzytek in dzialka.findall('.//egb:EGB_Klasouzytek', namespaces = ns):
               lokalnyId = dzialka.find('.//egb:lokalnyId', namespaces=ns)
               lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
               OFU = klasouzytek.find('.//egb:OFU', namespaces=ns)
               ofu_value = OFU.text if OFU is not None else None
               if ofu_value in ['Ls', 'W']:
                   OZU = klasouzytek.find('.//egb:OZU', namespaces=ns)
                   ozu_value = OZU.text if OZU is not None else None
                   if ozu_value == 'Ls':
                       OZK = klasouzytek.find('.//egb:OZK', namespaces=ns)
                       ozk_value = OZK.text if OZK is not None else None
                       if ozk_value in ['IIIa', 'IIIb', 'IVa', 'IVb']:
                           expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
                           request = QgsFeatureRequest().setFilterExpression(expression)
                           for feature in layer.getFeatures(request):
                               obiektyZbledami.append(feature)
    
    return obiektyZbledami


def KontrolaAtrybutuKlasouzytek6(layer, plikGML):
    obiektyZbledami = []
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'egb': 'ewidencjaGruntowIBudynkow:1.0'}
    
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces = ns):
        dzialka = featureMember.find('.//egb:EGB_DzialkaEwidencyjna', namespaces = ns)
        if dzialka is not None:
           # Dla każdego Klasouzytek w obrębie Działki Ewidencyjnej
           for klasouzytek in dzialka.findall('.//egb:EGB_Klasouzytek', namespaces = ns):
               lokalnyId = dzialka.find('.//egb:lokalnyId', namespaces=ns)
               lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
               OFU = klasouzytek.find('.//egb:OFU', namespaces=ns)
               ofu_value = OFU.text if OFU is not None else None
               if ofu_value in ['Lz', 'W']:
                   OZU = klasouzytek.find('.//egb:OZU', namespaces=ns)
                   ozu_value = OZU.text if OZU is not None else None
                   if ozu_value == 'Lz':
                       OZK = klasouzytek.find('.//egb:OZK', namespaces=ns)
                       ozk_value = OZK.text if OZK is not None else None
                       if ozk_value in ['IIIa', 'IIIb', 'IVa', 'IVb']:
                           expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
                           request = QgsFeatureRequest().setFilterExpression(expression)
                           for feature in layer.getFeatures(request):
                               obiektyZbledami.append(feature)
    
    return obiektyZbledami


def KontrolaAtrybutuKlasouzytek2(layer, plikGML):
    obiektyZbledami = []
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'egb': 'ewidencjaGruntowIBudynkow:1.0'}
    
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        dzialka = featureMember.find('.//egb:EGB_DzialkaEwidencyjna', namespaces=ns)
        if dzialka is not None:
           # Dla każdego Klasouzytek w obrębie Działki Ewidencyjnej
           for klasouzytek in dzialka.findall('.//egb:EGB_Klasouzytek', namespaces=ns):
               lokalnyId = dzialka.find('.//egb:lokalnyId', namespaces=ns)
               lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
               OFU = klasouzytek.find('.//egb:OFU', namespaces=ns)
               ofu_value = OFU.text if OFU is not None else None
               if ofu_value in ['R','S', 'Br','Wsr','W','Lzr']:
                   OZU = klasouzytek.find('.//egb:OZU', namespaces=ns)
                   ozu_value = OZU.text if OZU is not None else None
                   if ozu_value == 'R':
                       OZK = klasouzytek.find('.//egb:OZK', namespaces=ns)
                       ozk_value = OZK.text if OZK is not None else None
                       if not ozk_value in ['I','II','IIIa', 'IIIb', 'IVa', 'IVb','V','VI','VIz']:
                           expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
                           request = QgsFeatureRequest().setFilterExpression(expression)
                           for feature in layer.getFeatures(request):
                               obiektyZbledami.append(feature)
    
    return obiektyZbledami


def KontrolaAtrybutuKlasouzytek3(layer, plikGML):
    obiektyZbledami = []
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'egb': 'ewidencjaGruntowIBudynkow:1.0'}
    
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        dzialka = featureMember.find('.//egb:EGB_DzialkaEwidencyjna', namespaces=ns)
        if dzialka is not None:
           # Dla każdego Klasouzytek w obrębie Działki Ewidencyjnej
           for klasouzytek in dzialka.findall('.//egb:EGB_Klasouzytek', namespaces=ns):
               lokalnyId = dzialka.find('.//egb:lokalnyId', namespaces=ns)
               lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
               OFU = klasouzytek.find('.//egb:OFU', namespaces=ns)
               ofu_value = OFU.text if OFU is not None else None
               if ofu_value in ['Ł','S','Br','Wsr','W','Lzr']:
                   OZU = klasouzytek.find('.//egb:OZU', namespaces=ns)
                   ozu_value = OZU.text if OZU is not None else None
                   if ozu_value == 'Ł':
                       OZK = klasouzytek.find('.//egb:OZK', namespaces=ns)
                       ozk_value = OZK.text if OZK is not None else None
                       if not ozk_value in ['I','II','III', 'IV','V','VI']:
                           expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
                           request = QgsFeatureRequest().setFilterExpression(expression)
                           for feature in layer.getFeatures(request):
                               obiektyZbledami.append(feature)
    
    return obiektyZbledami


def KontrolaAtrybutuKlasouzytek4(layer, plikGML):
    obiektyZbledami = []
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'egb': 'ewidencjaGruntowIBudynkow:1.0'}
    
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        dzialka = featureMember.find('.//egb:EGB_DzialkaEwidencyjna', namespaces=ns)
        if dzialka is not None:
           # Dla każdego Klasouzytek w obrębie Działki Ewidencyjnej
           for klasouzytek in dzialka.findall('.//egb:EGB_Klasouzytek', namespaces=ns):
               lokalnyId = dzialka.find('.//egb:lokalnyId', namespaces=ns)
               lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
               OFU = klasouzytek.find('.//egb:OFU', namespaces=ns)
               ofu_value = OFU.text if OFU is not None else None
               if ofu_value in ['Ps','S','Br','Wsr','W','Lzr']:
                   OZU = klasouzytek.find('.//egb:OZU', namespaces=ns)
                   ozu_value = OZU.text if OZU is not None else None
                   if ozu_value == 'Ps':
                       OZK = klasouzytek.find('.//egb:OZK', namespaces=ns)
                       ozk_value = OZK.text if OZK is not None else None
                       if not ozk_value in ['I','II','III', 'IV','V','VI']:
                           expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
                           request = QgsFeatureRequest().setFilterExpression(expression)
                           for feature in layer.getFeatures(request):
                               obiektyZbledami.append(feature)
    
    return obiektyZbledami


def KontrolaGeometriaSchody(layer, plikGML):
    obiektyZbledami = []
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'egb': 'ewidencjaGruntowIBudynkow:1.0'}
    
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        budynek = featureMember.find('.//egb:EGB_ObiektTrwaleZwiazanyZBudynkiem', namespaces=ns)
        if budynek is not None:
            rodzajObiektu = budynek.find('.//egb:rodzajObiektuZwiazanegoZBudynkiem', namespaces=ns)
            rodzajObiektu_text = rodzajObiektu.text if rodzajObiektu is not None else "Nieznane ID"
            if rodzajObiektu_text == 's': # tylko schody
                polKier =  budynek.findall('.//egb:poliliniaKierunkowa', namespaces=ns)
                lokalnyId = budynek.find('.//egb:lokalnyId', namespaces=ns)
                lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
                expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
                request = QgsFeatureRequest().setFilterExpression(expression)
                if not polKier: # całkowity brak atrybutu
                    for feature in layer.getFeatures(request):
                        obiektyZbledami.append(feature)
                else: # schody nie posiadają poprawnej lini kierunkowej
                    for pk in polKier:
                        posList = pk.find('.//gml:posList', namespaces=ns)
                        pos = pk.find('.//gml:pos', namespaces=ns)
                        if pos is not None: # punkt
                            pos_wsp = pos.text 
                            if pos_wsp is None:
                                for feature in layer.getFeatures(request):
                                    obiektyZbledami.append(feature)
                        if posList is not None: # linie i powierzchnie
                            posList_wsp = posList.text
                            if posList_wsp is None:
                                for feature in layer.getFeatures(request):
                                    obiektyZbledami.append(feature)
    
    return obiektyZbledami


def gminyCzyNakladajaSie(layer):
    obiektyZbledami = []
    
    gm = processing.run("qgis:extractbyexpression", {
        'INPUT':layer,
        'EXPRESSION':'"rodzaj" = \'gmina\'',
        'OUTPUT':'memory:'
    })
    gminy = gm['OUTPUT']
    
    invalid_layer = processing.run("qgis:checkvalidity", {
        'INPUT_LAYER': gminy,
        'METHOD': 0, 
        'IGNORE_RING_SELF_INTERSECTION': True,
        'VALID_OUTPUT': 'memory:',
        'INVALID_OUTPUT': 'memory:',
        'ERROR_OUTPUT': 'memory:'
    })
    
    # zawiera warstwę z niepoprawnymi geometriami
    if invalid_layer['INVALID_OUTPUT']:
              # Wykonanie naprawy geometrii
              naprawiona = processing.run("native:fixgeometries", {
                  'INPUT': gminy,
                  'OUTPUT': 'memory:'
              })
              gminy = naprawiona['OUTPUT']
    
    union = processing.run("qgis:union", {
        'INPUT': gminy,
        'OUTPUT': 'memory:'
    })
    
    multiparttosingleparts = processing.run("native:multiparttosingleparts", {
        'INPUT': union['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    geom_union = []
    for f in multiparttosingleparts['OUTPUT'].getFeatures():
        g = f.geometry()
        geom_wkt = g.asWkt()
        if not geom_wkt in geom_union:
            geom_union.append(geom_wkt)
        else:
            if f.geometry().area() > 2:
                obiektyZbledami.append(f)
    
    return obiektyZbledami


def miastoWiesCzyNakladajaSie(layer):
    obiektyZbledami = []
    
    extractbyexpression = processing.run("qgis:extractbyexpression",{
        'INPUT': layer,
        'EXPRESSION':'"rodzaj"=\'miasto\' or "rodzaj"=\'wieś\'',
        'OUTPUT':'memory:'})
    miastoWies = extractbyexpression['OUTPUT']
    miastoWies.setName("miasto_wies")
    
    checkvalidity = processing.run("qgis:checkvalidity",{
        'INPUT_LAYER': miastoWies,
        'METHOD': 0,
        'IGNORE_RING_SELF_INTERSECTION': True,
        'VALID_OUTPUT': 'memory:',
        'INVALID_OUTPUT': 'memory:',
        'ERROR_OUTPUT': 'memory:'
    })
    
    # zawiera warstwę z niepoprawnymi geometriami
    if checkvalidity['INVALID_OUTPUT']:
              # Wykonanie naprawy geometrii
              naprawiona = processing.run("native:fixgeometries", {
                  'INPUT': miastoWies,
                  'OUTPUT': 'memory:'
              })
              miastoWies = naprawiona['OUTPUT']
    
    union = processing.run("qgis:union", {
        'INPUT': miastoWies,
        'OUTPUT': 'memory:'
    })
    
    multiparttosingleparts = processing.run("native:multiparttosingleparts", {
        'INPUT': union['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    geom_union = []
    for f in multiparttosingleparts['OUTPUT'].getFeatures():
        g = f.geometry()
        geom_wkt = g.asWkt()
        if not geom_wkt in geom_union:
            geom_union.append(geom_wkt)
        else:
            if f.geometry().area() > 2:
                obiektyZbledami.append(f)
    
    return obiektyZbledami


def sprawdzLokalnyId(layer):
    obiektyZbledami = []
    if layer.name()[-6:] in ['RTLW_L', 'RTPW_P']:
        # funkcja nie wykona się dla warstw z rzeźbą terenu
        return obiektyZbledami
    uuid_pattern = re.compile(r'^[A-Za-z0-9]{8}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{12}$|^$')
    # Zbiór do sprawdzania unikalności
    unique_ids = set()
    for f in layer.getFeatures():
        lokalny = f.attribute('lokalnyId')
        matches_pattern = bool(uuid_pattern.match(lokalny))
        if not isinstance(lokalny, str):
            lokalny = str(lokalny) # konwersja pustej wartosci na string
        is_unique = lokalny not in unique_ids
        if is_unique and not matches_pattern:
            unique_ids.add(lokalny)
            obiektyZbledami.append(f)
    
    return obiektyZbledami


def sprawdzPrzestrzenNazw(layer):
    obiektyZbledami = []
    if layer.name()[-6:] in ['RTLW_L', 'RTPW_P']:
        # funkcja nie wykona się dla warstw z rzeźbą terenu
        return obiektyZbledami
    dozwolone_kody = {
    '02': '337',  # dolnośląskie
    '04': '994',  # kujawsko-pomrskie
    '06': '3700', # lubelskie
    '26': '370',  # świętokrzyskie
    '08': '333',  # lubuskie
    '10': '340',  # łódzkie
    '12': '283',  # małopolskie
    '14': '330',  # mazowieckie
    '16': '1833', # opolskie
    '18': '332',  # podlaskie
    '20': '335',  # podkarpackie
    '22': '336',  # pomorskie
    '24': '238',  # śląskie
    '28': '341',  # warmińsko-mazurskie
    '30': '308',  # wielkopolskie
    '32': '339'   # zachodniopomorskie
    }
    pattern = re.compile(r'^PL\.PZGiK\.(\d{3,4})\.BDOT10k$')
    # Zbiór do sprawdzania unikalności
    unique_ids = set()
    for f in layer.getFeatures():
        przestrzen = f.attribute('przestrzenNazw')
        match = pattern.match(przestrzen)
        if not isinstance(przestrzen, str):
            przestrzen = str(przestrzen) # konwersja pustej wartosci na string
        if not match: # sprawdza, czy są niezgodne z schematem
            obiektyZbledami.append(f)
        else: 
            woj = layer.name()[13:15] # sprawdza niezgodnosci cyfr w wojewodztwach
            if woj in ['.1', '.0']:
                woj = layer.name()[14:16]
            cyfry = match.group(1) if match.group(1) else None
            expected_cyfry = dozwolone_kody.get(woj, None)
            if isinstance(expected_cyfry, list):
                valid = cyfry in expected_cyfry
            else:
                valid = cyfry == expected_cyfry
                
            if not valid:
                    obiektyZbledami.append(f)
    
    return obiektyZbledami


def sprawdzWersja(layer):
    obiektyZbledami = []
    if layer.name()[-6:] in ['RTLW_L', 'RTPW_P']:
        # funkcja nie wykona się dla warstw z rzeźbą terenu
        return obiektyZbledami
    uuid_pattern = re.compile(r'^[0-9]{4}-[01][0-9]-[0-3][0-9]T[0-2][0-9]:[0-5][0-9]:[0-5][0-9]$|^$')
    # Zbiór do sprawdzania unikalności
    unique_ids = set()
    for f in layer.getFeatures():
        wersja = f.attribute('wersja')
        matches_pattern = bool(uuid_pattern.match(wersja))
        if not isinstance(wersja, str):
            wersja = str(wersja) # konwersja pustej wartosci na string
        is_unique = wersja not in unique_ids
        if is_unique and not matches_pattern:
            unique_ids.add(wersja)
            obiektyZbledami.append(f)
    
    return obiektyZbledami


def sprawdzPoczatekWersjiObiektu(layer):
    obiektyZbledami = []
    if layer.name()[-6:] in ['RTLW_L', 'RTPW_P']:
        # funkcja nie wykona się dla warstw z rzeźbą terenu
        return obiektyZbledami
    uuid_pattern = re.compile(r'^[0-9]{4}-[01][0-9]-[0-3][0-9]T[0-2][0-9]:[0-5][0-9]:[0-5][0-9]$')
    # Zbiór do sprawdzania unikalności
    unique_ids = set()
    for f in layer.getFeatures():
        poczatek = f.attribute('poczatekWersjiObiektu')
        wersja = f.attribute('wersja')
        if not isinstance(wersja, str):
            wersja = str(wersja)
        if not isinstance(poczatek, str):
            poczatek = str(poczatek) # konwersja pustej wartosci na string
        if wersja != poczatek and f.id() not in unique_ids:
             unique_ids.add(f.id())
             obiektyZbledami.append(f)
        if not uuid_pattern.match(wersja) and f.id() not in unique_ids:
             unique_ids.add(f.id())
             obiektyZbledami.append(f)
        if not uuid_pattern.match(poczatek) and f.id() not in unique_ids:
             unique_ids.add(f.id())
             obiektyZbledami.append(f)
    
    return obiektyZbledami


def przestrzenNazw(layer,teryt):
    obiektyZbledami = []
    slownik = {
    '02': '337',  # dolnośląskie
    '04': '994',  # kujawsko-pomrskie
    '06': '3700', # lubelskie
    '08': '333',  # lubuskie
    '10': '340',  # łódzkie
    '12': '283',  # małopolskie
    '14': '330',  # mazowieckie
    '16': '1833', # opolskie
    '18': '332',  # podlaskie
    '20': '335',  # podkarpackie
    '22': '336',  # pomorskie
    '24': '238',  # śląskie
    '26': '370',  # świętokrzyskie
    '28': '341',  # warmińsko-mazurskie
    '30': '308',  # wielkopolskie
    '32': '339'   # zachodniopomorskie
    }
    pattern = re.compile(r'^PL\.PZGiK\.(\d{3,4})\.BDOT10k$')
    # Zbiór do sprawdzania unikalności
    unique_ids = set()
    for f in layer.getFeatures():
        przestrzen = f.attribute('przestrzenNazw')
        if not isinstance(przestrzen, str):
            przestrzen = str(przestrzen) # konwersja pustej wartosci na string
            obiektyZbledami.append(f)
        else:
            match = pattern.match(przestrzen)
            if not match: # sprawdza, czy są niezgodne z schematem
                match = pattern.match(przestrzen)
                obiektyZbledami.append(f)
            else:
                woj = teryt[:2]
                cyfry = match.group(1) if match.group(1) else None
                expected_cyfry = slownik.get(woj, None)
                if isinstance(expected_cyfry, list):
                    valid = cyfry in expected_cyfry
                else:
                    valid = cyfry == expected_cyfry
                if not valid:
                    obiektyZbledami.append(f)
    
    return obiektyZbledami


def zapisWspolrzednych(layer, plikGML):
    obiektyZbledami = []
    pattern = re.compile(r"[0-9]{6}\.[0-9]{3,}")
    plikGML = plikGML.getroot()
    otklasa = f'.//ot:{layer.name()[-9:]}'
    ns = {'gml': 'http://www.opengis.net/gml/3.2', "ot":"urn:gugik:specyfikacje:gmlas:bazaDanychObiektowTopograficznych10k:2.0"}
    warstwy_otklasy = {}
    
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        # Weryfikacja, czy wystąpienia są zgodne z oczekiwaniami
        matches = featureMember.find(otklasa, namespaces=ns)
        if matches is not None:
            geometria = matches.findall('.//ot:geometria', namespaces=ns)
            lokalnyId = matches.find('.//ot:lokalnyId', namespaces=ns)
            lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
            expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
            request = QgsFeatureRequest().setFilterExpression(expression)
            for g in geometria:  # błędy i braki wewnątrz atrybutu
                geom = g.find('.//gml:posList', namespaces=ns)
                geomPkt = g.find('.//gml:pos', namespaces=ns)
                if geom is not None: # linie i powierzchnie
                    geom_wsp = geom.text if geom is not None else "Nieznane ID"
                    if pattern.search(geom_wsp):
                        for feature in layer.getFeatures(request):
                            obiektyZbledami.append(feature)
                elif geomPkt is not None: # punkty
                    geom_wsp = geomPkt.text if geomPkt is not None else "Nieznane ID"
                    if pattern.search(geom_wsp):
                        for feature in layer.getFeatures(request):
                            obiektyZbledami.append(feature)
    
    return obiektyZbledami


def minDlugoscOIPR(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'OIPR_L':
        OIPR_L_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    granica = adjaMinus2cmBufor(layer)
    for OIPR_L_feature in OIPR_L_layer.getFeatures():
        geom = OIPR_L_feature.geometry()
        if geom.length() < 40 and OIPR_L_feature['rodzaj'] in ['rząd drzew','pas krzewów lub żywopłot']:
            styka = False
            for g in granica.getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(OIPR_L_feature)
    
    return obiektyZbledami


def minDlugoscBUUO(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'BUUO_L':
        BUUO_L_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    granica = adjaMinus2cmBufor(layer)
    for BUUO_L_feature in BUUO_L_layer.getFeatures():
        geom = BUUO_L_feature.geometry()
        if geom.length() < 10 and BUUO_L_feature['rodzaj'] in ['falochron','ostroga']:
            styka = False
            for g in granica['OUTPUT'].getFeatures():
                if not geom.intersects(g.geometry()):
                    styka = True
                    obiektyZbledami.append(BUUO_L_feature)
    
    return obiektyZbledami


def minDlugoscSUPRnaKUPG(layer):
    obiektyZbledami = []
    if layer.name()[-6:] == 'SUPR_L':
        KUPG_A_layer = QgsProject().instance().mapLayersByName(layer.name().replace("OT_SUPR_L","OT_KUPG_A"))[0]
        SUPR_L_layer = QgsProject().instance().mapLayersByName(layer.name())[0]
    granica = adjaMinus2cmBufor(layer)
    
    for g in granica.getFeatures():
        PGR_geom = g.geometry()
    
    for SUPR_L_feature in SUPR_L_layer.getFeatures():
        SUPR_L_geom = SUPR_L_feature.geometry()
        SUPR_L_id = SUPR_L_feature.id()
        if SUPR_L_geom.length() < 100 and not SUPR_L_geom.intersects(PGR_geom):
            for KUPG_A_feature in KUPG_A_layer.getFeatures():
                KUPG_A_geom = KUPG_A_feature.geometry()
                if SUPR_L_geom.intersects(KUPG_A_geom):
                    przecina = False
                    for SUPR_L_feature_o in SUPR_L_layer.getFeatures():
                        SUPR_L_id_o = SUPR_L_feature_o.id()
                        if SUPR_L_id_o != SUPR_L_id:
                            SUPR_L_geom_o = SUPR_L_feature_o.geometry()
                            if SUPR_L_geom_o.intersects(SUPR_L_geom):
                                przecina = True
                                break
                    if not przecina:
                        obiektyZbledami.append(SUPR_L_feature)
    
    return obiektyZbledami



    obiektyZbledami = []
    global loaded_csv_data
    
    if loaded_csv_data is None:
        loaded_csv_data = pd.read_csv(plikcsv, sep=';', encoding='utf-8')
        loaded_csv_data['CECHA'] = loaded_csv_data['CECHA'].fillna('NULL').str.strip()
        loaded_csv_data['NAZWA_1'] = loaded_csv_data['NAZWA_1'].fillna('NULL')
        loaded_csv_data['NAZWA_2'] = loaded_csv_data['NAZWA_2'].fillna('NULL')
    
    for f in layer.getFeatures():
        try:
            identyfikatorULIC = f.attribute('identyfikatorULIC')
            identyfikatorSIMC = f.attribute('identyfikatorSIMC')
        except:
            return []
        if identyfikatorULIC == NULL or identyfikatorSIMC == NULL:
            continue
        
        # Sprawdzenie zgodności identyfikatora ULIC
        if identyfikatorULIC not in loaded_csv_data['SYM_UL'].values:
            gml_id = f["gml_id"] + "| NIEZNALEZIONY identyfikatorULIC: " + str(identyfikatorULIC)
            f.setAttribute(layer.fields().indexFromName("gml_id"), gml_id)
            layer.updateFeature(f)
            obiektyZbledami.append(f)
        
        # Sprawdzenie zgodności identyfikatora SIMC
        if identyfikatorSIMC not in loaded_csv_data['SYM'].values:
            gml_id = f["gml_id"] + "| NIEZNALEZIONY identyfikatorSIMC: " + str(identyfikatorSIMC)
            f.setAttribute(layer.fields().indexFromName("gml_id"), gml_id)
            layer.updateFeature(f)
            obiektyZbledami.append(f)
        
        t = ''
        if 'OT_PTPL_A' in layer.name():
            nazwa1 = f.attribute('placNazwa1')
            try:
                nazwa2 = f.attribute('placNazwa2')
            except:
                nazwa2 = 'NULL'
            cecha = f.attribute('placCecha')
            t = 'placCecha:' + cecha + ',placNazwa1:' + nazwa1 + ',placNazwa2:' + nazwa2
        else:
            nazwa1 = str(f.attribute('ulicaNazwa1'))
            try:
                nazwa2 = str(f.attribute('ulicaNazwa2'))
            except:
                nazwa2 = 'NULL'
            cecha = str(f.attribute('ulicaCecha'))
            t = 'ulicaCecha:' + cecha + ',ulicaNazwa1:' + nazwa1 + ',ulicaNazwa2:' + nazwa2
        
        wynik = loaded_csv_data[(loaded_csv_data['SYM_UL'] == identyfikatorULIC) & (loaded_csv_data['SYM'] == identyfikatorSIMC)]
        if len(wynik['CECHA'].tolist()) == 1:
            cecha_GUS = str(wynik['CECHA'].tolist()[0])
            nazwa1_GUS = str(wynik['NAZWA_1'].tolist()[0])
            nazwa2_GUS = str(wynik['NAZWA_2'].tolist()[0])
            if cecha_GUS != cecha or nazwa1_GUS != nazwa1 or nazwa2_GUS != nazwa2:
                gml_id = f["gml_id"] + "| CECHA:" + cecha_GUS + ",NAZWA_1:" + nazwa1_GUS + ",NAZWA_2:" + nazwa2_GUS + ";" + t
                f.setAttribute(layer.fields().indexFromName("gml_id"), gml_id)
                layer.updateFeature(f)
                obiektyZbledami.append(f)
        
        layer.commitChanges()
    return obiektyZbledami


def kontrolaZgodnosciIdentyfikatoraUlicyZNazwa(layer, plikcsv):
    obiektyZbledami = []
    global loaded_csv_data
    
    if loaded_csv_data is None:
        loaded_csv_data = pd.read_csv(plikcsv, sep=';', encoding='utf-8', dtype=str).apply(lambda x: x.str.strip() if x.dtype == "object" else x).fillna('NULL')
        
    sym_ul_set = set(loaded_csv_data['SYM_UL'].astype(str).values)
    sym_set = set(loaded_csv_data['SYM'].astype(str).values)
    csv_map = {(str(row['SYM_UL']), str(row['SYM'])): (str(row['CECHA']), str(row['NAZWA_1']), str(row['NAZWA_2'])) for _, row in loaded_csv_data.iterrows()}
    
    for f in layer.getFeatures():
        identyfikatorULIC = str(f.attribute('identyfikatorULIC')).strip() if 'identyfikatorULIC' in layer.fields().names() and f.attribute('identyfikatorULIC') is not None else 'NULL'
        identyfikatorSIMC = str(f.attribute('identyfikatorSIMC')).strip() if 'identyfikatorSIMC' in layer.fields().names() and f.attribute('identyfikatorSIMC') is not None else 'NULL'
        
        if identyfikatorULIC == 'NULL' or identyfikatorSIMC == 'NULL':
            continue
        
        if 'OT_PTPL_A' in layer.name():
            nazwa1 = str(f.attribute('placNazwa1')).strip() if 'placNazwa1' in layer.fields().names() and f.attribute('placNazwa1') is not None else 'NULL'
            nazwa2 = str(f.attribute('placNazwa2')).strip() if 'placNazwa2' in layer.fields().names() and f.attribute('placNazwa2') is not None else 'NULL'
            cecha = str(f.attribute('placCecha')).strip() if 'placCecha' in layer.fields().names() and f.attribute('placCecha') is not None else 'NULL'
            t = f"placCecha:{cecha},placNazwa1:{nazwa1},placNazwa2:{nazwa2}"
        else:
            nazwa1 = str(f.attribute('ulicaNazwa1')).strip() if 'ulicaNazwa1' in layer.fields().names() and f.attribute('ulicaNazwa1') is not None else 'NULL'
            nazwa2 = str(f.attribute('ulicaNazwa2')).strip() if 'ulicaNazwa2' in layer.fields().names() and f.attribute('ulicaNazwa2') is not None else 'NULL'
            cecha = str(f.attribute('ulicaCecha')).strip() if 'ulicaCecha' in layer.fields().names() and f.attribute('ulicaCecha') is not None else 'NULL'
            t = f"ulicaCecha:{cecha},ulicaNazwa1:{nazwa1},ulicaNazwa2:{nazwa2}"
            
        cecha_GUS, nazwa1_GUS, nazwa2_GUS = csv_map.get((identyfikatorULIC, identyfikatorSIMC), ('NULL', 'NULL', 'NULL'))
        
        gml_id = str(f.attribute("gml_id")) if f.attribute("gml_id") is not None else 'NULL'
        komunikaty_bledu = []
        
        # Sprawdzenie identyfikatorów ULIC i SIMC
        if identyfikatorULIC not in sym_ul_set:
            komunikaty_bledu.append(f"NIEZNALEZIONY identyfikatorULIC: {identyfikatorULIC}")
        
        if identyfikatorSIMC not in sym_set:
            komunikaty_bledu.append(f"NIEZNALEZIONY identyfikatorSIMC: {identyfikatorSIMC}")
            
        if cecha_GUS != cecha or nazwa1_GUS != nazwa1 or nazwa2_GUS != nazwa2:
            komunikaty_bledu.append(f"CECHA:{cecha_GUS},NAZWA_1:{nazwa1_GUS},NAZWA_2:{nazwa2_GUS}; {t}")
            
        if komunikaty_bledu:
            gml_id = (gml_id + " | " if gml_id != 'NULL' else "") + " | ".join(komunikaty_bledu)
            f.setAttribute(layer.fields().indexFromName("gml_id"), gml_id)
            layer.updateFeature(f)
            obiektyZbledami.append(f)
            
    layer.commitChanges()
    return obiektyZbledami


def pyExpression(layer, sqltxt):
    obiektyZbledami = []
    
    def lexpression(layer, sqltxt):
        expression = QgsExpression(sqltxt)
        
        if expression.hasParserError():
            return f"Parser error: {expression.parserErrorString()}"
        
        if not expression.isValid():
            print("błąd w szablonie kontroli")
        
        # Tworzenie kontekstu wyrażenia
        context = QgsExpressionContext()
        context.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layer))
        
        # Iteracja przez wszystkie obiekty w kontekcie expression
        for feature in layer.getFeatures():
            context.setFeature(feature)
            expression.evaluate(context)
            
            if expression.hasEvalError():
                field_name = expression.evalErrorString().split("'")[1]
                layer.addExpressionField(field_name, QgsField(field_name, QVariant.String))
                
                # iteracyjnie dodaje brakujące pola do warstwy
                lexpression(layer, sqltxt)
                break
    
    lexpression(layer, sqltxt)
    
    request = QgsFeatureRequest(QgsExpression(sqltxt))
    requestFeatures = layer.getFeatures(request)
    for f in requestFeatures:
        obiektyZbledami.append(f)
    
    return obiektyZbledami


def mgrExpression(layer, gml, sqltxt):
    obiektyZbledami = []
    
    if not QgsProject.instance().mapLayersByName(layer.name() + "_dodane_pola"):
        newFields = ['numerPodloza','podloze','szkieletowosc','rodzajGlebyOrganicznej','miazszosc','gatunekMady','gatunekRedziny','informacjeDodatkowe']
        nowePola = []
        
        layer_dodane_pola = QgsVectorLayer('Polygon?crs=EPSG:2180', layer.name() + "_dodane_pola", 'memory')
        memory_provider = layer_dodane_pola.dataProvider()
        memory_provider.addAttributes(layer.fields())
        layer_dodane_pola.updateFields()
        
        for field in newFields:
            for n in [1,2,3,4,5]:
                newFieldName = field + str(n)
                nowePola.append(newFieldName)
                memory_provider.addAttributes([QgsField(newFieldName, QVariant.String)])
        
        for feature in layer.getFeatures():
            memory_provider.addFeature(feature)
        
        layer_dodane_pola.startEditing()
        ns = {'gml': 'http://www.opengis.net/gml/3.2', 'gr': 'urn:gugik:specyfikacje:gmlas:mapaGlebowoRolnicza:1.0'}
        konturyGlebowe = gml.getroot().findall('.//gr:GR_KonturGlebowy', namespaces=ns)
        for konturGlebowy in konturyGlebowe:
            lokalnyId = konturGlebowy.find('.//gr:lokalnyId', namespaces=ns).text
            expression = f"\"lokalnyId\" = '{lokalnyId}'"
            request = QgsFeatureRequest().setFilterExpression(expression)
            lyr_request = layer_dodane_pola.getFeatures(request)
            for feature in lyr_request:
                QCoreApplication.processEvents()
                opisyPodlozy = konturGlebowy.findall('.//gr:opisPodloza', namespaces=ns)
                for opisPodloza in opisyPodlozy:
                    numerPodloza = opisPodloza.find('.//gr:numerPodloza', namespaces=ns).text
                    for field in newFields:
                        value = opisPodloza.find('.//gr:' + field, namespaces=ns)
                        if value == None:
                            wartosc = NULL
                        else:
                            wartosc = value.text
                        feature.setAttribute(layer_dodane_pola.fields().indexFromName(field + numerPodloza), wartosc)
                layer_dodane_pola.updateFeature(feature)
        layer_dodane_pola.commitChanges()
        
        QgsProject.instance().addMapLayer(layer_dodane_pola)
    else:
        layer_dodane_pola = QgsProject.instance().mapLayersByName(layer.name() + "_dodane_pola")[0]
    
    request = QgsFeatureRequest(QgsExpression(sqltxt))
    requestFeatures = layer_dodane_pola.getFeatures(request)
    for f in requestFeatures:
        obiektyZbledami.append(f)
    
    return obiektyZbledami


def numerPodloza(layer, plikGML):
    obiektyZbledami = []
    idenBledow = set()
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'gr': 'urn:gugik:specyfikacje:gmlas:mapaGlebowoRolnicza:1.0'}
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        kontur = featureMember.find('.//gr:GR_KonturGlebowy', namespaces=ns)
        if kontur is not None:
            opisyPodloza =  kontur.findall('.//gr:opisPodloza', namespaces=ns)
            lokalnyId = kontur.find('.//gr:lokalnyId', namespaces=ns)
            lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
            for opisPodloza in opisyPodloza:
                nrPodloza = opisPodloza.find('.//gr:numerPodloza', namespaces=ns)
                nrPodloza_value = nrPodloza.text if nrPodloza is not None else None
                if nrPodloza_value not in ['1','2','3','4','5']:
                    if lokalnyId_text not in idenBledow:
                        expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
                        request = QgsFeatureRequest().setFilterExpression(expression)
                        for feature in layer.getFeatures(request):
                                obiektyZbledami.append(feature)
                        idenBledow.add(lokalnyId_text)
    return obiektyZbledami


def miazszoscPodloza(layer, plikGML):
    obiektyZbledami = []
    idenBledow = set()
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'gr': 'urn:gugik:specyfikacje:gmlas:mapaGlebowoRolnicza:1.0'}
    warunki = {
         '-': '2',
         '=': ['2', '3'],
         '.': '3',
         ':': '4',
        ':.': '5',
    }
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        kontur = featureMember.find('.//gr:GR_KonturGlebowy', namespaces=ns)
        if kontur is not None:
            opisyPodloza =  kontur.findall('.//gr:opisPodloza', namespaces=ns)
            lokalnyId = kontur.find('.//gr:lokalnyId', namespaces=ns)
            lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
            for opisPodloza in opisyPodloza:
                nrPodloza = opisPodloza.find('.//gr:numerPodloza', namespaces=ns)
                miazszosc = opisPodloza.find('.//gr:miazszosc', namespaces=ns)
                nrPodloza_value = nrPodloza.text if nrPodloza is not None else None
                miazszosc_value = miazszosc.text if miazszosc is not None else None
                # Iteracja przez warunki w słowniku
                znaleziono_warunek = False
                for miazszosc_key, nrPodloza_values in warunki.items():
                    if miazszosc_value == miazszosc_key:
                        if isinstance(nrPodloza_values, list):
                            for value in nrPodloza_values:
                                if nrPodloza_value != value:
                                    if lokalnyId_text not in idenBledow:
                                        expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
                                        request = QgsFeatureRequest().setFilterExpression(expression)
                                        for feature in layer.getFeatures(request):
                                            obiektyZbledami.append(feature)
                                        idenBledow.add(lokalnyId_text)
                        else:
                            if nrPodloza_value != nrPodloza_values:
                                # Jeśli spełnia warunek, dodaj do obiektyZbledami
                                if lokalnyId_text not in idenBledow:
                                    expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
                                    request = QgsFeatureRequest().setFilterExpression(expression)
                                    for feature in layer.getFeatures(request):
                                        obiektyZbledami.append(feature)
                                    idenBledow.add(lokalnyId_text)
    
    return obiektyZbledami


def podlozeKompleks(layer, plikGML):
    obiektyZbledami = []
    idenBledow = set()
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'gr': 'urn:gugik:specyfikacje:gmlas:mapaGlebowoRolnicza:1.0'}
    for featureMember in plikGML.findall('.//gml:featureMember', namespaces=ns):
        kontur = featureMember.find('.//gr:GR_KonturGlebowy', namespaces=ns)
        if kontur is not None:
            opisyPodloza =  kontur.findall('.//gr:opisPodloza', namespaces=ns)
            lokalnyId = kontur.find('.//gr:lokalnyId', namespaces=ns)
            lokalnyId_text = lokalnyId.text if lokalnyId is not None else "Nieznane ID"
            kompleks = kontur.find('.//gr:kompleks', namespaces=ns)
            kompleks_text = kompleks.text if kompleks is not None else "Nieznane ID"
            typPodtyp = kontur.find('.//gr:typPodtyp', namespaces=ns)
            typPodtyp_text = typPodtyp.text if typPodtyp is not None else "Nieznane ID"
            if kompleks_text == 'Tnk':
                for opisPodloza in opisyPodloza:
                    nrPodloza = opisPodloza.find('.//gr:numerPodloza', namespaces=ns)
                    nrPodloza_value = nrPodloza.text if nrPodloza is not None else None
                    podloze = opisPodloza.find('.//gr:podloze', namespaces=ns)
                    podloze_value = podloze.text if podloze is not None else None
                    if typPodtyp_text is not None or podloze_value is not None or nrPodloza_value is not None:
                        if lokalnyId_text not in idenBledow:
                            expression = f"\"lokalnyId\" = '{lokalnyId_text}'"
                            request = QgsFeatureRequest().setFilterExpression(expression)
                            for feature in layer.getFeatures(request):
                                obiektyZbledami.append(feature)
                            idenBledow.add(lokalnyId_text)
                    
    return obiektyZbledami


def kontrola_OT_ADJA_A_z_A02_Granice_powiatow(layer):
    obiektyZbledami = []
    
    extractbyexpression = processing.run("qgis:extractbyexpression", {
        'INPUT': layer,
        'EXPRESSION': '"rodzaj" IN (\'państwo\', \'województwo\', \'powiat\')',
        'FAIL_OUTPUT': 'memory:',
        'OUTPUT': 'memory:'
    })
    
    terytyPowiatow = []
    for obj in extractbyexpression['OUTPUT'].getFeatures():
        terytyPowiatow.append(str(obj['identyfikatorTERYTjednostki']))
        
    config = configparser.ConfigParser()
    mainPath = pathlib.Path(QgsApplication.qgisSettingsDirPath()) / pathlib.Path("python/plugins/Walidator_plikow_gml/")
    config.read(str(mainPath) + '/Walidator_plikow_gml.ini')
    granicePowiatowPath = config['DEFAULT']['granicepowiatow']
    granicePowiatow = QgsVectorLayer(granicePowiatowPath, 'GranicePowiatow', 'ogr')
    granicePowiatow_z_PRG = QgsVectorLayer("Polygon?crs=epsg:2180&field=gml_id:string(254)", "granica powiatu z PRG", "memory")
    
    granicePowiatow = processing.run("native:multiparttosingleparts", {
        'INPUT': granicePowiatow,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    for obj in granicePowiatow.getFeatures():
        JPT_KOD_JE = str(obj['JPT_KOD_JE'])
        if JPT_KOD_JE in terytyPowiatow:
            granicePowiatow_z_PRG.dataProvider().addFeatures([obj])
            
    extractbyexpression_linia = processing.run("native:polygonstolines", {
        'INPUT': extractbyexpression['OUTPUT'],
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    granicePowiatow_z_PRG_linia = processing.run("native:polygonstolines", {
        'INPUT': granicePowiatow_z_PRG,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    bufor = processing.run("native:buffer", {
        'INPUT': granicePowiatow_z_PRG_linia,
        'DISTANCE': 0.02,
        'SEGMENTS': 10,
        'DISSOLVE': True,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    difference = processing.run("qgis:difference", {
        'INPUT': extractbyexpression_linia,
        'OVERLAY': bufor,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    pojedynczeObiekty = processing.run("native:multiparttosingleparts", {
        'INPUT': difference,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    if pojedynczeObiekty.featureCount() > 0:
        is_error_found = True
        for lyr in QgsProject.instance().mapLayers().values():
            if lyr.name() == "granica powiatu z PRG":
                is_error_found = False
        if is_error_found:
            QgsProject.instance().addMapLayer(granicePowiatow_z_PRG)
            
        for obj in pojedynczeObiekty.getFeatures():
            obiektyZbledami.append(obj)
            
    return obiektyZbledami


def kontrola_OT_ADJA_A_z_A03_Granice_gmin(layer):
    obiektyZbledami = []
    
    extractbyexpression = processing.run("qgis:extractbyexpression", {
        'INPUT': layer,
        'EXPRESSION': '"rodzaj" = \'gmina\'',
        'FAIL_OUTPUT': 'memory:',
        'OUTPUT': 'memory:'
    })
    
    terytyGmin = []
    for obj in extractbyexpression['OUTPUT'].getFeatures():
        terytyGmin.append(str(obj['identyfikatorTERYTjednostki']))
        
    config = configparser.ConfigParser()
    mainPath = pathlib.Path(QgsApplication.qgisSettingsDirPath()) / pathlib.Path("python/plugins/Walidator_plikow_gml/")
    config.read(str(mainPath) + '/Walidator_plikow_gml.ini')
    graniceGminPath = config['DEFAULT']['granicegmin']
    graniceGmin = QgsVectorLayer(graniceGminPath, 'GraniceGmin', 'ogr')
    graniceGmin_z_PRG = QgsVectorLayer("Polygon?crs=epsg:2180&field=gml_id:string(254)", "granice gmin z PRG", "memory")
    
    graniceGmin = processing.run("native:multiparttosingleparts", {
        'INPUT': graniceGmin,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    for obj in graniceGmin.getFeatures():
        JPT_KOD_JE = str(obj['JPT_KOD_JE'])
        if JPT_KOD_JE in terytyGmin:
            graniceGmin_z_PRG.dataProvider().addFeatures([obj])
            
    extractbyexpression_linia = processing.run("native:polygonstolines", {
        'INPUT': extractbyexpression['OUTPUT'],
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    graniceGmin_z_PRG_linia = processing.run("native:polygonstolines", {
        'INPUT': graniceGmin_z_PRG,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    bufor = processing.run("native:buffer", {
        'INPUT': graniceGmin_z_PRG_linia,
        'DISTANCE': 0.02,
        'SEGMENTS': 10,
        'DISSOLVE': True,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    difference = processing.run("qgis:difference", {
        'INPUT': extractbyexpression_linia,
        'OVERLAY': bufor,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    pojedynczeObiekty = processing.run("native:multiparttosingleparts", {
        'INPUT': difference,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    if pojedynczeObiekty.featureCount() > 0:
        is_error_found = True
        for lyr in QgsProject.instance().mapLayers().values():
            if lyr.name() == "granice gmin z PRG":
                is_error_found = False
        if is_error_found:
            QgsProject.instance().addMapLayer(graniceGmin_z_PRG)
            
        for obj in pojedynczeObiekty.getFeatures():
            obiektyZbledami.append(obj)
            
    return obiektyZbledami


def kontrola_OT_ADJA_A_z_A05_Granice_jednostek_ewidencyjnych(layer):
    obiektyZbledami = []
    
    extractbyexpression = processing.run("qgis:extractbyexpression", {
        'INPUT': layer,
        'EXPRESSION': '"rodzaj" = \'miasto w gminie miejsko-wiejskiej\'',
        'FAIL_OUTPUT': 'memory:',
        'OUTPUT': 'memory:'
    })
    
    terytyMiast = []
    teryt = ''
    
    for obj in extractbyexpression['OUTPUT'].getFeatures():
        if obj['rodzaj'] == 'miasto w gminie miejsko-wiejskiej':
            if len(str(obj['identyfikatorTERYTjednostki'])) < 7:
                Teryt = str(obj['identyfikatorTERYTjednostki']).zfill(7)
            else:
                Teryt = str(obj['identyfikatorTERYTjednostki'])
            terytyMiast.append(Teryt)
            teryt = Teryt[:4]
    
    config = configparser.ConfigParser()
    mainPath = pathlib.Path(QgsApplication.qgisSettingsDirPath()) / pathlib.Path("python/plugins/Walidator_plikow_gml/")
    config.read(str(mainPath) + '/Walidator_plikow_gml.ini')
    graniceJednostekEwidencyjnychPath = config['DEFAULT']['granicejednostekewidencyjnych']
    graniceJednostekEwidencyjnych = QgsVectorLayer(graniceJednostekEwidencyjnychPath, 'GraniceJednostekEwidencyjnych', 'ogr')
    graniceJednostekEwidencyjnych_z_PRG = QgsVectorLayer("Polygon?crs=epsg:2180&field=gml_id:string(254)", "granice jednostek ewidencyjnych z PRG", "memory")
    
    graniceJednostekEwidencyjnych = processing.run("native:multiparttosingleparts", {
        'INPUT': graniceJednostekEwidencyjnych,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    for obj in graniceJednostekEwidencyjnych.getFeatures():
        JPT_KOD_JE = str(obj['JPT_KOD_JE']).replace("_", "")
        if JPT_KOD_JE in terytyMiast:
            graniceJednostekEwidencyjnych_z_PRG.dataProvider().addFeatures([obj])
        else:
            if JPT_KOD_JE[:4] == teryt and JPT_KOD_JE[-1] in ['4', '3']:
                nowyRekord = QgsFeature(graniceJednostekEwidencyjnych_z_PRG.fields())
                nowyRekord.setAttribute(0, 'nie dotyczy')
                nowyRekord.setGeometry(obj.geometry())
                obiektyZbledami.append(nowyRekord)
    
    extractbyexpression_linia = processing.run("native:polygonstolines", {
        'INPUT': extractbyexpression['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    jednostkiEwidencyjne_z_PRG_linia = processing.run("native:polygonstolines", {
        'INPUT': graniceJednostekEwidencyjnych_z_PRG,
        'OUTPUT': 'memory:'
    })
   
    bufor = processing.run("native:buffer", {
        'INPUT': jednostkiEwidencyjne_z_PRG_linia['OUTPUT'],
        'DISTANCE': 0.02,
        'SEGMENTS': 10,
        'DISSOLVE': True,
        'OUTPUT': 'memory:'
    })
    
    difference = processing.run("qgis:difference", {
        'INPUT': extractbyexpression_linia['OUTPUT'],
        'OVERLAY': bufor['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    pojedynczeObiekty = processing.run("native:multiparttosingleparts", {
        'INPUT': difference['OUTPUT'],
        'OUTPUT': 'memory:'
    })
    
    if pojedynczeObiekty['OUTPUT'].featureCount() > 0:
        is_error_found = True
        for lyr in QgsProject.instance().mapLayers().values():
            if lyr.name() == "granice jednostek ewidencyjnych z PRG":
                is_error_found = False
        if is_error_found:
            QgsProject.instance().addMapLayer(graniceJednostekEwidencyjnych_z_PRG)
        
        for obj in pojedynczeObiekty['OUTPUT'].getFeatures():
            obiektyZbledami.append(obj)
    
    return obiektyZbledami


def kompletnoscPlikowBDOT10k(pliki):
    obiektyZbledami = []
    
    listaKlas = ['OT_ADJA_A','OT_ADMS_A','OT_ADMS_P','OT_BUBD_A','OT_BUHD_A','OT_BUHD_L','OT_BUIB_A','OT_BUIB_L','OT_BUIN_L','OT_BUIT_A',
                 'OT_BUIT_P','OT_BUSP_A','OT_BUSP_L','OT_BUTR_L','OT_BUTR_P','OT_BUUO_L','OT_BUWT_A','OT_BUWT_P','OT_BUZM_L','OT_BUZT_A',
                 'OT_BUZT_P','OT_KUHO_A','OT_KUHU_A','OT_KUKO_A','OT_KUKO_P','OT_KUMN_A','OT_KUOS_A','OT_KUOZ_A','OT_KUPG_A','OT_KUPG_P',
                 'OT_KUPW_A','OT_KUSC_A','OT_KUSK_A','OT_KUZA_A','OT_OIKM_A','OT_OIKM_L','OT_OIKM_P','OT_OIMK_A','OT_OIOR_A','OT_OIOR_L',
                 'OT_OIOR_P','OT_OIPR_L','OT_OIPR_P','OT_OISZ_A','OT_PTGN_A','OT_PTKM_A','OT_PTLZ_A','OT_PTNZ_A','OT_PTPL_A','OT_PTRK_A',
                 'OT_PTSO_A','OT_PTTR_A','OT_PTUT_A','OT_PTWP_A','OT_PTWZ_A','OT_PTZB_A','OT_RTLW_L','OT_RTPW_P','OT_SKDR_L','OT_SKJZ_L',
                 'OT_SKPP_L','OT_SKRP_L','OT_SKRW_P','OT_SKTR_L','OT_SULN_L','OT_SUPR_L','OT_SWKN_L','OT_SWRM_L','OT_SWRS_L','OT_TCON_A',
                 'OT_TCPK_A','OT_TCPN_A','OT_TCRZ_A']
    
    brakujaceKlasy = QgsVectorLayer("Point?crs=epsg:2180&field=gml_id:string(254)", "brakujace klasy", "memory")
    
    for klasa in listaKlas:
        brakKlasy = True
        for plik in pliki:
            if plik.__contains__(klasa):
                brakKlasy = False
                break
        if brakKlasy:
            brakujaceKlasy.startEditing()
            nowyRekord = QgsFeature(brakujaceKlasy.fields())
            nowyRekord.setAttribute(0, klasa)
            nowyRekord.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(0, 0)))
            brakujaceKlasy.addFeature(nowyRekord)
            brakujaceKlasy.commitChanges()
            obiektyZbledami.append(nowyRekord)
    
    return obiektyZbledami


def kompletnoscObiektowBDOT10k(layer, plikGMLzrodlowy, plikGML):
    obiektyZbledami = []
    
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'ot': 'urn:gugik:specyfikacje:gmlas:bazaDanychObiektowTopograficznych10k:2.0'}
    lokalnyIdsKontrolowane = [element.text for element in lxml.etree.parse(plikGML).getroot().findall('.//ot:lokalnyId', namespaces=ns)]
    lokalnyIdsZrodla = [element.text for element in lxml.etree.parse(plikGMLzrodlowy).getroot().findall('.//ot:lokalnyId', namespaces=ns)]
    
    set_difference = set(lokalnyIdsZrodla) - set(lokalnyIdsKontrolowane)
    list_difference_result = list(set_difference)
    
    if len(list_difference_result) > 0:
        layerDaneZrodlowe = QgsVectorLayer(plikGMLzrodlowy, 'BDOT10k_dane_zrodlowe', 'ogr')
        
        for diff in list_difference_result:
            expression = QgsExpression(f'"lokalnyId" = \'{diff}\'')
            request = QgsFeatureRequest(expression)
            for feature in layerDaneZrodlowe.getFeatures(request):
                obiektyZbledami.append(feature)
    
    return obiektyZbledami


def kontrolaZmianAtrybutowWzgledemWersji(layer, plikGMLzrodlowy, plikGML):
    obiektyZbledami = set()
    parser = etree.XMLParser(remove_blank_text=True)
    k = lxml.etree.parse(plikGML, parser).getroot()
    z = lxml.etree.parse(plikGMLzrodlowy, parser).getroot()
    
    # usuwanie gml:id
    for elem in k.xpath('//*[@gml:id]', namespaces={'gml': 'http://www.opengis.net/gml/3.2'}):
        del elem.attrib['{http://www.opengis.net/gml/3.2}id']
    for elem in z.xpath('//*[@gml:id]', namespaces={'gml': 'http://www.opengis.net/gml/3.2'}):
        del elem.attrib['{http://www.opengis.net/gml/3.2}id']
    
    # usuwanie zbędnych spacji z gml:posList
    for posList_elem in k.xpath('//gml:posList', namespaces={'gml': 'http://www.opengis.net/gml/3.2'}):
        if posList_elem.text:
            posList_elem.text = posList_elem.text.strip()
    for posList_elem in z.xpath('//gml:posList', namespaces={'gml': 'http://www.opengis.net/gml/3.2'}):
        if posList_elem.text:
            posList_elem.text = posList_elem.text.strip()
    
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'ot': 'urn:gugik:specyfikacje:gmlas:bazaDanychObiektowTopograficznych10k:2.0'}
    fMembers_K = k.findall('.//gml:featureMember', namespaces=ns)
    fMembers_Z = z.findall('.//gml:featureMember', namespaces=ns)
    
    fMembers_K_dic = {}
    fMembers_Z_dic = {}
    badfMember_Z_dic = {}
    
    for fMember in fMembers_K:
        fMembers_K_dic[fMember.find('.//ot:lokalnyId', namespaces=ns).text] = fMember
    fMembers_K_dic = dict(sorted(fMembers_K_dic.items()))
    for fMember in fMembers_Z:
        fMembers_Z_dic[fMember.find('.//ot:lokalnyId', namespaces=ns).text] = fMember
    fMembers_Z_dic = dict(sorted(fMembers_Z_dic.items()))
    del fMembers_K, fMembers_Z
    
    for fMember_Z_dic in fMembers_Z_dic:
        if fMember_Z_dic in fMembers_K_dic and etree.tostring(fMembers_K_dic[fMember_Z_dic], method="c14n", exclusive=True) != etree.tostring(fMembers_Z_dic[fMember_Z_dic], method="c14n", exclusive=True):
            if fMembers_K_dic[fMember_Z_dic].find('.//ot:wersja', namespaces=ns).text == fMembers_Z_dic[fMember_Z_dic].find('.//ot:wersja', namespaces=ns).text:
                atrybutyZRoznica = set()
                for element in fMembers_Z_dic[fMember_Z_dic].iter():
                    elementyIdentyczne = False
                    for fM_K_dic_element in fMembers_K_dic[fMember_Z_dic].findall('.//' + element.tag):
                        if fM_K_dic_element.text == element.text:
                            elementyIdentyczne = True
                    if not elementyIdentyczne and element.tag != '{http://www.opengis.net/gml/3.2}featureMember':
                        if not element.tag.split("}")[1].startswith('OT_'):
                            if element.tag.split("}")[1] in ['posList','LinearRing','LineString','exterior','interior','Polygon','segments','LineStringSegment','Curve','pos','Point']:
                                atrybutyZRoznica.add('geometria')
                            else:
                                atrybutyZRoznica.add(element.tag.split("}")[1])
                for element in fMembers_K_dic[fMember_Z_dic].iter():
                    elementyIdentyczne = False
                    for fM_Z_dic_element in fMembers_Z_dic[fMember_Z_dic].findall('.//' + element.tag):
                        if fM_Z_dic_element.text == element.text:
                            elementyIdentyczne = True
                    if not elementyIdentyczne and element.tag != '{http://www.opengis.net/gml/3.2}featureMember':
                        if not element.tag.split("}")[1].startswith('OT_'):
                            if element.tag.split("}")[1] in ['posList','LinearRing','LineString','exterior','interior','Polygon','segments','LineStringSegment','Curve','pos','Point']:
                                atrybutyZRoznica.add('geometria')
                            else:
                                atrybutyZRoznica.add(element.tag.split("}")[1])
                if len(atrybutyZRoznica) > 0:
                    badfMember_Z_dic[fMember_Z_dic] = atrybutyZRoznica
    
    if len(badfMember_Z_dic) > 0:
        for feature in layer.getFeatures():
            if feature['lokalnyId'] in badfMember_Z_dic:
                gml_id = feature["gml_id"] + "|" + ','.join(badfMember_Z_dic[feature['lokalnyId']])
                feature.setAttribute(layer.fields().indexFromName("gml_id"), gml_id)
                layer.updateFeature(feature)
                obiektyZbledami.add(feature)
                layer.commitChanges()
    
    del fMembers_Z_dic, fMembers_K_dic, badfMember_Z_dic
    
    return obiektyZbledami


def kontrolaZgodnosciZDanymiPRNG(layer, plik_prng, klasa):
    global loaded_gml_prng_miejscowosci, loaded_gml_prng_obiektyfizjograficzne
    obiektyZbledami = []
    
    if not 'identyfikatorPRNG' in [field.name() for field in layer.fields()]:
        return []
    
    if loaded_gml_prng_miejscowosci is None and 'PRNG_MIEJSCOWOSCI' in plik_prng:
        loaded_gml_prng_miejscowosci = QgsVectorLayer(plik_prng, 'Warstwa GML', 'ogr')
    
    if loaded_gml_prng_obiektyfizjograficzne is None and 'PRNG_OBIEKTY_FIZJOGRAFICZNE' in plik_prng:
        loaded_gml_prng_obiektyfizjograficzne = QgsVectorLayer(plik_prng, 'Warstwa GML', 'ogr')
    
    if 'PRNG_MIEJSCOWOSCI' in plik_prng:
        loaded_gml_prng = loaded_gml_prng_miejscowosci
    else:
        loaded_gml_prng = loaded_gml_prng_obiektyfizjograficzne
    
    posiada_ID_PRNG = processing.run("qgis:extractbyexpression", {
        'INPUT': layer,
        'EXPRESSION': '"identyfikatorPRNG" IS NOT NULL',
        'OUTPUT': 'memory:'
    })
    layer_with_id = posiada_ID_PRNG['OUTPUT']
    # Pobierz indeks pola 'identyfikatorPRNG'
    idx_id_field = layer_with_id.fields().indexFromName('identyfikatorPRNG')
    nazwa =layer_with_id.fields()[idx_id_field].name()
    # Sprawdź typ pola
    field_type = layer_with_id.fields()[idx_id_field].type()
    # Jeśli typ pola jest różny od int, wykonaj konwersję
    if field_type != QVariant.Int: 
        layer_with_id.startEditing() # utworzenie nowego pola
        idx_new_field =layer_with_id.dataProvider().addAttributes([QgsField("identyfikatorPRNG_int", QVariant.Int)])
        layer_with_id.updateFields()
        zmiana = processing.run("qgis:fieldcalculator", {
            'INPUT': layer_with_id,
            'FIELD_NAME': 'identyfikatorPRNG_int',
            'FIELD_TYPE': 0,  # typ danych: Integer
            'FORMULA': 'toint("identyfikatorPRNG")',
            'OUTPUT': 'memory:'
        })
        # Zaktualizuj indeks pola
        idx_id_field = layer_with_id.fields().indexFromName('identyfikatorPRNG_int')
        nazwa =layer_with_id.fields()[idx_id_field].name()
        layer_with_id = zmiana['OUTPUT'] # podstawienie do zmiennej
    joinattributestable = processing.run("native:joinattributestable", {
        'INPUT': layer_with_id, #poprzednio: posiada_ID_PRNG['OUTPUT'],
        'FIELD':  nazwa, #'identyfikatorPRNG',
        'INPUT_2': loaded_gml_prng,
        'FIELD_2':'identyfikatorPRNG',
        'FIELDS_TO_COPY': ['identyfikatorPRNG','nazwaGlowna'],
        'METHOD': 1,
        'DISCARD_NONMATCHING': False,
        'OUTPUT': 'memory:',
        'NON_MATCHING':'memory:'
    })
    
    for feature in joinattributestable['OUTPUT'].getFeatures():
        if feature['nazwa'] != feature['nazwaGlowna']:
            gml_id = str(feature["gml_id"]) + '| nazwaGlowna:' + str(feature['nazwaGlowna']) + ',nazwa:' + str(feature['nazwa'])
            feature.setAttribute(joinattributestable['OUTPUT'].fields().indexFromName("gml_id"), gml_id)
            joinattributestable['OUTPUT'].updateFeature(feature)
            obiektyZbledami.append(feature)
    
    if joinattributestable['NON_MATCHING'].featureCount() > 0:
        joinattributestable['NON_MATCHING'].setName(f"obiekty {klasa} nie połączone z PRNG")
        QgsProject.instance().addMapLayer(joinattributestable['NON_MATCHING'])
    
    return obiektyZbledami


def kontrolaZgodnosciZDanymiGDOS(layer, tc_zip, klasa):
    global tereny_chronione_zip
    obiektyZbledami = []
    klasaPliki = {'OT_TCPN_A': ['ParkiNarodowePolygon.shp'],
                  'OT_TCPK_A': ['ParkiKrajobrazowePolygon.shp'],
                  'OT_TCRZ_A': ['RezerwatyPolygon.shp'],
                  'OT_TCON_A': ['ObszarySpecjalnejOchronyPolygon.shp', 'SpecjalneObszaryOchronyPolygon.shp']}
    
    if tereny_chronione_zip is None:
        tereny_chronione_zip = tc_zip
        if zipfile.is_zipfile(tereny_chronione_zip):
            with zipfile.ZipFile(tereny_chronione_zip, 'r') as plikZIP:
                plikZIP.extractall(os.path.dirname(tereny_chronione_zip))
    
    loaded_shp = {klasa: [] for klasa in klasaPliki.keys()}
    
    for i, klasaPlik in enumerate(klasaPliki[klasa]):
        sciezka = os.path.join(os.path.dirname(tereny_chronione_zip), klasaPlik)
        loaded_shp[klasa].append(QgsVectorLayer(sciezka, f'Warstwa {i} SHP dla klasy {klasa}', 'ogr'))
    
    posiada_numerCRFOP = processing.run("qgis:extractbyexpression", {
        'INPUT': layer,
        'EXPRESSION': '"numerCRFOP" IS NOT NULL',
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    if klasa != 'OT_TCON_A':
        shp_out = processing.run("qgis:extractbyexpression", {
            'INPUT': loaded_shp[klasa][0],
            'EXPRESSION': "not nazwa like '%otulina%'",
            'OUTPUT': 'memory:'
        })['OUTPUT']
    else:
        shp_out = processing.run("native:mergevectorlayers", {
            'LAYERS': loaded_shp[klasa],
            'OUTPUT': 'memory:'
        })['OUTPUT']
    
    config = configparser.ConfigParser()
    mainPath = pathlib.Path(QgsApplication.qgisSettingsDirPath()) / pathlib.Path(r"python/plugins/Walidator_plikow_gml/")
    config.read(str(mainPath) + '/Walidator_plikow_gml.ini')
    granicePowiatowPath = config['DEFAULT']['granicepowiatow']
    granicePowiatow = QgsVectorLayer(granicePowiatowPath, 'GranicePowiatow', 'ogr')
    
    granicePowiatow = processing.run("native:multiparttosingleparts", {
        'INPUT': granicePowiatow,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    powiat_z_PRG = QgsVectorLayer("Polygon?crs=epsg:2180&field=gml_id:string(254)", "granica powiatu z PRG", "memory")
    terytPowiatu = int(layer.name()[-15:-11])
    
    for obj in granicePowiatow.getFeatures():
        if str(obj['JPT_KOD_JE']) == str(terytPowiatu):
            powiat_z_PRG.dataProvider().addFeatures([obj])
            break
    
    clip = processing.run("native:clip", {
        'INPUT': shp_out,
        'OVERLAY': powiat_z_PRG,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    shp_out_linie = processing.run("native:polygonstolines", {
        'INPUT': clip,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    posiada_numerCRFOP_linie = processing.run("native:polygonstolines", {
        'INPUT': posiada_numerCRFOP,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    bufor = processing.run("native:buffer", {
        'INPUT': shp_out_linie,
        'DISTANCE': 0.20,
        'SEGMENTS': 10,
        'DISSOLVE': True,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    difference = processing.run("qgis:difference", {
        'INPUT': posiada_numerCRFOP_linie,
        'OVERLAY': bufor,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    pojedynczeObiekty = processing.run("native:multiparttosingleparts", {
        'INPUT': difference,
        'OUTPUT': 'memory:'
    })['OUTPUT']
    
    if pojedynczeObiekty.featureCount() > 0:
        poza_GDOS = QgsVectorLayer("LineString?crs=epsg:2180&field=gml_id:string(254)", f"niezgodność geometrii {klasa} z danymi GDOŚ", "memory")
        poza_GDOS.startEditing()
        for n in pojedynczeObiekty.getFeatures():
            nowyRekord = QgsFeature(poza_GDOS.fields())
            nowyRekord.setAttribute(0, 'nie dotyczy')
            nowyRekord.setGeometry(n.geometry())
            poza_GDOS.addFeature(nowyRekord)
            obiektyZbledami.append(nowyRekord)
        poza_GDOS.commitChanges()
        QgsProject.instance().addMapLayer(poza_GDOS)
    
    return obiektyZbledami


def kontrolaFormatuAtrybutuWysokosc(layer, expression, plikGML):
    obiektyZbledami = []
    
    extractbyexpression = processing.run("qgis:extractbyexpression", {
        'INPUT': layer,
        'EXPRESSION': expression,
        'FAIL_OUTPUT': 'memory:',
        'OUTPUT': 'memory:'
    })
    if extractbyexpression['OUTPUT'].featureCount() > 0:
        fMembers_dic = {}
        root = plikGML.getroot()
        ns = {'gml': 'http://www.opengis.net/gml/3.2', 'ot': 'urn:gugik:specyfikacje:gmlas:bazaDanychObiektowTopograficznych10k:2.0'}
        fMembers = root.findall('.//gml:featureMember', namespaces=ns)
        for fMember in fMembers:
            wysokosc = fMember.find('.//ot:wysokosc', namespaces=ns).text
            gmlids = fMember.xpath('.//*[@gml:id]', namespaces={'gml': 'http://www.opengis.net/gml/3.2'})
            fMembers_dic[gmlids[0].get('{http://www.opengis.net/gml/3.2}id')] = wysokosc
    
    for feature in extractbyexpression['OUTPUT'].getFeatures():
        new_expression = expression.replace("\\\\", "\\")
        if not bool(re.fullmatch(re.search(r"'(.*?)'", new_expression).group(1), fMembers_dic[feature['gml_id']])):
            obiektyZbledami.append(feature)
    
    return obiektyZbledami


def kodKarto10kNULL(layer):
    obiektyZbledami = []
    try:
        oimka = None
        ptsoa = None
        ptwza = None
        ptgna = None
        if layer.name().__contains__('RTLW_L'):
            oimka=layer.name().replace("RTLW_L","OIMK_A") # Bagno
            if QgsProject().instance().mapLayersByName(oimka):
               oimka = QgsProject().instance().mapLayersByName(oimka)[0]
            ptsoa=layer.name().replace("RTLW_L","PTSO_A")[0] # teren z odpadami komunalnymi i przemysłowymi
            if QgsProject().instance().mapLayersByName(ptsoa):
                ptsoa = QgsProject().instance().mapLayersByName(ptsoa)[0]
            ptwza = layer.name().replace("RTLW_L","PTWZ_A")[0] # zwałowisko, wyrobisko
            if QgsProject().instance().mapLayersByName(ptwza):
                ptwza = QgsProject().instance().mapLayersByName(ptwza)[0]
            ptgna=layer.name().replace("RTLW_L","PTGN_A")
            if  QgsProject().instance().mapLayersByName(ptgna):
                QgsProject().instance().mapLayersByName(ptgna)[0] # teren piaszczysty, żwirowy, kamienisty i rumowisko  skalne
            
        extractbyexpression = processing.run("qgis:extractbyexpression", {
            'INPUT': layer,
            'EXPRESSION': '"rodzaj" in (\'poziomica\') and "kodKarto10k" != \'\'',
            'FAIL_OUTPUT': 'memory:',
            'OUTPUT': 'memory:'
        })
        if isinstance(oimka, QgsVectorLayer): 
            # bufor -0.04 m
            bufor = processing.run("native:buffer", {
                'INPUT': oimka,
                'DISTANCE': -0.04,
                'SEGMENTS': 10,
                'DISSOLVE': False,
                'OUTPUT': 'memory:'
            })
            pojedynczeOIMKA = processing.run("native:multiparttosingleparts", {
                'INPUT': bufor['OUTPUT'],
                'OUTPUT': 'memory:'
            })
            extractBagno = processing.run("qgis:extractbyexpression", {
                'INPUT': pojedynczeOIMKA['OUTPUT'],
                'EXPRESSION': '"rodzaj" in (\'bagno\')',
                'FAIL_OUTPUT': 'memory:',
                'OUTPUT': 'memory:'
            })
            extractbylocation = processing.run("native:extractbylocation", {
                'INPUT': extractbyexpression['OUTPUT'],
                'INTERSECT': extractBagno['OUTPUT'],
                'PREDICATE': [0],
                'OUTPUT': 'memory:'
            })
            if extractbylocation['OUTPUT'].featureCount() > 0:
                for obj in extractbylocation['OUTPUT'].getFeatures():
                    obiektyZbledami.append(obj)
        if isinstance(ptgna, QgsVectorLayer):
            # bufor -0.04 m
            bufor = processing.run("native:buffer", {
                'INPUT': ptgna,
                'DISTANCE': -0.04,
                'SEGMENTS': 10,
                'DISSOLVE': False,
                'OUTPUT': 'memory:'
            })
            pojedynczePTGNA = processing.run("native:multiparttosingleparts", {
                'INPUT': bufor['OUTPUT'],
                'OUTPUT': 'memory:'
            })
            extractGrunt = processing.run("qgis:extractbyexpression", {
                'INPUT': pojedynczePTGNA['OUTPUT'],
                'EXPRESSION': '"rodzaj" in (\'piarg, usypisko lub rumowisko skalne\', \'teren kamienisty\', \'teren piaszczysty lub żwirowy\')',
                'FAIL_OUTPUT': 'memory:',
                'OUTPUT': 'memory:'
            })
            extractbylocation = processing.run("native:extractbylocation", {
                'INPUT': extractbyexpression['OUTPUT'],
                'INTERSECT': extractGrunt['OUTPUT'],
                'PREDICATE': [0],
                'OUTPUT': 'memory:'
            })
            if extractbylocation['OUTPUT'].featureCount() > 0:
                for obj in extractbylocation['OUTPUT'].getFeatures():
                    obiektyZbledami.append(obj)
        if isinstance(ptsoa, QgsVectorLayer):
              # bufor -0.04 m
              bufor = processing.run("native:buffer", {
                  'INPUT': ptsoa,
                  'DISTANCE': -0.04,
                  'SEGMENTS': 10,
                  'DISSOLVE': False,
                  'OUTPUT': 'memory:'
              })
              pojedynczePTSOA = processing.run("native:multiparttosingleparts", {
                  'INPUT': bufor['OUTPUT'],
                  'OUTPUT': 'memory:'
              })
              extractbylocation = processing.run("native:extractbylocation", {
                  'INPUT': extractbyexpression['OUTPUT'],
                  'INTERSECT': pojedynczePTSOA['OUTPUT'],
                  'PREDICATE': [0],
                  'OUTPUT': 'memory:'
              })
              if extractbylocation['OUTPUT'].featureCount() > 0:
                  for obj in extractbylocation['OUTPUT'].getFeatures():
                      obiektyZbledami.append(obj)
        if isinstance(ptwza, QgsVectorLayer):
              # bufor -0.04 m
              bufor = processing.run("native:buffer", {
                  'INPUT': ptwza,
                  'DISTANCE': -0.04,
                  'SEGMENTS': 10,
                  'DISSOLVE': False,
                  'OUTPUT': 'memory:'
              })
              pojedynczePTWZA = processing.run("native:multiparttosingleparts", {
                  'INPUT': bufor['OUTPUT'],
                  'OUTPUT': 'memory:'
              })
              extractbylocation = processing.run("native:extractbylocation", {
                  'INPUT': extractbyexpression['OUTPUT'],
                  'INTERSECT': pojedynczePTWZA['OUTPUT'],
                  'PREDICATE': [0],
                  'OUTPUT': 'memory:'
              })
              if extractbylocation['OUTPUT'].featureCount() > 0:
                  for obj in extractbylocation['OUTPUT'].getFeatures():
                      obiektyZbledami.append(obj)
    except:
        pass
    return obiektyZbledami


def blednePolozeniePktWys(layer):
    obiektyZbledami = []
    try:
        bubda = None
        buzta = None
        oiora = None
        buwta = None
        ptnza = None
        ptsoa = None
        ptwpa = None
        ptwza = None
        if layer.name().__contains__('RTPW_P'):
            bubda=layer.name().replace("RTPW_P","BUBD_A")
            if QgsProject().instance().mapLayersByName(bubda):
               bubda= QgsProject().instance().mapLayersByName(bubda)[0]
            buwta=layer.name().replace("RTPW_P","BUWT_A")
            if QgsProject().instance().mapLayersByName(buwta):
                buwta=QgsProject().instance().mapLayersByName(buwta)[0]
            buzta=layer.name().replace("RTPW_P","BUZT_A")
            if QgsProject().instance().mapLayersByName(buzta):
                buzta=QgsProject().instance().mapLayersByName(buzta)[0]
            oiora=layer.name().replace("RTPW_P","OIOR_A")
            if QgsProject().instance().mapLayersByName(oiora):
                oiora=QgsProject().instance().mapLayersByName(oiora)[0]
            ptnza=layer.name().replace("RTPW_P","PTNZ_A")
            if QgsProject().instance().mapLayersByName(ptnza):
                ptnza=QgsProject().instance().mapLayersByName(ptnza)[0]
            ptsoa=layer.name().replace("RTPW_P","PTSO_A")
            if QgsProject().instance().mapLayersByName(ptsoa):
                ptsoa=QgsProject().instance().mapLayersByName(ptsoa)[0]
            ptwpa=layer.name().replace("RTPW_P","PTWP_A")
            if QgsProject().instance().mapLayersByName(ptwpa): 
               ptwpa= QgsProject().instance().mapLayersByName(ptwpa)[0]
            ptwza=layer.name().replace("RTPW_P","PTWZ_A")
            if QgsProject().instance().mapLayersByName(ptwza): 
                ptwza=QgsProject().instance().mapLayersByName(ptwza)[0]
            if isinstance(bubda, QgsVectorLayer):
                # bufor -0.02 m
                bufor = processing.run("native:buffer", {
                    'INPUT': bubda,
                    'DISTANCE': -0.02,
                    'SEGMENTS': 10,
                    'DISSOLVE': False,
                    'OUTPUT': 'memory:'
                })
                pojedynczeBUBDA = processing.run("native:multiparttosingleparts", {
                    'INPUT': bufor['OUTPUT'],
                    'OUTPUT': 'memory:'
                })
                extractbylocation = processing.run("native:extractbylocation", {
                    'INPUT': layer,#extractbyexpression['OUTPUT'],
                    'INTERSECT': pojedynczeBUBDA['OUTPUT'],
                    'PREDICATE': [0],
                    'OUTPUT': 'memory:'
                })
                if extractbylocation['OUTPUT'].featureCount() > 0:
                    for obj in extractbylocation['OUTPUT'].getFeatures():
                        obiektyZbledami.append(obj)
            if isinstance(buwta, QgsVectorLayer):
                # bufor -0.02 m
                bufor = processing.run("native:buffer", {
                    'INPUT': buwta,
                    'DISTANCE': -0.02,
                    'SEGMENTS': 10,
                    'DISSOLVE': False,
                    'OUTPUT': 'memory:'
                })
                pojedynczeBUBDA = processing.run("native:multiparttosingleparts", {
                    'INPUT': bufor['OUTPUT'],
                    'OUTPUT': 'memory:'
                })
                extractbylocation = processing.run("native:extractbylocation", {
                    'INPUT': layer,
                    'INTERSECT': pojedynczeBUBDA['OUTPUT'],
                    'PREDICATE': [0],
                    'OUTPUT': 'memory:'
                })
                if extractbylocation['OUTPUT'].featureCount() > 0:
                    for obj in extractbylocation['OUTPUT'].getFeatures():
                        obiektyZbledami.append(obj)
            if isinstance(buzta, QgsVectorLayer):
                # bufor -0.02 m
                bufor = processing.run("native:buffer", {
                    'INPUT': buzta,
                    'DISTANCE': -0.02,
                    'SEGMENTS': 10,
                    'DISSOLVE': False,
                    'OUTPUT': 'memory:'
                })
                pojedynczeBUZTA = processing.run("native:multiparttosingleparts", {
                    'INPUT': bufor['OUTPUT'],
                    'OUTPUT': 'memory:'
                })
                extractbylocation = processing.run("native:extractbylocation", {
                    'INPUT': layer,
                    'INTERSECT': pojedynczeBUZTA['OUTPUT'],
                    'PREDICATE': [0],
                    'OUTPUT': 'memory:'
                })
                if extractbylocation['OUTPUT'].featureCount() > 0:
                    for obj in extractbylocation['OUTPUT'].getFeatures():
                        obiektyZbledami.append(obj)
            if isinstance(oiora, QgsVectorLayer):
                 # bufor -0.02 m
                 bufor = processing.run("native:buffer", {
                     'INPUT': oiora,
                     'DISTANCE': -0.02,
                     'SEGMENTS': 10,
                     'DISSOLVE': False,
                     'OUTPUT': 'memory:'
                 })
                 pojedynczeOIORA = processing.run("native:multiparttosingleparts", {
                     'INPUT': bufor['OUTPUT'],
                     'OUTPUT': 'memory:'
                 })
                 extractWiata = processing.run("qgis:extractbyexpression", {
                     'INPUT': pojedynczeOIORA['OUTPUT'],
                     'EXPRESSION': '"rodzaj" in (\'wiata lub altana\')',
                     'FAIL_OUTPUT': 'memory:',
                     'OUTPUT': 'memory:'
                 })
                 extractbylocation = processing.run("native:extractbylocation", {
                     'INPUT': layer, 
                     'INTERSECT': extractWiata['OUTPUT'],
                     'PREDICATE': [0],
                     'OUTPUT': 'memory:'
                 })
                 if extractbylocation['OUTPUT'].featureCount() > 0:
                     for obj in extractbylocation['OUTPUT'].getFeatures():
                        obiektyZbledami.append(obj)
            if isinstance(ptnza, QgsVectorLayer):
                # bufor -0.02 m
                bufor = processing.run("native:buffer", {
                    'INPUT': ptnza,
                    'DISTANCE': -0.02,
                    'SEGMENTS': 10,
                    'DISSOLVE': False,
                    'OUTPUT': 'memory:'
                })
                pojedynczePTNZA = processing.run("native:multiparttosingleparts", {
                    'INPUT': bufor['OUTPUT'],
                    'OUTPUT': 'memory:'
                })
                extractbylocation = processing.run("native:extractbylocation", {
                    'INPUT': layer,
                    'INTERSECT': pojedynczePTNZA['OUTPUT'],
                    'PREDICATE': [0],
                    'OUTPUT': 'memory:'
                })
                if extractbylocation['OUTPUT'].featureCount() > 0:
                    for obj in extractbylocation['OUTPUT'].getFeatures():
                        obiektyZbledami.append(obj)
            if isinstance(ptsoa, QgsVectorLayer):
                # bufor -0.02 m
                bufor = processing.run("native:buffer", {
                    'INPUT': ptsoa,
                    'DISTANCE': -0.02,
                    'SEGMENTS': 10,
                    'DISSOLVE': False,
                    'OUTPUT': 'memory:'
                })
                pojedynczePTSOA = processing.run("native:multiparttosingleparts", {
                    'INPUT': bufor['OUTPUT'],
                    'OUTPUT': 'memory:'
                })
                extractbylocation = processing.run("native:extractbylocation", {
                    'INPUT': layer, 
                    'INTERSECT': pojedynczePTSOA['OUTPUT'],
                    'PREDICATE': [0],
                    'OUTPUT': 'memory:'
                })
                if extractbylocation['OUTPUT'].featureCount() > 0:
                    for obj in extractbylocation['OUTPUT'].getFeatures():
                        obiektyZbledami.append(obj)
            if isinstance(ptwpa, QgsVectorLayer):
                # bufor -0.02 m
                bufor = processing.run("native:buffer", {
                    'INPUT': ptwpa,
                    'DISTANCE': -0.02,
                    'SEGMENTS': 10,
                    'DISSOLVE': False,
                    'OUTPUT': 'memory:'
                })
                pojedynczePTWPA = processing.run("native:multiparttosingleparts", {
                    'INPUT': bufor['OUTPUT'],
                    'OUTPUT': 'memory:'
                })
                extractbylocation = processing.run("native:extractbylocation", {
                    'INPUT': layer, 
                    'INTERSECT': pojedynczePTWPA['OUTPUT'],
                    'PREDICATE': [0],
                    'OUTPUT': 'memory:'
                })
                if extractbylocation['OUTPUT'].featureCount() > 0:
                    for obj in extractbylocation['OUTPUT'].getFeatures():
                        obiektyZbledami.append(obj)
            if isinstance(ptwza, QgsVectorLayer):
                # bufor -0.02 m
                bufor = processing.run("native:buffer", {
                    'INPUT': ptwza,
                    'DISTANCE': -0.02,
                    'SEGMENTS': 10,
                    'DISSOLVE': False,
                    'OUTPUT': 'memory:'
                })
                pojedynczePTWZA = processing.run("native:multiparttosingleparts", {
                    'INPUT': bufor['OUTPUT'],
                    'OUTPUT': 'memory:'
                })
                extractbylocation = processing.run("native:extractbylocation", {
                    'INPUT': layer, 
                    'INTERSECT': pojedynczePTWZA['OUTPUT'],
                    'PREDICATE': [0],
                    'OUTPUT': 'memory:'
                })
                if extractbylocation['OUTPUT'].featureCount() > 0:
                    for obj in extractbylocation['OUTPUT'].getFeatures():
                        obiektyZbledami.append(obj)
    except:
        pass
    return obiektyZbledami


def kontrolaKodKarto10k219_1(layer):
    try:
        obiektyZbledami = []
        dodane_bledy_ids = set()  # Analiza unikalnych Id obiektów błędnych
        
        if not layer.isValid():
            return []
        
        # Wyszukiwanie warstw OT_SKTR_L i OT_SKJZ_L
        sktr_layer_name = layer.name().replace("OT_BUIN_L", "OT_SKTR_L")
        skjz_layer_name = layer.name().replace("OT_BUIN_L", "OT_SKJZ_L")
        
        sktr_layers = QgsProject.instance().mapLayersByName(sktr_layer_name)
        skjz_layers = QgsProject.instance().mapLayersByName(skjz_layer_name)
        
        if not sktr_layers or not skjz_layers:
            return []
        
        sktr = sktr_layers[0]
        skjz = skjz_layers[0]
        
        # Tworzenie indeksów przestrzennych
        index_buin = QgsSpatialIndex(layer.getFeatures())
        index_sktr = QgsSpatialIndex(sktr.getFeatures())
        index_skjz = QgsSpatialIndex(skjz.getFeatures())
        
        # Bufor granicy
        granica = adjaMinus2cmBufor(layer)
        
        # Filtrowanie warstwy BUIN_L według kodu
        extract_params = {
            'INPUT': layer,
            'EXPRESSION': '"kodKarto10k" = \'0010_219_1\'',
            'OUTPUT': 'memory:'
        }
        extract_result = processing.run("qgis:extractbyexpression", extract_params)
        filtered_layer = extract_result['OUTPUT']
        
        # Filtrowanie obiektów według 'rodzaj' oraz kontrola długości
        for obj in filtered_layer.getFeatures():
            
            # Sprawdzanie, czy rodzaj jest poprawny
            if obj['rodzaj'] != 'tunel':
                print(f"-> Niewłaściwy rodzaj: {obj['rodzaj']}")
                obiektyZbledami.append(obj)
                continue
            
            # Kontrola długości obiektu BUIN_L
            geom = obj.geometry()
            obj_length = geom.length()
            
            if obj_length < 25:
                # Sprawdzanie, czy obiekt dotyka granicy
                if not any(obj.geometry().intersects(boundary.geometry()) for boundary in granica.getFeatures()):
                    if obj.id() not in dodane_bledy_ids:
                        obiektyZbledami.append(obj)
                        dodane_bledy_ids.add(obj.id())
                    continue  # Odrzucenie obiektu, jeśli nie styka się z granicą
                    
            # Tworzenie bufora dla geometrii obiektu BUIN_L
            buffer_distance = 5  # Odległość bufora w metrach
            buffered_geometry = geom.buffer(buffer_distance, 5)  # Bufor 5 m z zaokrągleniem 5 segmentów
            
            # Sprawdzenie obiektów SKTR w buforze
            nearby_sktr_ids = index_sktr.intersects(buffered_geometry.boundingBox())
            nearby_sktr = [sktr.getFeature(fid) for fid in nearby_sktr_ids]
            
            # Weryfikacja atrybutu 'położenie' w obiektach SKTR
            sktr_valid_positions = []
            sktr_invalid_positions = []  # Lista obiektów SKTR, które mają błędny lub brakujący atrybut 'polozenie'
            for sktr_obj in nearby_sktr:
                try:
                    if sktr_obj['polozenie'] == 'na powierzchni gruntu':
                        sktr_valid_positions.append(sktr_obj)
                    else:
                        sktr_invalid_positions.append(sktr_obj)  # Obiekt SKTR ma niewłaściwe położenie
                except KeyError:
                    sktr_invalid_positions.append(sktr_obj)  # Obiekt SKTR nie ma atrybutu 'polozenie'
                    
            # Sprawdzenie obiektów SKJZ w buforze
            nearby_skjz_ids = index_skjz.intersects(buffered_geometry.boundingBox())
            nearby_skjz = [skjz.getFeature(fid) for fid in nearby_skjz_ids]
            
            # Logika decyzji
            if len(sktr_valid_positions) > 0:
                continue
            
            if len(nearby_sktr) > 0 and len(nearby_skjz) == 0:
                continue
            
            # Jeśli w buforze znajdują się tylko obiekty SKTR z błędnym lub brakującym atrybutem 'polozenie'
            if len(sktr_invalid_positions) == len(nearby_sktr):
                continue
            
            # Jeśli żaden obiekt SKTR nie spełnia warunku
            if obj.id() not in dodane_bledy_ids:
                obiektyZbledami.append(obj)
                dodane_bledy_ids.add(obj.id())
        return obiektyZbledami
    except Exception as e:
        return []


def kontrolaKodKarto10k219_2(layer):
    try:
        obiektyZbledami = []
        dodane_bledy_ids = set()  # Analiza unikalnych Id obiektów błędnych
        
        if not layer.isValid():
            return []
        
        # Wyszukiwanie warstw OT_SKTR_L i OT_SKJZ_L
        sktr_layer_name = layer.name().replace("OT_BUIN_L", "OT_SKTR_L")
        skjz_layer_name = layer.name().replace("OT_BUIN_L", "OT_SKJZ_L")
        
        sktr_layers = QgsProject.instance().mapLayersByName(sktr_layer_name)
        skjz_layers = QgsProject.instance().mapLayersByName(skjz_layer_name)
        
        if not sktr_layers or not skjz_layers:
            return []
        
        sktr = sktr_layers[0]
        skjz = skjz_layers[0]
        
        # Tworzenie indeksów przestrzennych
        index_buin = QgsSpatialIndex(layer.getFeatures())
        index_sktr = QgsSpatialIndex(sktr.getFeatures())
        index_skjz = QgsSpatialIndex(skjz.getFeatures())
        
        # Filtrowanie warstwy BUIN_L według kodu
        extract_params = {
            'INPUT': layer,
            'EXPRESSION': '"kodKarto10k" = \'0010_219_2\'',
            'OUTPUT': 'memory:'
        }
        extract_result = processing.run("qgis:extractbyexpression", extract_params)
        filtered_layer = extract_result['OUTPUT']
        
        # Filtrowanie obiektów według 'rodzaj' oraz kontrola długości
        for obj in filtered_layer.getFeatures():
            
            # Sprawdzanie, czy rodzaj jest poprawny
            if obj['rodzaj'] != 'tunel':
                obiektyZbledami.append(obj)
                continue
            
            # Kontrola długości obiektu BUIN_L
            geom = obj.geometry()
            obj_length = geom.length()
            
            if obj_length >= 25:
                if obj.id() not in dodane_bledy_ids:
                    obiektyZbledami.append(obj)
                    dodane_bledy_ids.add(obj.id())
                continue  # Odrzucenie obiektu z dalszej analizy, jeśli długość >= 25
                
            # Tworzenie bufora dla geometrii obiektu BUIN_L
            buffer_distance = 5  # Odległość bufora w metrach
            buffered_geometry = geom.buffer(buffer_distance, 5)  # Bufor 5 m z zaokrągleniem 5 segmentów
            
            # Sprawdzenie obiektów SKTR w buforze
            nearby_sktr_ids = index_sktr.intersects(buffered_geometry.boundingBox())
            nearby_sktr = [sktr.getFeature(fid) for fid in nearby_sktr_ids]
            
            # Weryfikacja atrybutu 'położenie' w obiektach SKTR
            sktr_valid_positions = []
            sktr_invalid_positions = []  # Lista obiektów SKTR, które mają błędny lub brakujący atrybut 'polozenie'
            for sktr_obj in nearby_sktr:
                try:
                    if sktr_obj['polozenie'] == 'na powierzchni gruntu':
                        sktr_valid_positions.append(sktr_obj)
                    else:
                        sktr_invalid_positions.append(sktr_obj)  # Obiekt SKTR ma niewłaściwe położenie
                except KeyError:
                    sktr_invalid_positions.append(sktr_obj)  # Obiekt SKTR nie ma atrybutu 'polozenie'
                    
            # Sprawdzenie obiektów SKJZ w buforze
            nearby_skjz_ids = index_skjz.intersects(buffered_geometry.boundingBox())
            nearby_skjz = [skjz.getFeature(fid) for fid in nearby_skjz_ids]
            
            # Logika decyzji
            if len(sktr_valid_positions) > 0:
                continue
                
            if len(nearby_sktr) > 0 and len(nearby_skjz) == 0:
                continue
                
            # Jeśli w buforze znajdują się tylko obiekty SKTR z błędnym lub brakującym atrybutem 'polozenie'
            if len(sktr_invalid_positions) == len(nearby_sktr):
                continue
                
            # Jeśli żaden obiekt SKTR nie spełnia warunku
            if obj.id() not in dodane_bledy_ids:
                obiektyZbledami.append(obj)
                dodane_bledy_ids.add(obj.id())
                
        return obiektyZbledami
    
    except Exception as e:
        return []


def kontrolaKodKarto10k220_1(layer):
    try:
        obiektyZbledami = []
        dodane_bledy_ids = set()
        
        if not layer.isValid():
            return []
        
        # Wyszukiwanie warstw OT_SKTR_L i OT_SKJZ_L
        sktr_layer_name = layer.name().replace("OT_BUIN_L", "OT_SKTR_L")
        skjz_layer_name = layer.name().replace("OT_BUIN_L", "OT_SKJZ_L")
        
        sktr_layers = QgsProject.instance().mapLayersByName(sktr_layer_name)
        skjz_layers = QgsProject.instance().mapLayersByName(skjz_layer_name)
        
        if not sktr_layers or not skjz_layers:
            return []
        
        sktr = sktr_layers[0]
        skjz = skjz_layers[0]
        
        # Tworzenie indeksów przestrzennych
        index_buin = QgsSpatialIndex(layer.getFeatures())
        index_sktr = QgsSpatialIndex(sktr.getFeatures())
        index_skjz = QgsSpatialIndex(skjz.getFeatures())
        
        # Bufor granicy
        granica = adjaMinus2cmBufor(layer)
        
        # Filtrowanie warstwy BUIN_L według kodu
        extract_params = {
            'INPUT': layer,
            'EXPRESSION': '"kodKarto10k" = \'0010_220_1\'',
            'OUTPUT': 'memory:'
        }
        extract_result = processing.run("qgis:extractbyexpression", extract_params)
        filtered_layer = extract_result['OUTPUT']
        filtered_features = list(filtered_layer.getFeatures())
        
        if len(filtered_features) == 0:
            return []
        
        # Filtrowanie obiektów według 'rodzaj' oraz kontrola długości i styku z granicą
        for obj in filtered_features:
            
            if obj['rodzaj'] not in ['estakada', 'wiadukt', 'most']:
                obiektyZbledami.append(obj)
                continue
                
            # Kontrola długości obiektu BUIN_L
            geom = obj.geometry()
            obj_length = geom.length()
            
            # Warunki długości i styku z granicą
            if obj_length < 10:
                # Sprawdzanie, czy obiekt dotyka granicy
                if not any(geom.intersects(boundary.geometry()) for boundary in granica.getFeatures()):
                    if obj.id() not in dodane_bledy_ids:
                        obiektyZbledami.append(obj)
                        dodane_bledy_ids.add(obj.id())
                    continue
                    
            # Tworzenie bufora dla geometrii obiektu BUIN_L
            buffer_distance = 5  # Odległość bufora w metrach
            buffered_geometry = geom.buffer(buffer_distance, 5)
            
            # Sprawdzenie obiektów SKTR w buforze
            nearby_sktr_ids = index_sktr.intersects(buffered_geometry.boundingBox())
            nearby_sktr = [sktr.getFeature(fid) for fid in nearby_sktr_ids]
            
            # Weryfikacja atrybutu 'położenie' w obiektach SKTR
            sktr_valid_positions = []
            sktr_invalid_positions = []
            for sktr_obj in nearby_sktr:
                try:
                    if sktr_obj['polozenie'] == 'na powierzchni gruntu':
                        sktr_valid_positions.append(sktr_obj)
                    else:
                        sktr_invalid_positions.append(sktr_obj)
                except KeyError:
                    sktr_invalid_positions.append(sktr_obj)
                    
            # Sprawdzenie obiektów SKJZ w buforze
            nearby_skjz_ids = index_skjz.intersects(buffered_geometry.boundingBox())
            nearby_skjz = [skjz.getFeature(fid) for fid in nearby_skjz_ids]
            
            # Logika decyzji
            if len(sktr_valid_positions) > 0:
                continue
                
            if len(nearby_sktr) > 0 and len(nearby_skjz) == 0:
                continue
                
            if len(sktr_invalid_positions) == len(nearby_sktr):
                continue
                
            if obj.id() not in dodane_bledy_ids:
                obiektyZbledami.append(obj)
                dodane_bledy_ids.add(obj.id())
                
        return obiektyZbledami
    except Exception as e:
        return []


def kontrolaKodKarto10k220_2(layer):
    try:
        obiektyZbledami = []
        dodane_bledy_ids = set()
        
        if not layer.isValid():
            return []
        
        sktr_layer_name = layer.name().replace("OT_BUIN_L", "OT_SKTR_L")
        skjz_layer_name = layer.name().replace("OT_BUIN_L", "OT_SKJZ_L")
        
        sktr_layers = QgsProject.instance().mapLayersByName(sktr_layer_name)
        skjz_layers = QgsProject.instance().mapLayersByName(skjz_layer_name)
        
        if not sktr_layers or not skjz_layers:
            return []
        
        sktr = sktr_layers[0]
        skjz = skjz_layers[0]
        
        index_buin = QgsSpatialIndex(layer.getFeatures())
        index_sktr = QgsSpatialIndex(sktr.getFeatures())
        index_skjz = QgsSpatialIndex(skjz.getFeatures())
        
        granica = adjaMinus2cmBufor(layer)
        
        extract_params = {
            'INPUT': layer,
            'EXPRESSION': '"kodKarto10k" = \'0010_220_2\'',
            'OUTPUT': 'memory:'
        }
        extract_result = processing.run("qgis:extractbyexpression", extract_params)
        filtered_layer = extract_result['OUTPUT']
        filtered_features = list(filtered_layer.getFeatures())
        
        if len(filtered_features) == 0:
            return []
        
        for obj in filtered_features:
            if obj['rodzaj'] not in ['estakada', 'wiadukt', 'most']:
                obiektyZbledami.append(obj)
                continue
            
            geom = obj.geometry()
            obj_length = geom.length()
            
            buffer_distance = 5 
            buffered_geometry = geom.buffer(buffer_distance, 5)
            
            nearby_sktr_ids = index_sktr.intersects(buffered_geometry.boundingBox())
            nearby_sktr = [sktr.getFeature(fid) for fid in nearby_sktr_ids]
            
            nearby_skjz_ids = index_skjz.intersects(buffered_geometry.boundingBox())
            nearby_skjz = [skjz.getFeature(fid) for fid in nearby_skjz_ids]
            
            # Jeśli obiekt nie styka się z żadnym SKTR
            if len(nearby_sktr) == 0:
                if obj.id() not in dodane_bledy_ids:
                    obiektyZbledami.append(obj)
                    dodane_bledy_ids.add(obj.id())
                continue
            
            # Jeśli BUIN_L ma tylko SKTR w sąsiedztwie
            if len(nearby_sktr) > 0 and len(nearby_skjz) == 0:
                if 3 <= obj_length < 10:
                    continue
                
                if obj_length < 3:
                    if not any(obj.geometry().intersects(boundary.geometry()) for boundary in granica.getFeatures()):
                        if obj.id() not in dodane_bledy_ids:
                            obiektyZbledami.append(obj)
                            dodane_bledy_ids.add(obj.id())
                elif obj_length >= 10:
                    if obj.id() not in dodane_bledy_ids:
                        obiektyZbledami.append(obj)
                        dodane_bledy_ids.add(obj.id())
                continue
            
            sktr_valid_positions = []
            sktr_invalid_positions = []
            for sktr_obj in nearby_sktr:
                try:
                    if sktr_obj['polozenie'] == 'na powierzchni gruntu':
                        sktr_valid_positions.append(sktr_obj)
                    else:
                        sktr_invalid_positions.append(sktr_obj)
                except KeyError:
                    sktr_invalid_positions.append(sktr_obj)
                    
            if len(sktr_valid_positions) > 0:
                continue
            
            if len(sktr_invalid_positions) == len(nearby_sktr):
                continue
            
            if obj.id() not in dodane_bledy_ids:
                obiektyZbledami.append(obj)
                dodane_bledy_ids.add(obj.id())
                
        return obiektyZbledami
    except Exception as e:
        return []


def kontrolaKodKarto10k131_1(layer):
    try:
        obiektyZbledami = []
        dodane_bledy_ids = set()  # Analiza unikalnych Id obiektów błędnych
        
        if not layer.isValid():
            return []
        
        # Wyszukiwanie warstw OT_SKTR_L i OT_SKJZ_L
        skjz_layer_name = layer.name().replace("OT_BUIN_L", "OT_SKJZ_L")
        sktr_layer_name = layer.name().replace("OT_BUIN_L", "OT_SKTR_L")
        
        skjz_layers = QgsProject.instance().mapLayersByName(skjz_layer_name)
        sktr_layers = QgsProject.instance().mapLayersByName(sktr_layer_name)
        
        if not skjz_layers or not sktr_layers:
            return []
        
        skjz = skjz_layers[0]
        sktr = sktr_layers[0]
        
        # Tworzenie indeksów przestrzennych
        index_buin = QgsSpatialIndex(layer.getFeatures())
        index_skjz = QgsSpatialIndex(skjz.getFeatures())
        index_sktr = QgsSpatialIndex(sktr.getFeatures())
        
        # Bufor granicy
        granica = adjaMinus2cmBufor(layer)
        
        # Filtrowanie warstwy BUIN_L według kodu
        extract_params = {
            'INPUT': layer,
            'EXPRESSION': '"kodKarto10k" = \'0010_131_1\'',
            'OUTPUT': 'memory:'
        }
        extract_result = processing.run("qgis:extractbyexpression", extract_params)
        filtered_layer = extract_result['OUTPUT']
        
        # Filtrowanie obiektów według 'rodzaj' oraz kontrola długości
        for obj in filtered_layer.getFeatures():
            
            # Sprawdzanie, czy rodzaj jest poprawny
            if obj['rodzaj'] != 'tunel':
                obiektyZbledami.append(obj)
                continue
            
            # Kontrola długości obiektu BUIN_L
            geom = obj.geometry()
            obj_length = geom.length()
            
            if obj_length < 25:
                # Sprawdzanie, czy obiekt dotyka granicy
                if not any(obj.geometry().intersects(boundary.geometry()) for boundary in granica.getFeatures()):
                    if obj.id() not in dodane_bledy_ids:
                        obiektyZbledami.append(obj)
                        dodane_bledy_ids.add(obj.id())
                    continue  # Odrzucenie obiektu, jeśli nie styka się z granicą
                    
            # Tworzenie bufora dla geometrii obiektu BUIN_L
            buffer_distance = 5  # Odległość bufora w metrach
            buffered_geometry = geom.buffer(buffer_distance, 5)  # Bufor 5 m z zaokrągleniem 5 segmentów
            
            # Sprawdzenie obiektów SKJZ w buforze
            nearby_skjz_ids = index_skjz.intersects(buffered_geometry.boundingBox())
            nearby_skjz = [skjz.getFeature(fid) for fid in nearby_skjz_ids]
            
            # Weryfikacja atrybutu 'położenie' w obiektach SKJZ
            skjz_valid_positions = []
            skjz_invalid_positions = []  # Lista obiektów SKJZ, które mają błędny lub brakujący atrybut 'polozenie'
            for skjz_obj in nearby_skjz:
                try:
                    if skjz_obj['polozenie'] == 'na powierzchni gruntu':
                        skjz_valid_positions.append(skjz_obj)
                    else:
                        skjz_invalid_positions.append(skjz_obj)  # Obiekt SKJZ ma niewłaściwe położenie
                except KeyError:
                    skjz_invalid_positions.append(skjz_obj)  # Obiekt SKJZ nie ma atrybutu 'polozenie'
                    
            # Sprawdzenie obiektów SKTR w buforze
            nearby_sktr_ids = index_sktr.intersects(buffered_geometry.boundingBox())
            nearby_sktr = [sktr.getFeature(fid) for fid in nearby_sktr_ids]
            
            # Logika decyzji
            if len(skjz_valid_positions) > 0:
                continue
                
            if len(nearby_skjz) > 0 and len(nearby_sktr) == 0:
                continue
                
            # Jeśli w buforze znajdują się tylko obiekty SKJZ z błędnym lub brakującym atrybutem 'polozenie'
            if len(skjz_invalid_positions) == len(nearby_skjz):
                continue
                
            # Jeśli żaden obiekt SKJZ nie spełnia warunku
            if obj.id() not in dodane_bledy_ids:
                obiektyZbledami.append(obj)
                dodane_bledy_ids.add(obj.id())
                
        return obiektyZbledami
    except Exception as e:
        return []


def kontrolaKodKarto10k131_2(layer):
    try:
        obiektyZbledami = []
        dodane_bledy_ids = set()  # Analiza unikalnych Id obiektów błędnych
        
        if not layer.isValid():
            return []
            
        # Wyszukiwanie warstw OT_SKTR_L i OT_SKJZ_L
        sktr_layer_name = layer.name().replace("OT_BUIN_L", "OT_SKTR_L")
        skjz_layer_name = layer.name().replace("OT_BUIN_L", "OT_SKJZ_L")
        
        sktr_layers = QgsProject.instance().mapLayersByName(sktr_layer_name)
        skjz_layers = QgsProject.instance().mapLayersByName(skjz_layer_name)
        
        if not sktr_layers or not skjz_layers:
            return []
            
        sktr = sktr_layers[0]
        skjz = skjz_layers[0]
        
        # Tworzenie indeksów przestrzennych
        index_buin = QgsSpatialIndex(layer.getFeatures())
        index_sktr = QgsSpatialIndex(sktr.getFeatures())
        index_skjz = QgsSpatialIndex(skjz.getFeatures())
        
        # Filtrowanie warstwy BUIN_L według kodu
        extract_params = {
            'INPUT': layer,
            'EXPRESSION': '"kodKarto10k" = \'0010_131_2\'',
            'OUTPUT': 'memory:'
        }
        extract_result = processing.run("qgis:extractbyexpression", extract_params)
        filtered_layer = extract_result['OUTPUT']
        
        # Filtrowanie obiektów według 'rodzaj' oraz kontrola długości
        for obj in filtered_layer.getFeatures():
            
            # Sprawdzanie, czy rodzaj jest poprawny
            if obj['rodzaj'] != 'tunel':
                obiektyZbledami.append(obj)
                continue
                
            # Kontrola długości obiektu BUIN_L
            geom = obj.geometry()
            obj_length = geom.length()
            
            if obj_length >= 25:
                if obj.id() not in dodane_bledy_ids:
                    obiektyZbledami.append(obj)
                    dodane_bledy_ids.add(obj.id())
                continue  # Odrzucenie obiektu z dalszej analizy, jeśli długość >= 25
                
            # Tworzenie bufora dla geometrii obiektu BUIN_L
            buffer_distance = 5  # Odległość bufora w metrach
            buffered_geometry = geom.buffer(buffer_distance, 5)  # Bufor 5 m z zaokrągleniem 5 segmentów
            
            # Sprawdzenie obiektów SKJZ w buforze
            nearby_skjz_ids = index_skjz.intersects(buffered_geometry.boundingBox())
            nearby_skjz = [skjz.getFeature(fid) for fid in nearby_skjz_ids]
            
            # Weryfikacja atrybutu 'położenie' w obiektach SKJZ
            skjz_valid_positions = []
            skjz_invalid_positions = []  # Lista obiektów SKJZ, które mają błędny lub brakujący atrybut 'polozenie'
            for skjz_obj in nearby_skjz:
                try:
                    if skjz_obj['polozenie'] == 'na powierzchni gruntu':
                        skjz_valid_positions.append(skjz_obj)
                    else:
                        skjz_invalid_positions.append(skjz_obj)  # Obiekt SKJZ ma niewłaściwe położenie
                except KeyError:
                    skjz_invalid_positions.append(skjz_obj)  # Obiekt SKJZ nie ma atrybutu 'polozenie'
                    
            # Sprawdzenie obiektów SKTR w buforze
            nearby_sktr_ids = index_sktr.intersects(buffered_geometry.boundingBox())
            nearby_sktr = [sktr.getFeature(fid) for fid in nearby_sktr_ids]
            
            # Logika decyzji
            if len(skjz_valid_positions) > 0:
                continue
                
            if len(nearby_skjz) > 0 and len(nearby_sktr) == 0:
                continue
                
            # Jeśli w buforze znajdują się tylko obiekty SKJZ z błędnym lub brakującym atrybutem 'polozenie'
            if len(skjz_invalid_positions) == len(nearby_skjz):
                continue
                
            # Jeśli żaden obiekt SKJZ nie spełnia warunku
            if obj.id() not in dodane_bledy_ids:
                obiektyZbledami.append(obj)
                dodane_bledy_ids.add(obj.id())
                
        return obiektyZbledami
    
    except Exception as e:
        return []


def kontrolaKodKarto10k133_1(layer):
    try:
        obiektyZbledami = []
        dodane_bledy_ids = set()
        
        if not layer.isValid():
            return []
        
        # Wyszukiwanie warstw OT_SKJZ_L i OT_SKTR_L
        skjz_layer_name = layer.name().replace("OT_BUIN_L", "OT_SKJZ_L")
        sktr_layer_name = layer.name().replace("OT_BUIN_L", "OT_SKTR_L")
        
        skjz_layers = QgsProject.instance().mapLayersByName(skjz_layer_name)
        sktr_layers = QgsProject.instance().mapLayersByName(sktr_layer_name)
        
        if not skjz_layers or not sktr_layers:
            return []
        
        skjz = skjz_layers[0]
        sktr = sktr_layers[0]
        
        # Tworzenie indeksów przestrzennych
        index_buin = QgsSpatialIndex(layer.getFeatures())
        index_skjz = QgsSpatialIndex(skjz.getFeatures())
        index_sktr = QgsSpatialIndex(sktr.getFeatures())
        
        granica = adjaMinus2cmBufor(layer)
        
        extract_params = {
            'INPUT': layer,
            'EXPRESSION': '"kodKarto10k" = \'0010_133_1\'',
            'OUTPUT': 'memory:'
        }
        extract_result = processing.run("qgis:extractbyexpression", extract_params)
        filtered_layer = extract_result['OUTPUT']
        filtered_features = list(filtered_layer.getFeatures())
        
        if len(filtered_features) == 0:
            return []
            
        # Filtrowanie obiektów według 'rodzaj' oraz kontrola długości i styku z granicą
        for obj in filtered_features:
            
            if obj['rodzaj'] not in ['estakada', 'wiadukt', 'most']:
                obiektyZbledami.append(obj)
                continue
                
            geom = obj.geometry()
            obj_length = geom.length()
            
            if obj_length < 10:
                if not any(geom.intersects(boundary.geometry()) for boundary in granica.getFeatures()):
                    if obj.id() not in dodane_bledy_ids:
                        obiektyZbledami.append(obj)
                        dodane_bledy_ids.add(obj.id())
                    continue
                    
            buffer_distance = 5
            buffered_geometry = geom.buffer(buffer_distance, 5)
            
            # Sprawdzenie obiektów SKJZ w buforze
            nearby_skjz_ids = index_skjz.intersects(buffered_geometry.boundingBox())
            nearby_skjz = [skjz.getFeature(fid) for fid in nearby_skjz_ids]
            
            # Sprawdzenie obiektów SKTR w buforze
            nearby_sktr_ids = index_sktr.intersects(buffered_geometry.boundingBox())
            nearby_sktr = [sktr.getFeature(fid) for fid in nearby_sktr_ids]
            
            # SKTR w pobliżu, brak SKJZ
            if len(nearby_sktr) > 0 and len(nearby_skjz) == 0:
                if obj.id() not in dodane_bledy_ids:
                    obiektyZbledami.append(obj)
                    dodane_bledy_ids.add(obj.id())
                continue
            
            # Weryfikacja atrybutu 'położenie' w obiektach SKJZ
            skjz_valid_positions = []
            skjz_invalid_positions = []
            for skjz_obj in nearby_skjz:
                try:
                    if skjz_obj['polozenie'] is None or skjz_obj['polozenie'] == 'na powierzchni gruntu':
                        skjz_valid_positions.append(skjz_obj)
                    else:
                        skjz_invalid_positions.append(skjz_obj)
                except KeyError:
                    skjz_invalid_positions.append(skjz_obj)
                    
            # Logika decyzji
            if len(skjz_valid_positions) > 0:
                continue
            
            if len(nearby_skjz) > 0 and len(nearby_sktr) == 0:
                continue
            
            if len(skjz_invalid_positions) == len(nearby_skjz):
                continue
            
            if obj.id() not in dodane_bledy_ids:
                obiektyZbledami.append(obj)
                dodane_bledy_ids.add(obj.id())
                
        return obiektyZbledami
    
    except Exception as e:
        return []


def kontrolaKodKarto10k133_2(layer):
    try:
        obiektyZbledami = []
        dodane_bledy_ids = set()
        
        if not layer.isValid():
            return []
        
        skjz_layer_name = layer.name().replace("OT_BUIN_L", "OT_SKJZ_L")
        sktr_layer_name = layer.name().replace("OT_BUIN_L", "OT_SKTR_L")
        
        skjz_layers = QgsProject.instance().mapLayersByName(skjz_layer_name)
        sktr_layers = QgsProject.instance().mapLayersByName(sktr_layer_name)
        
        if not skjz_layers or not sktr_layers:
            return []
        
        skjz = skjz_layers[0]
        sktr = sktr_layers[0]
        
        index_buin = QgsSpatialIndex(layer.getFeatures())
        index_skjz = QgsSpatialIndex(skjz.getFeatures())
        index_sktr = QgsSpatialIndex(sktr.getFeatures())
        
        granica = adjaMinus2cmBufor(layer)
        distance_threshold = 10
        
        extract_params = {
            'INPUT': layer,
            'EXPRESSION': '"kodKarto10k" = \'0010_133_2\'',
            'OUTPUT': 'memory:'
        }
        extract_result = processing.run("qgis:extractbyexpression", extract_params)
        filtered_layer = extract_result['OUTPUT']
        
        for obj in filtered_layer.getFeatures():
            if obj.id() in dodane_bledy_ids:
                continue  # Jeśli obiekt już dodano, pomijamy dalsze sprawdzenia
            
            if obj['rodzaj'] not in ['estakada', 'wiadukt', 'most']:
                obiektyZbledami.append(obj)
                dodane_bledy_ids.add(obj.id())
                continue
            
            obj_length = obj.geometry().length()
            obj_centroid = obj.geometry().centroid()
            
            nearby_skjz_ids = []
            nearby_sktr_ids = []
            
            for skjz_obj in skjz.getFeatures():
                if obj_centroid.distance(skjz_obj.geometry().centroid()) <= distance_threshold:
                    nearby_skjz_ids.append(skjz_obj.id())
                    
            for sktr_obj in sktr.getFeatures():
                if obj_centroid.distance(sktr_obj.geometry().centroid()) <= distance_threshold:
                    nearby_sktr_ids.append(sktr_obj.id())
                    
            if len(nearby_skjz_ids) > 0 and len(nearby_sktr_ids) == 0:
                if 3 <= obj_length < 10:
                    continue
                    
                if obj_length < 3:
                    if not any(obj.geometry().intersects(boundary.geometry()) for boundary in granica.getFeatures()):
                        obiektyZbledami.append(obj)
                        dodane_bledy_ids.add(obj.id())
                elif obj_length >= 10:
                    obiektyZbledami.append(obj)
                    dodane_bledy_ids.add(obj.id())
                
                if 3 <= obj_length < 10:
                    for skjz_obj in skjz.getFeatures():
                        if obj.geometry().distance(skjz_obj.geometry()) < distance_threshold:
                            if skjz_obj['polozenie'] is None or skjz_obj['polozenie'] == 'na powierzchni gruntu':
                                obiektyZbledami.append(obj)
                                dodane_bledy_ids.add(obj.id())
                                break
                        
            elif len(nearby_sktr_ids) > 0 and len(nearby_skjz_ids) == 0:
                obiektyZbledami.append(obj)
                dodane_bledy_ids.add(obj.id())
                
            else:
                for sktr_obj in sktr.getFeatures():
                    if obj.geometry().distance(sktr_obj.geometry()) < distance_threshold:
                        polozenie = sktr_obj['polozenie']
                        if polozenie is None or polozenie.strip().lower() != 'na powierzchni gruntu':
                            obiektyZbledami.append(obj)
                            dodane_bledy_ids.add(obj.id())
                            break
        
        return obiektyZbledami
    
    except Exception:
        return []


def kontrolaKodKarto10k134_1(layer):
    try:
        obiektyZbledami = []
        granica = adjaMinus2cmBufor(layer)
        for obj in layer.getFeatures():
            try:
                if obj["kodKarto10k"] == '0010_134_1':
                    if obj['rodzaj'] != 'kładka':
                        obiektyZbledami.append(obj)
                        continue
                    geom = obj.geometry()
                    touches_boundary = any(geom.intersects(boundary.geometry()) for boundary in granica.getFeatures())
                    if not touches_boundary:
                        if not (geom.length() >= 10):
                            obiektyZbledami.append(obj)
            except Exception:
                 pass
        return obiektyZbledami
    
    except Exception:
        return []


def kontrolaKodKarto10k134_2(layer):
    try:
        obiektyZbledami = []
        granica = adjaMinus2cmBufor(layer)
        for obj in layer.getFeatures():
            try:
                if obj["kodKarto10k"] == '0010_134_2':
                    if obj['rodzaj'] != 'kładka':
                        obiektyZbledami.append(obj)
                        continue
                    geom = obj.geometry()
                    touches_boundary = any(obj.geometry().intersects(boundary.geometry()) for boundary in granica.getFeatures())
                    if not touches_boundary:
                        if geom.length() < 3 or geom.length() > 10:
                            obiektyZbledami.append(obj)
            except Exception:
                pass
        return obiektyZbledami
        
    except Exception:
        return []


def kontrolaKodKarto10k638_1(layer):
    try:
        obiektyZbledami = []
        granica = adjaMinus2cmBufor(layer)
        for obj in layer.getFeatures():
            try:
                if obj["kodKarto10k"] == '0010_638_1':
                    if obj['rodzaj'] != 'akwedukt':
                        obiektyZbledami.append(obj)
                        continue
                    geom = obj.geometry()
                    touches_boundary = any(obj.geometry().intersects(boundary.geometry()) for boundary in granica.getFeatures())
                    if not touches_boundary:
                        if not (geom.length() >= 10):
                            obiektyZbledami.append(obj)
            except Exception:
                 pass
        return obiektyZbledami
        
    except Exception:
        return []


def kontrolaKodKarto10k638_2(layer):
    try:
        obiektyZbledami = []
        granica = adjaMinus2cmBufor(layer)
        for obj in layer.getFeatures():
           try:
               if obj["kodKarto10k"] == '0010_638_2':
                   if obj['rodzaj'] != 'akwedukt':
                       obiektyZbledami.append(obj)
                       continue
                   geom = obj.geometry()
                   touches_boundary = any(obj.geometry().intersects(boundary.geometry()) for boundary in granica.getFeatures())
                   
                   if not touches_boundary:
                       if not (geom.length() < 10):
                           obiektyZbledami.append(obj)
           except Exception:
                pass
        return obiektyZbledami
        
    except Exception:
        return []


global lokalneIdWRamachKlas
lokalneIdWRamachKlas = {}

def unikalnoscLokalnyIdWPliku(layer, plikGML):
    obiektyZbledami = []
    
    ns = {'gml':'http://www.opengis.net/gml/3.2', 'ot':'urn:gugik:specyfikacje:gmlas:bazaDanychObiektowTopograficznych10k:2.0'}
    lokalnyIds_elem = plikGML.getroot().findall(".//ot:lokalnyId", ns)
    lokalnyIds = []
    
    for lokalnyId in lokalnyIds_elem:
        lokalnyIds.append(lokalnyId.text)
    
    unikalne = set()
    zdublowane = set()
    zdublowaneWRamachKlas = {}
    
    for element in lokalnyIds:
        if element in unikalne:
            zdublowane.add(element)
        else:
            unikalne.add(element)
    
    for element in unikalne:
        if element in lokalneIdWRamachKlas:
            zdublowaneWRamachKlas[element] = layer.name()
        else:
            lokalneIdWRamachKlas[element] = layer.name()
    
    zdublowane_lista = list(zdublowane)
    zdublowaneWRamachKlas_lista = list(zdublowaneWRamachKlas.keys())
    
    for obj in layer.getFeatures():
        if obj['lokalnyId'] in zdublowane_lista:
            gml_id = obj['gml_id'] + '| w ramach tej samej klasy'
            obj.setAttribute(layer.fields().indexFromName("gml_id"), gml_id)
            layer.updateFeature(obj)
            obiektyZbledami.append(obj)
            layer.commitChanges()
    
    for obj in layer.getFeatures():
        if obj['lokalnyId'] in zdublowaneWRamachKlas_lista:
            gml_id = obj['gml_id'] + '| w ramach klasy: ' + str(lokalneIdWRamachKlas[obj['lokalnyId']])
            obj.setAttribute(layer.fields().indexFromName("gml_id"), gml_id)
            layer.updateFeature(obj)
            obiektyZbledami.append(obj)
            layer.commitChanges()
    
    return obiektyZbledami


def kontrolaRelacjiDzialkaEwidencyjnaDoPunktGraniczny(layer):
    obiektyZbledami = []
    
    try:
        PunktGranicyDzialkiEwidencyjnej_layer = QgsProject().instance().mapLayersByName(layer.name().replace("DzialkaEwidencyjna","PunktGraniczny"))[0]
    except:
        PunktGranicyDzialkiEwidencyjnej_layer = None
    
    fields =  layer.fields()
    
    for obj in layer.getFeatures():
         jestBlad = False
         
         if 'punktGranicyDzialki_href' in [field.name() for field in fields] and isinstance(obj['punktGranicyDzialki_href'], list):
            if len(obj['punktGranicyDzialki_href']) < 3:
                jestBlad = True
         else:
            jestBlad = True
        
         if jestBlad:
            gml_id = obj['gml_id'] + '| brak min. 3 referencji na punkty graniczne'
            obj.setAttribute(layer.fields().indexFromName("gml_id"), gml_id)
            layer.updateFeature(obj)
            obiektyZbledami.append(obj)
            layer.commitChanges()
    
    if 'punktGranicyDzialki_href' in [field.name() for field in fields]:
        extractbyexpression = processing.run("qgis:extractbyexpression", {
            'INPUT': layer,
            'EXPRESSION': "'punktGranicyDzialki_href' IS NOT NULL",
            'FAIL_OUTPUT': 'memory:',
            'OUTPUT': 'memory:'
        })
    else:
        return obiektyZbledami
    
    if extractbyexpression['OUTPUT'].featureCount() > 0 and layer.featureCount() > 0:
        punktyGranicyDzialki_hrefy = set()
        
        gmlid_PunktyGraniczne = set()
        if PunktGranicyDzialkiEwidencyjnej_layer != None:
            for obj_PG in PunktGranicyDzialkiEwidencyjnej_layer.getFeatures():
                gmlid_PunktyGraniczne.add(obj_PG['gml_id'])
        
        for obj in extractbyexpression['OUTPUT'].getFeatures():
            gml_id = ''
            if isinstance(obj['punktGranicyDzialki_href'], list):
                for gmlid in obj['punktGranicyDzialki_href']:
                    if gmlid == '':
                        gml_id += ' pusta referencja na punkt graniczny;'
                    else:
                        punktyGranicyDzialki_hrefy.add(gmlid)
                        if not gmlid in gmlid_PunktyGraniczne:
                            gml_id += 'referencja "' + gmlid + '" na punkt graniczny, którego nie ma w pliku gml;'
            else:
                if obj['punktGranicyDzialki_href'] != NULL:
                    punktyGranicyDzialki_hrefy.add(obj['punktGranicyDzialki_href'])
            
            if gml_id != '':
                gml_id = obj['gml_id'] + '| ' + gml_id
                obj.setAttribute(layer.fields().indexFromName("gml_id"), gml_id)
                layer.updateFeature(obj)
                obiektyZbledami.append(obj)
                layer.commitChanges()
    
    return obiektyZbledami


def zapisWspolrzednychKonturow(layer, plikGML):
    obiektyZbledami = []
    pattern = re.compile(r"[0-9]{6}\.[0-9]{3,}")
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'gr': 'urn:gugik:specyfikacje:gmlas:mapaGlebowoRolnicza:1.0'}
    konturyGlebowe = plikGML.findall('.//gr:GR_KonturGlebowy', namespaces=ns)
    for konturGlebowy in konturyGlebowe:
            lokalnyId = konturGlebowy.find('.//gr:lokalnyId', namespaces=ns).text
            expression = f"\"lokalnyId\" = '{lokalnyId}'"
            request = QgsFeatureRequest().setFilterExpression(expression)
            geometria = konturGlebowy.findall('.//gr:geometria', namespaces=ns)
            for g in geometria:
                geom = g.findall('.//gml:Polygon', namespaces=ns)
                for e in geom:
                    ex = e.findall('.//gml:exterior', namespaces=ns)
                    for f in ex:
                        liner = f.findall('.//gml:LinearRing', namespaces=ns)
                        for l in liner:
                            posList = l.find('.//gml:posList', namespaces=ns).text
                            if pattern.search(posList):
                                    for feature in layer.getFeatures(request):
                                        obiektyZbledami.append(feature)
    
    return obiektyZbledami


def zapisWspolrzednychOdkrywek(layer, plikGML):
    obiektyZbledami = []
    pattern = re.compile(r"[0-9]{6}\.[0-9]{3,}")
    plikGML = plikGML.getroot()
    ns = {'gml': 'http://www.opengis.net/gml/3.2', 'gr': 'urn:gugik:specyfikacje:gmlas:mapaGlebowoRolnicza:1.0'}
    odkrywkiGlebowe = plikGML.findall('.//gr:GR_OdkrywkaGlebowa', namespaces=ns)
    for odkrywkaGlebowa in odkrywkiGlebowe:
            lokalnyId = odkrywkaGlebowa.find('.//gr:lokalnyId', namespaces=ns).text
            expression = f"\"lokalnyId\" = '{lokalnyId}'"
            request = QgsFeatureRequest().setFilterExpression(expression)
            geometria = odkrywkaGlebowa.findall('.//gr:geometria', namespaces=ns)
            for g in geometria:
                geom = g.findall('.//gml:Point', namespaces=ns)
                for e in geom:
                    pos = e.find('.//gml:pos', namespaces=ns).text
                    if pattern.search(pos):
                        for feature in layer.getFeatures(request):
                            obiektyZbledami.append(feature)
    
    return obiektyZbledami


def kontrolaGeometriiGML_luki(layer, plikGML, klasa):
    obiektyZbledami = set()
    global gml_id_set
    gml_id_set = set()
    nieobslugiwanyTypGeometrii = QgsVectorLayer("Point?crs=epsg:2180&field=gml_id:string(254)", "Geometrie o nieobsługiwanym typie", "memory")
    
    ns = {'gml':'http://www.opengis.net/gml/3.2',
          'ot':'bazaDanychObiektowTopograficznych500:1.0',
          'ges':'geodezyjnaEwidencjaSieciUzbrojeniaTerenu:1.0',
          'egb':'ewidencjaGruntowIBudynkow:1.0'
          }
    
    if 'OT_' in klasa:
        klasy = plikGML.getroot().findall(".//ot:" + klasa, ns)
    elif 'EGB_' in klasa:
        klasy = plikGML.getroot().findall(".//egb:" + klasa, ns)
    else:
        klasy = plikGML.getroot().findall(".//ges:" + klasa, ns)
    
    for klasa in klasy:
        gml_id = klasa.attrib.get("{http://www.opengis.net/gml/3.2}id")
        
        for curve in klasa.findall(".//gml:Curve", ns):
            unusual_segments = {}
            for segment in curve.findall(".//*", ns):
                # ArcByCenterPoint, ArcString, Arc, ArcStringByBulge, ArcByBulge
                # CircleByCenterPoint, Circle
                if 'Arc' in segment.tag.split('}')[-1] or 'Circle' in segment.tag.split('}')[-1]:
                    gml_id_set.add(gml_id)
                    break
    
    nieobslugiwanyTypGeometrii.startEditing()
    for gmlid in gml_id_set:
        nowyRekord = QgsFeature(nieobslugiwanyTypGeometrii.fields())
        nowyRekord.setAttribute(0, gmlid)
        nowyRekord.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(0, 0)))
        nieobslugiwanyTypGeometrii.addFeature(nowyRekord)
        nieobslugiwanyTypGeometrii.commitChanges()
        obiektyZbledami.add(nowyRekord)
    
    del nieobslugiwanyTypGeometrii
    
    return obiektyZbledami